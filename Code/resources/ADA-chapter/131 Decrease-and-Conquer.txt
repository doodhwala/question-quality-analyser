plutarch sertorius teach soldiers perseverance wit brute horses brought set men tails men burly hercules tugged purpose sharp weasel faced tailor plucked hair roars laughter left tail cobham brewer dictionary phrase fable decrease conquer technique based exploiting relationship solution instance problem solution smaller instance relationship established exploited leads naturally recursive implementa tion examples chapter ultimate implementation nonrecursive variation implemented iteratively starting solution smallest instance problem called incremental approach major variations decrease conquer decrease constant decrease constant factor variable size decrease constant variation size instance reduced constant iteration algorithm typically constant equal figure constant size reductions occasionally exponentiation problem computing nonnegative integer relationship solution instance size instance size obtained obvious formula function computed recursive definition problem size subproblem size solution subproblem solution original problem figure decrease conquer technique multiplying times brute algorithm thought process interesting examples decrease algorithms sections decrease constant factor technique suggests reducing problem instance constant factor iteration algorithm applications constant factor equal algorithm decrease half idea illustrated figure revisit exponentiation problem instance size compute instance half size compute obvious relationship instances integer exponents odd compute valued exponents result summarize formula problem size subproblem size solution subproblem solution original problem figure decrease half conquer technique positive odd compute recursively formula algorithm efficiency multiplications algorithm log iteration size reduced half expense multiplications examples decrease constant factor algorithms section exercises algorithms efficient examples kind finally variable size decrease variety decrease conquer size reduction pattern varies iteration algorithm euclid algorithm computing greatest common divisor good situation recall algorithm based formula gcd mod argument smaller left decreases constant factor examples algorithms section insertion sort section application decrease technique sorting array technique idea assume smaller problem sorting array solved sorted array size advantage solution smaller problem solution original problem taking account element position sorted elements insert scanning sorted subarray left element smaller equal encountered insert element resulting algorithm called straight insertion sort simply insertion sort insertion sort based recursive idea efficient implement algorithm iteratively shown figure starting ending inserted elements array sorted selection sort generally final positions pseudocode algorithm insertionsort sorts array insertion sort input array orderable elements output array sorted nondecreasing smaller equal greater figure iteration insertion sort inserted proper position preceding elements previously sorted figure sorting insertion sort vertical separates sorted array remaining elements element inserted bold operation algorithm illustrated figure basic operation algorithm key comparison faster actual implementation germane algorithm implementation sentinel problem section exercises eliminates altogether key comparisons algorithm depends nature input worst case executed largest times fact ith iteration insertion sort elements preceding elements input albeit sorted worst case input words worst case input array strictly decreasing values key comparisons input cworst worst case insertion sort makes comparisons selection sort section case comparison executed iteration outer loop input array sorted nondecreasing makes sense case algorithm problem solved case discussion quicksort chapter sorted arrays key comparisons cbest good performance case sorted arrays convenient inputs sorted files arise variety applications insertion sort preserves excellent performance inputs rigorous analysis algorithm average case efficiency based investigating element pairs problem section exercises shows randomly ordered arrays insertion sort makes average half comparisons decreasing arrays cavg fast average case performance coupled excellent efficiency sorted arrays makes insertion sort stand principal petitors elementary sorting algorithms selection sort addition extension named shellsort inventor shell algorithm sorting moderately large files problem section exercises ferrying soldiers detachment soldiers wide deep river bridge sight year boys playing rowboat shore boat tiny hold boys soldier soldiers river leave boys joint possession boat times boat shore alternating glasses standing row filled soda drink remaining glasses make glasses alternate filled pattern minimum glass moves gar solve problem glasses drink initially random marking cells design algorithm task cells infinite sheet graph paper marked cell odd marked neighbors cells considered neighbors horizontally vertically diagonally marked cells contiguous region path pair marked cells sequence marked neighbors kor design decrease algorithm generating power set elements power set subsets set algorithm connectivity graph defined adjacency matrix algorithm connected input adjacency matrix undirected graph output true connected false vertex graph connected definition connected algorithm correctly undirected graph vertices algorithm efficiency class worst case team ordering results completed robin tournament teams played game ended victory teams design algorithm lists teams sequence team lose game team listed immediately efficiency class algorithm apply insertion sort alphabetical sentinel element array sorted checking bound condition iteration loop insertion sort sentinel version efficiency class original version implement insertion sort sorting linked lists efficiency array version text implementation insertion sort ver sion algorithm insertsort swap efficiency algorithm compared version section array sortable elements simplicity assume elements distinct pair called inversion arrays size largest inversions questions smallest inversions average case key comparisons insertion sort formula cavg shellsort accurately shell sort important sorting algorithm works applying insertion sort interleaving sublists formed stepping increment predefined decreasing sequence sizes algorithm works sequence sequences yield efficiency sequence reverse purpose apply shellsort stable sorting algorithm implement shellsort straight insertion sort selection sort language choice performance random arrays sizes increasing decreasing arrays sizes topological sorting section discuss important problem directed graphs variety applications involving prerequisite restricted tasks pose problem review basic facts directed graphs directed graph digraph short graph directions edges figure adjacency matrix adjacency lists principal means representing digraph notable differences undirected directed graphs representing adjacency matrix directed graph symmetric edge directed graph nodes digraph adjacency lists figure digraph dfs forest digraph dfs traversal started depth breadth principal traversal algorithms traversing digraphs structure forests complex undirected graphs simple figure depth forest figure exhibits types edges dfs forest directed graph tree edges vertices ancestors forward edges vertices descendants tree children edges aforementioned types edge dfs forest directed graph vertex parent case presence edge digraph directed digraph sequence vertices starts ends vertex connected predecessor edge directed predecessor successor directed digraph figure conversely dfs forest digraph edges digraph dag acronym directed acyclic graph edge directions lead questions digraphs meaningless trivial undirected graphs section discuss motivating set required courses student degree courses prerequisites met prerequisites requires student term student courses situation modeled digraph vertices represent courses directed edges prerequisite requirements figure terms digraph vertices edge graph vertex edge starts listed vertex edge ends ordering digraph vertices problem called topological sorting posed figure digraph representing prerequisite structure courses popping topologically sorted figure digraph topological sorting problem solved dfs traversal stack subscript numbers indicating popping solution problem arbitrary digraph easy problem solution digraph directed topological sorting digraph dag turns dag sufficient topological sorting digraph directed cycles topological sorting problem solution efficient algorithms verify digraph dag ordering vertices solves topological sorting problem algorithm simple application depth dfs traversal vertices dead ends popped traversal stack reversing yields solution topological sorting problem provided edge encountered traversal edge encountered digraph dag topological sorting vertices impossible algorithm vertex popped dfs stack vertex edge vertices popped edge vertex listed popped reversed figure illustrates application algorithm digraph fig ure figure drawn edges digraph left problem statement requires venient visually correctness solution instance topological sorting problem delete solution obtained figure illustration source removal algorithm topological sorting problem iteration vertex incoming edges deleted digraph algorithm based direct implementation decrease conquer technique repeatedly remaining digraph source vertex incoming edges delete edges outgoing sources break arbitrarily problem solved problem section exercises vertices deleted yields solution topological sorting problem application algorithm digraph representing courses figure solution obtained source removal algorithm obtained dfs based algorithm topological sorting problem alternative solutions tiny size create wrong impression topological sorting problem large project construction research software development involves multitude interrelated tasks prerequisites thing situation make set prerequisites contradictory convenient solve topological sorting problem project digraph thinking scheduling tasks minimize total completion project require algorithms general books operations research special cpm critical path method pert evaluation review technique methodologies applications topological sorting science instruction scheduling compilation cell evaluation ordering spreadsheet formulas resolving symbol dependencies linkers exercises apply dfs based algorithm solve topological sorting problem digraphs prove topological sorting problem solution dag digraph vertices largest distinct solutions topological sorting problem efficiency dfs based algorithm topological sorting modify dfs based algorithm reversing vertex ordering generated dfs vertices pushed dfs stack popped solve topological sorting problem apply source removal algorithm digraphs problem prove nonempty dag source determine vertex digraph represented adjacency matrix efficiency operation source determine vertex digraph represented adjacency lists efficiency operation implement source removal algorithm digraph represented adjacency lists running implement topological sorting algorithms language choice run experiment running times digraph called strongly connected pair distinct vertices exists directed path directed path general digraph vertices partitioned disjoint maximal subsets vertices mutually accessible directed paths subsets called strongly connected components digraph dfs based algorithms identifying strongly connected components simpler efficient dfs traversal digraph vertices dead ends reverse directions edges digraph dfs traversal digraph starting restarting traversal highest numbered vertex unvisited vertices strongly connected components vertices dfs trees obtained traversal apply algorithm digraph determine strongly connected components efficiency class algorithm answers adjacency matrix representation adjacency representation input digraph strongly connected components dag spider web spider sits web fly sits ways spider fly moving web lines directions arrows kor algorithms generating combinatorial objects section discuss algorithms generating combi natorial objects important types combinatorial objects permuta tions combinations subsets set typically arise problems require consideration choices encountered chapter discussed exhaustive combinatorial objects stud ied discrete mathematics called combinatorics mathematicians primarily interested counting formulas ful formulas items generated combinatorial objects typically grows exponentially faster function problem size primary lies algorithms generating combinatorial objects counting generating permutations simplicity assume underlying set elements permuted simply set integers generally interpreted indices elements element set decrease technique problem generating permutations smaller problem generate permutations assuming smaller problem solved solution larger inserting positions elements permutation elements permu tations obtained fashion distinct total permutations insert previously generated permutations left turns beneficial inserting moving left direction permutation processed applying approach figure advantage generating permutations stems fact satisfies minimal requirement permutation tained predecessor exchanging elements method discussed elements adjacent insert left insert left insert left figure generating permutations generated figure minimal requirement beneficial algorithm speed applications permutations section needed permutations cities solve traveling salesman problem exhaustive permutations generated minimal algorithm compute length predecessor constant linear ordering permutations elements explicitly generating permutations smaller values associating direction element permutation direction small arrow written element mobile arrow marked permutation arrow points smaller adjacent permutation mobile notion mobile element description johnson trotter algorithm generating permutations algorithm johnsontrotter implements johnson trotter algorithm generating permutations input positive integer output permutations initialize permutation mobile element largest mobile element swap adjacent element arrow points reverse direction elements larger permutation application algorithm largest mobile element shown bold algorithm efficient generating permutations implemented run proportional permutations horribly small values algorithm fault problem simply asks generate items permutation ordering generated johnsontrotter algorithm natural permutation case permutations listed increasing called lexicographic der listed dictionary numbers interpreted letters alphabet generate permutation lexi cographic case half permutations simply transpose elements permutation longest decreasing suffix exchanging smallest element suffix greater reverse suffix increasing pseudocode simple algorithm origins century india algorithm lexicographicpermute generates permutations lexicographic input positive integer output permutations lexicographic initialize permutation consecutive elements increasing largest index largest index swap decreasing reverse elements inclusive permutation generating subsets recall section examined knapsack problem asks valuable subset items fits knapsack capacity exhaustive approach solving problem discussed based generating subsets set items section discuss algorithms generating subsets abstract set mathematicians set subsets set power set decrease idea immediately applicable problem subsets divided groups group subsets element obtained adding subset subsets adding elements application algorithm generate subsets illustrated figure similarly generating permutations generate power sets smaller sets convenient solving problem directly based correspondence subsets element set subsets figure generating subsets bit strings length easiest establish correspondence assign subset bit string belongs subset mentioned idea bit vectors section bit string correspond subset element set correspond set represent correspondence generate bit strings length generating successive binary numbers padded leading case bit strings subsets bit strings generated algorithm lexicographic symbol alphabet subsets natural called squashed subset involving listed subsets involving case element set figure easy adjust bit string based algorithm yield squashed ordering subsets involved problem section exercises challenging exists minimal algorithm generating bit strings differs predecessor single bit language subsets subset differ predecessor addition deletion single element sequence bit strings called binary reflected gray code frank gray researcher bell laboratories reinvented minimize effect errors transmitting digital signals ros years earlier french engineer mile baudot codes telegraphy pseudocode generates binary reflected gray code recursively algorithm brgc generates recursively binary reflected gray code input positive integer output bit strings length composing gray code make bit strings generate bit strings size calling brgc reversed bit string bit string append correctness algorithm stems fact generates bit strings distinct assertions easy mathematical induction binary reflected gray code cyclic bit string differs single bit nonrecursive algorithm generating binary reflected gray code problem section exercises realistic implement algorithm requires generating permu tations element set subsets set generate permutations minimal algorithm johnson trotter algorithm lexicographic algorithm apply lexicographicpermute multiset generate correctly permutations lexicographic implementation algorithm generating mutations discovered hea algorithm heappermute implements algorithm generating permutations input positive integer global array output permutations elements write heappermute odd swap algorithm prove correctness algorithm efficiency heappermute generate subsets element set algorithms outlined section simple make bit string based algorithm generate subsets squashed write pseudocode recursive algorithm generating bit strings length write nonrecursive algorithm generating bit strings length implements bit strings arrays binary additions generate binary reflexive gray code nonrecursive algorithm generate binary flexive gray code bit string generate ith bit string flipping bit previ ous bit string position significant binary representation design decrease conquer algorithm generating combinations items chosen element subsets element set algorithm minimal algorithm gray code tower hanoi disk moves classic recursive algorithm tower hanoi puzzle generating binary reflected gray code binary reflected gray code solving tower hanoi puzzle fair attraction olden days encounter attraction fair light bulb connected switches lighted switches closed controlled button pressing button toggled state light bulb design algorithm light bulb minimum button pushes needed worst case switches decrease constant factor algorithms recall introduction chapter decrease constant factor major variety decrease conquer algorithm based technique mentioned exponentiation squar ing defined formula section examples algorithms important binary decrease constant factor algorithms run logarithmic ing efficient reduction factor rare binary remarkably efficient algorithm searching sorted array works comparing key array middle element algorithm stops operation repeated recursively half array half apply binary searching array iterations algorithm table index iteration binary based recursive idea easily implemented nonrecursive algorithm pseudocode nonre cursive version algorithm binarysearch implements nonrecursive binary input array sorted ascending key output index array element equal element standard analyze efficiency binary times key compared element array sake simplicity called comparisons assumes comparison algorithm determine smaller equal larger comparisons algorithm make array elements depends specifics instance problem key comparisons worst case cworst worst case inputs arrays key successful searches comparison algorithm faces situation array half size recurrence relation cworst convince rounded initial condition written encountered recurrence initial condition section recurrence solution initial condition cworst log similarly case recurrence problem exercises solution formula tweaked solution valid arbitrary positive integer cworst log formula deserves attention implies worst case efficiency binary log fully expected algorithm simply reduces size remaining array half iteration iterations needed initial size final size log reiterate section logarithmic function grows slowly values small large values formula log comparisons element establish element sorted array elements log comparisons sorted array size average case efficiency binary phisticated analysis shows average key comparisons binary slightly smaller worst case cavg log accurate formulas average comparisons successful unsuccessful cayvegs log canvog log binary optimal searching algorithm restrict erations comparisons keys section searching algorithms interpolation section hashing section average case efficiency hashing quire array sorted algorithms require special calculations addition key comparisons finally idea binary applications searching ben addition applied solving nonlinear equations unknown discuss continuous analogue binary called method bisection section fake coin problem versions fake coin identification problem illustrates decrease constant factor strategy identical coins fake scale sets coins tipping left staying scale sets heavier problem design efficient algorithm detecting fake coin easier version problem discuss assumes fake coin lighter genuine natural idea solving problem coins piles coins leaving extra coin odd challenging version assumes additional information relative weights fake genuine coins presence fake coin coins pursue difficult version exercises section piles scale piles coin fake proceed manner lighter pile fake coin easily set recurrence relation weighings needed algorithm worst case recurrence familiar identical worst case comparisons binary difference initial condition similarity surprising algorithms based technique halving instance size solution recurrence weighings similar binary log elementary outright boring interesting fact algorithm efficient solution efficient coins piles coins details precise formulation developed section exercises instructor forgets demand instructor assign problem weighing piles instance size factor weighings log smaller log russian peasant multiplication nonorthodox algorithm multiplying positive integers called multiplication russe russian peasant method positive integers product compute instance size instance half size deal obvious formula relating solution problem larger instance solution smaller odd slight adjustment formula formulas trivial case compute product recursively iteratively computing algorithm figure extra addends shown parentheses figure rows odd values column product simply adding elements column odd column figure algorithm involves simple operations halving doubling adding feature attractive figure computing russian peasant method memorize table multiplications feature algorithm attractive russian peasants accord ing western visitors widely nineteenth century method named fact method egyptian mathematicians early cha leads fast hardware implementa tion doubling halving binary numbers performed shifts basic operations machine josephus problem josephus problem named flavius josephus famous jewish historian participated chronicled jewish revolt romans josephus general managed hold fortress jotapata days fall city refuge diehards nearby cave rebels voted perish surrender josephus proposed dispatch neighbor determined casting lots josephus contrived draw lot surviving men cave prevailed intended victim surrender romans people numbered stand circle starting grim person eliminate person survivor left problem determine survivor figure people positions eliminated circle people initial positions eliminated leaving sole survivor initial position people positions eliminated convenient people positions convenience figure instances josephus problem subscript numbers person position eliminated solutions convenient cases odd separately circle yields instance problem half initial size difference position numbering person initial position person initial position figure easy initial position person simply position relationship hold survivor case odd eliminates people positions elimination person position left instance size initial position corresponds position numbering position figure odd values closed solution case recurrence subject initial condition requires ingenuity applying backward substitutions fact solution apply forward substitutions values discern pattern prove general validity mathematical induction leave execution exercises alternatively gkp exposition josephus problem interestingly elegant closed involves binary representation size obtained bit cyclic shift left exercises cutting stick inches cut inch pieces outline algorithm performs task minimum cuts pieces stick cut formula minimum cuts design decrease half algorithm computing log determine efficiency largest key comparisons binary searching key array keys array require largest key comparisons searched binary average key comparisons binary successful array assume key searched probability average key comparisons binary unsuccessful array assume searches keys intervals formed array elements equally estimate times faster average successful sorted array elements binary sequential efficiency sequential implemented array linked true searching sorted binary design version binary comparisons implement algorithm language choice carefully debug programs notorious prone bugs analyze efficiency comparison version designed picture guessing version popular problem solving task involves pre senting people array pictures rows pictures target picture questions answered people required picture questions efficient algorithm problem largest questions ternary algorithm searching sorted array simply key single element array recursively comparing larger determine array design technique algorithm based set recurrence key comparisons worst case assume solve recurrence algorithm efficiency binary array integers increasing integer range missing design efficient algorithm missing integer efficiency write pseudocode algorithm fake coin problem make algorithm handles properly values multiples set recurrence relation weighings algorithm fake coin problem solve large values times faster algorithm based dividing coins piles apply russian peasant algorithm compute standpoint efficiency russian peasant algorithm write pseudocode russian peasant multiplication algorithm efficiency class russian peasant multiplication solution josephus problem prove solution josephus problem power josephus problem compute discern pattern solutions values prove general validity prove validity bit cyclic shift left binary representation variable size decrease algorithms principal variety decrease conquer size reduction pattern varies iteration algorithm euclid algorithm computing greatest common divisor section good kind algorithm section encounter examples variety computing median selection problem selection problem finding kth smallest element numbers called kth statistic simply scan smallest largest element interesting case problem asks element larger half elements smaller half middle called median important notions mathematical statistics kth smallest element sorting selecting kth element output sorting algorithm determined efficiency sorting algorithm fast sorting algorithm mergesort discussed chapter algorithm efficiency log immediately sorting entire overkill problem asks entire kth smallest element advantage idea partitioning element general rearrangement elements left elements smaller equal pivot elements greater equal principal algorithmic alternatives partition array discuss lomuto partitioning ben hoare algorithm chapter idea lomuto parti tioning helpful array generally subarray consideration composed contiguous seg ments listed pivot segment elements smaller segment elements greater equal segment elements compared fig ure segments case segments algorithm starts starting algorithm scans subarray left maintaining structure partition achieved iteration pares element unknown segment pointed scanning index figure pivot simply incremented segment elements greater equal shrinking processed segment elements smaller expanded incrementing index figure illustration lomuto partitioning element segment swapping incrementing element shrunk unprocessed segment unprocessed elements figure algorithm swaps pivot achieve partition sought figure pseudocode implementing partitioning procedure algorithm lomutopartition partitions subarray lomuto algorithm element pivot input subarray array defined left indices output partition position pivot swap advantage partition kth smallest element assume implemented array elements indexed starting partition split position index array element occupied pivot partitioning pivot kth smallest element solves problem kth smallest element entire array kth smallest element left partitioned array smallest element solve problem outright instance smaller solved approach recursively algorithm called quickselect kth smallest element array algorithm quickselect algorithm quickselect solves selection problem recursive partition based algorithm input subarray array orderable elements integer output kth smallest element lomutopartition partition algorithm quickselect fact idea implemented recursion nonrecursive version adjust apply partition based algorithm median fol lowing numbers task smallest element array version array partitioning showing pivots bold smaller proceed array median greater smaller efficient quickselect partitioning element array requires key comparisons produces split solves selection problem requiring iterations case cbest algorithm extremely unbalanced partition array elements worst case iterations specific worst case input case strictly increasing array implies cworst compares poorly straightforward sorting based approach mentioned beginning selection problem discussion usefulness partition based algorithm depends algorithm efficiency average case fortunately careful mathematical analysis shown average case efficiency linear fact scientists discovered sophisticated choosing pivot quickselect guarantees linear worst case blo complicated recommended practical applications noting partition based algorithm solves general problem identifying smallest largest elements kth smallest element interpolation variable size decrease algorithm searching sorted array called interpolation binary compares key middle sorted array reduces problem instance size half interpolation takes account key array element compared key sense algorithm mimics index figure index computation interpolation searching named brown middle beginning action searching named smith precisely iteration dealing array portion leftmost element rightmost element algorithm assumes array values linearly straight line points accuracy assumption algorithm efficiency correctness key compared element index computed coordinate straight line points coordinate equal figure writing standard equation straight line passing points substituting solving leads formula logic approach straightforward array values increasing accurately decreasing values increased linearly simplest manner index computed formula expected location array element equal formula applied comparing algorithm stops equal proceeds searching manner elements indexed depending smaller larger size problem instance reduced priori analysis algorithm efficiency shows interpolation log key comparisons average searching random keys function grows slowly comparisons small constant practically feasible inputs problem section exercises worst case interpolation linear considered bad performance assessing worthiness interpolation binary robert sedgewick wrote edition algorithms binary smaller files interpolation large files applications comparisons expensive access costs high section discuss continuous counterpart interpolation variable size decrease algorithm searching insertion binary tree revisit binary tree recall binary tree nodes elements set orderable items element node elements left subtree smaller elements subtree greater element subtree root element tree recursively manner tree ends failure tree root desired element stopped left subtree root subtree iteration algorithm problem searching binary tree reduced searching smaller binary tree size tree height decrease tree height iteration binary tree giving excellent variable size decrease algorithm worst case binary tree severely skewed tree constructed successive insertions increasing decreasing sequence keys figure tree requires comparisons making worst case efficiency operation fall fortunately average case efficiency turns log precisely key comparisons needed binary tree built random keys log insertion key binary tree identical searching exemplifies variablesize decrease technique efficiency characteristics operation figure binary trees increasing sequence keys decreasing sequence keys game nim games features players randomness hidden information permitted players information gameplay game impartial player moves game position finite moves leads smaller instance game ends win players ties winner player prototypical games nim generally game played piles chips pile version single pile chips players turns removing pile chips vary lower upper limits wins game taking chip player moving players make moves instance game winning position player winning strategy sequence moves results victory moves opponent makes instance game losing position player leads winning position opponent standard approach determining positions winning losing investigate small values logical instance losing player make instance chips winning position player instance chips losing taking allowed chips puts opponent winning position illustration figure instance chips winning position player leaves opponent chips losing figure illustration pile nim maximum chips numbers chips pile losing positions player circled winning moves winning positions shown bold position chips losing position difficult pattern formally proved mathematical induction instance chips winning position player multiple winning strategy mod chips deviation strategy puts opponent winning position pile nim appeared summation game published recreational mathematics authored claude gaspar bachet french aristocrat mathematician player picks positive integer opponent turns adding integer player winner dud general nim played piles chips sizes player chips single pile goal player make easy figure wins game hint game instances differs solution general case nim unexpected based binary representation pile sizes pile sizes binary compute binary digital sum nim sum defined sum binary digits discarding words binary digit sum ith position addends odd turns instance nim winning player nim sum nim instance losing instance nim sum zeros commonly played instance nim sum instance winning player moving winning position player bit strings nim sum difficult accomplish chips pile ingenious solution game nim discovered harvard math ematics professor bouton years ago mathemati cians developed general theory games excellent account theory applications specific games monograph berlekamp conway guy ber exercises instance size computing greatest common divisor size decrease iteration euclid algorithm prove instance size decrease factor successive iterations euclid algorithm apply quickselect median numbers write pseudocode nonrecursive implementation quickselect derive formula underlying interpolation worst case input interpolation algorithm linear worst case smallest log greater determine assertions true log iii log outline algorithm finding largest key binary tree classify algorithm variable size decrease algorithm efficiency class algorithm worst case outline algorithm deleting key binary tree classify algorithm variable size decrease algorithm efficiency class algorithm worst case outline variable size decrease algorithm constructing eulerian circuit connected graph vertices degrees mise pile nim called mise version pile nim player taking chip loses game conditions game pile chips player takes chips winning losing positions player game moldy chocolate players turns breaking chocolate spoiled square break single straight line cutting boundaries squares break player broke eats piece spoiled square player left spoiled square loses game write interactive game make winning position random legitimate losing position flipping pancakes sizes stacked allowed flipper pancakes flip stack flipper purpose pancakes size biggest visualization puzzle interactive mathematics miscellany puzzles site bog design algorithm solving puzzle matrix row column sorted increasing design algorithm problem laa summary decrease conquer general algorithm design technique based exploiting relationship solution instance problem solution smaller instance problem relationship established exploited recursively major variations decrease conquer decrease constant insertion sort decrease constant factor binary variable size decrease euclid algorithm insertion sort direct application decrease conquer technique sorting problem algorithm worst average cases fast average worst case algorithm notable advantage good performance sorted arrays digraph graph directions edges topological sorting problem asks vertices digraph edge digraph vertex starts listed vertex points problem solution digraph dag directed acyclic graph directed cycles algorithms solving topological sorting problem based depth based direct application decrease technique decrease technique natural approach developing algo rithms generating elementary combinatorial objects efficient class algorithms minimal algorithms num ber combinatorial objects grows fast algorithms practical small instances problems binary efficient algorithm searching sorted array principal decrease constant factor algorithm examples exponentiation squaring identifying fake coin scale russian peasant multiplication josephus problem decrease conquer algorithms size reduction varies iteration algorithm examples variable size decrease algorithms euclid algorithm partition based algorithm selection problem interpolation searching insertion binary tree nim exemplifies games proceed series diminishing instances game
speaking express numbers express numbers knowledge meagre unsatisfactory kind beginning knowledge scarcely thoughts advanced stage science lord kelvin counted counts counted albert einstein chapter devoted analysis algorithms american heritage dic tionary defines analysis separation intellectual substantial constituent parts individual study prin cipal dimensions algorithm pointed section legitimate desirable subject study term analysis algorithms narrower technical sense investigation algorithm efficiency respect resources running memory space emphasis efficiency easy dimensions simplicity gen erality efficiency studied precise quantitative terms case speed memory today computers efficiency considerations primary importance practical view chapter limit discussion algorithm efficiency general framework analyzing algorithm efficiency sec tion section arguably important chapter funda mental nature topic makes important sections entire section notations big omega big theta borrowed mathematics notations language discussing efficiency algorithms section general framework outlined section systematically applied analyzing efficiency nonrecursive algorithms main tool analysis setting sum representing algorithm running simplifying sum standard sum manipulation techniques section general framework outlined section systematically applied analyzing efficiency recursive algorithms main tool summation special kind equation called recurrence relation recurrence relations set method solving illustrate analysis framework methods appli cations variety examples sections chapter section devoted fibonacci numbers discov ered years ago remarkable sequence appears variety applications science discussion fibonacci sequence serves natural vehicle introducing important class recurrence rela tions solvable method section discuss algorithms computing fibonacci numbers sake general obser vations efficiency algorithms methods analyzing methods sections powerful technique analyz ing efficiency algorithms mathematical clarity precision methods foolproof sections chapter deal approaches empirical analysis algorithm visualization complement pure mathematical techniques sections newer developed mathematical counterparts proaches important role tools analysis algorithm efficiency analysis framework section outline general framework analyzing efficiency algo rithms mentioned section kinds efficiency space efficiency called complexity fast algorithm runs space efficiency called space complexity refers memory units required algorithm dition space needed input output early days electronic computing resources space premium half century relentless technological innovations improved speed memory size orders magnitude extra space quired algorithm typically caveat difference fast main memory slower secondary memory cache issue diminished extent addition research experience shown problems achieve spectacular progress speed space established tradition algorithm textbooks primarily efficiency analytical framework introduced applicable analyzing space efficiency measuring input size obvious observation algorithms run longer larger inputs takes longer sort larger arrays larger matrices logical investigate algorithm efficiency function parameter indicating algorithm input size cases selecting parameter straightforward size problems sorting searching finding smallest element problems dealing lists problem evaluating polynomial anxn degree polynomial degree coefficients larger degree discussion minor difference inconsequential efficiency analysis situations choice parameter indicating input size computing product matrices natural measures size problem frequently matrix natural contender total elements matrices multiplied general applicable matrices necessarily square simple formula relating measures easily algorithm efficiency qualitatively depending measures problem section exercises choice size metric influenced operations algorithm input size checking algorithm examines individual characters input size characters works processing words input make special measuring input size algorithms solving problems checking primality positive integer input magnitude determines input algorithms require parameter size inputs vertices edges algorithms graphs represented adjacency lists size situations preferable size bits binary representation log metric idea efficiency algorithms ques tion units measuring running issue concerns units measuring algorithm running simply standard unit measurement millisecond running implement ing algorithm obvious drawbacks approach dependence speed dependence quality implementing algorithm compiler generating machine code difficulty clocking actual running pro gram algorithm efficiency metric extraneous factors approach times algorithm operations executed approach excessively difficult unnecessary thing important operation algorithm called basic operation contributing total running compute times basic operation executed difficult basic operation algorithm consuming operation algorithm innermost loop sorting algorithms comparing elements keys sorted algorithms basic operation key comparison algorithms mathematical problems typically involve arithmetical operations addition subtraction multiplication division consuming operation division multiplication addition subtraction considered established framework analysis algorithm ficiency suggests measuring counting times algorithm basic operation executed inputs size compute nonrecursive recursive algorithms sections important application cop execution algo rithm basic operation times operation executed algorithm estimate computers multiplication longer addition subtraction timing data provided kernighan pike ker running implementing algorithm formula copc formula caution information operations basic fact computed approximately constant cop approximation reliability easy assess extremely large small formula reasonable estimate algorithm running makes questions faster algorithm run machine times faster times assuming longer algorithm run input size times longer small values copc knowing cop neatly cancelled ratio multiplicative constant formula cancelled reasons efficiency analysis framework ignores multiplicative constants concentrates growth constant multiple large size inputs orders growth emphasis growth large input sizes difference running times small inputs distinguishes efficient algorithms inefficient compute greatest common divisor small numbers immediately efficient euclid algorithm compared algorithms discussed section faster greatest common divisor large numbers difference algorithm efficiencies important large values function growth counts table values functions important analysis algorithms magnitude numbers table profound significance analysis algorithms function growing slowest logarithmic function grows slowly fact table values approximate functions important analysis algorithms log implementing algorithm logarithmic basic operation run practi cally instantaneously inputs realistic sizes specific values logarithm base formula loga logb makes base leaving logarithmic multiplicative constant omit logarithm base write simply log situations interested function growth multiplicative constant spectrum exponential function factorial function functions grow fast values astronomically large small values reason values table years making operations execute operations incomparably faster execute operations longer years estimated age planet earth tremendous difference orders growth functions referred exponential growth functions simply exponential fact strictly speaking referred line important algorithms require exponential operations practical solving problems small sizes qualitative difference orders growth functions table react twofold argument function log increases log linear function increases twofold linearithmic function log increases slightly twofold quadratic function cubic function fourfold eightfold squared increases mathematics refuses cooperate neat worst case average case efficiencies beginning section established reasonable algorithm efficiency function parameter indicating size algorithm input algorithms running depends input size specifics input sequential straightforward algorithm searches item key elements checking successive elements key exhausted algorithm pseudocode simplicity implemented array assumes condition checked checks array index exceed upper bound fails algorithm sequentialsearch searches array sequential input array key output index element matches matching elements running algorithm size worst case matching elements matching element algorithm makes largest key comparisons inputs size cworst worst case efficiency algorithm efficiency worst case input size input inputs size algorithm runs longest inputs size determine worst case efficiency algorithm principle straightforward analyze algorithm kind inputs yield largest basic operation inputs size compute worst case cworst sequential obvious methods handling trivial situations explained subsequent sections chapter worst case analysis important information algorithm efficiency bounding running words guarantees instance size running exceed cworst running worst case inputs case efficiency algorithm efficiency case input size input inputs size algorithm runs fastest inputs size analyze case efficiency determine kind inputs smallest inputs size case smallest input means input size algorithm runs fastest ascertain convenient inputs case inputs sequential lists size element equal key cbest algorithm analysis case efficiency important worst case efficiency completely useless case inputs advantage fact algorithms good case performance extends types inputs case sorting algorithm insertion sort case inputs sorted arrays algorithm works fast case efficiency deteriorates slightly sorted arrays algorithm method choice applications dealing sorted arrays case efficiency algorithm unsatisfactory immediately discard analysis discussion worst case analysis case counterpart yields information algorithm behavior typical random input information average case efficiency seeks analyze algorithm average case efficiency make assumptions inputs size sequential standard assumptions probability successful equal probability occurring ith position assumptions validity difficult verify reasonableness average key comparisons cavg case successful probability occurring ith position comparisons algorithm situation case unsuccessful comparisons probability cavg general formula yields reasonable answers successful average key comparisons sequential algorithm inspect average half elements unsuccessful average key comparisons algorithm inspect elements inputs elementary investigation average case efficiency considerably difficult investigation worst case efficiencies direct approach involves dividing instances size classes instance class times algorithm basic operation executed classes sequential probability distribution inputs obtained assumed expected basic operation technical implementation rarely easy probabilistic assumptions underlying case difficult verify quest simplicity quote results average case efficiency algorithms discussion interested derivations results consult books baa sed knui knuii knuiii preceding discussion average case efficiency obtained taking average worst case efficiencies average occasionally coincide average case cost legitimate performing average case analysis average case efficiency information unequivocally important algorithms averagecase efficiency overly pessimistic worst case efficiency lead average case analysis scientists missed important algorithms efficiency called amortized efficiency applies single run algorithm sequence operations performed data structure turns situations single operation expensive total entire sequence operations significantly worst case efficiency single operation multiplied amortize high cost worst case occurrence entire sequence manner similar business amortize cost expensive item years item productive life sophisticated approach discovered american scientist robert tarjan applications developing interesting variation classic binary tree tar readable nontechnical discussion tar technical account usefulness amortized efficiency section algorithms finding unions disjoint sets recapitulation analysis framework leave section summarize main points framework outlined space efficiencies measured functions algorithm input size efficiency measured counting times algorithm basic operation executed space efficiency measured counting extra memory units consumed algorithm efficiencies algorithms differ significantly inputs size algorithms distinguish worst case average case efficiencies framework primary lies growth algorithm running extra memory units consumed input size infinity section formal means investigate orders growth sections discuss methods investigating nonrecursive recursive algorithms analysis framework outlined applied investigating efficiency specific algorithms encounter examples rest exercises algorithms natural size metric inputs basic operation iii basic operation inputs size computing sum numbers computing finding largest element numbers euclid algorithm sieve eratosthenes pen pencil algorithm multiplying digit decimal integers definition based algorithm adding matrices basic operation times performed function matrix function total elements input matrices questions definition based algorithm matrix multiplication variation sequential scans occurrences key efficiency differ efficiency classic sequential glove selection gloves drawer pairs red gloves pairs yellow pairs green select gloves dark selection smallest gloves select matching pair case worst case missing socks washing distinct pairs socks missing largest pairs remaining left pairs case scenario pairs worst case assuming probability disappearance socks probability case scenario probability worst case scenario pairs average case prove formula bits binary representation positive decimal integer prove alternative formula bits binary repre sentation positive integer log analogous formulas decimal digits accepted analysis framework binary decimal digits measuring size sorting algorithm augmented make case key comparisons equal size worthwhile addition sorting algorithm gaussian elimination classic algorithm solving systems linear equations unknowns requires multiplications algorithm basic operation longer gaussian elimination equations buying times faster factor faster sizes systems solvable functions function argument increased fourfold log pairs functions function pairs lower higher growth constant multiple function log invention chess legend game chess invented centuries ago northwestern india sage invention king game offered inventor reward wanted inventor asked grain obtained single grain wheat square chessboard fourth squares filled grain doubling grains square chessboard inventor asked adding grains asymptotic notations basic efficiency classes pointed previous section efficiency analysis framework centrates growth algorithm basic operation principal indicator algorithm efficiency rank orders growth scientists notations big omega big theta notations informally sev eral examples formal definitions discussion nonnegative functions defined set natural numbers context interested algorithm running basic operation simple function informal introduction informally set functions lower growth constant multiple infinity examples assertions true functions linear lower growth quadratic growth functions cubic higher growth fourth degree polynomial notation stands set functions higher growth constant multiple infinity finally set functions growth constant multiple infinity quadratic function infinitely log informal introduction comfortable idea asymptotic notations formal definitions notation definition function denoted bounded constant multiple large positive constant nonnegative integer definition illustrated figure sake visual clarity extended real formally prove assertions introduction values constants required definition lot freedom choosing specific values constants reason proof figure big notation figure big omega notation definition function denoted bounded positive constant multiple large positive constant nonnegative integer definition illustrated figure formal proof select figure big theta notation definition function denoted bounded positive constant multiples large positive constants nonnegative integer definition illustrated figure prove inequality upper bound prove left inequality lower bound select property involving asymptotic notations formal definitions asymptotic notations prove general properties problem section exercises simple examples property analyzing algorithms comprise consecutively executed parts theorem max analogous assertions true notations proof extends orders growth simple fact arbitrary real numbers max positive constant negative integer similarly denote max inequalities adding yields max constants required definition max property imply algorithm comprises consec utively executed parts implies algorithm efficiency deter mined higher growth efficient max array equal elements algorithm sort array applying sorting algorithm scan sorted array consecutive elements equality sorting algorithm makes comparisons makes comparisons efficiency entire algorithm max limits comparing orders growth formal definitions indispensable proving abstract properties rarely comparing orders growth specific functions convenient method based computing limit ratio functions principal cases arise implies smaller growth lim implies growth implies larger growth cases case means limit based approach convenient based definitions advantage powerful calculus techniques developed computing limits pital lim stirling formula large values examples limit based approach comparing orders growth functions orders growth examples beginning section illustrate definitions lim limit equal positive constant functions growth symbolically orders growth log exam ple immediately obvious log lim log lim limit equal log smaller growth limn log called notation log big notation rarely analysis algorithms fourth case limit rarely actual practice analyzing algorithms possibility makes limit based approach comparing orders growth general based definitions orders growth discussed informally section taking advantage stirling formula lim nen grows fast grows faster write symbolically big omega notation preclude possibility growth limit computed basic efficiency classes efficiency analysis framework puts functions orders growth differ constant multiple infinitely classes exponential functions orders growth values base efficiencies large algorithms fall classes listed table increasing orders growth names comments classifying algorithms asymptotic effi ciency practical values multiplicative constants left unspecified leaves possibility algorithm worse efficiency class running faster algorithm efficiency class inputs realistic sizes running algorithm running cubic algorithm outperform quadratic algorithm exceeds anomalies fortunately multiplicative constants differ drastically algorithm asymptotic efficiency class outperform algorithm worse class moderately sized inputs observation true algorithm exponential running exponential worse algorithm exercises notation efficiency class sequential section worst case average case informal definitions determine ing assertions true false table basic asymptotic efficiency classes class comments constant short case efficiencies reasonable examples algorithm running typically infinity input size grows infinitely large log logarithmic typically result cutting problem size constant factor iteration algorithm section logarithmic algorithm account input fixed fraction algorithm linear running linear algorithms scan size sequential class log linearithmic conquer algorithms chapter mergesort quicksort average case fall category quadratic typically characterizes efficiency algorithms embedded loops section elemen tary sorting algorithms operations matrices standard examples cubic typically characterizes efficiency algorithms embedded loops section nontrivial algorithms linear algebra fall class exponential typical algorithms generate subsets element set term exponential broader sense larger orders growth factorial typical algorithms generate permutations element set functions class function belongs simplest answers prove assertions log table values functions arise analysis algorithms values functions log listed increasing growth values prove fact mathematical certainty prove functions listed increasing growth functions growth lowest highest prove polynomial degree aknk belongs prove exponential functions orders growth values base prove assertions definitions notations volved disprove giving specific counterexample nonnegative functions defined set nonnegative integers prove section theorem notation mentioned section elements array distinct algorithm based array presorting algorithm efficiency log efficiency class entire algorithm sorting algorithm presorting extra array size space efficiency class entire algorithm range finite nonempty set real numbers defined differ ence largest smallest elements representation english algorithm compute range indi cate efficiency classes algorithms notation unsorted array sorted array sorted singly linked binary tree lighter heavier identical coins pan scale weights coins fake lighter heavier genuine coins design algorithm determine fake coin lighter heavier door wall facing wall stretches infinitely direc tions door wall direction door algorithm enables door walking steps unknown steps initial position door par mathematical analysis nonrecursive algorithms section systematically apply general framework outlined section analyzing efficiency nonrecursive algorithms simple demonstrates principal steps typically analyzing algorithms problem finding largest element numbers simplicity assume implemented array pseudocode standard algorithm solving problem algorithm maxelement determines largest element array input array real numbers output largest element maxval obvious input size elements array operations executed algorithm loop operations loop body comparison maxval assignment maxval operations basic comparison executed repetition loop assignment comparison algorithm basic operation comparisons arrays size terms metric distinguish worst average cases denote times comparison executed formula expressing function size algorithm makes comparison execution loop repeated loop variable bounds inclusive sum easy sum compute repeated times general analyzing nonrecursive algorithms general analyzing efficiency nonrecursive algorithms parameter parameters indicating input size algorithm basic operation located loop times basic operation executed depends size input depends additional property worst case average case efficiencies investigated separately set sum expressing times algorithm basic operation executed standard formulas rules sum manipulation closed formula establish growth proceeding examples review appen dix summation formulas rules analysis algorithms frequently basic rules sum manipulation cai analysis nonrecursive algorithm requires setting sum recurrence relation times basic operation executed recurrence relations typical analyzing recursive algorithms section summation formulas lower upper integer limits formula special case formula element uniqueness problem elements array elements distinct problem solved straightforward algorithm uniqueelements determines elements array distinct input array output returns true elements distinct false true natural input size elements array innermost loop single operation comparison elements algorithm basic operation element comparisons depends equal elements array positions occupy limit investigation worst case definition worst case input array element comparisons cworst largest arrays size inspection innermost loop reveals kinds worst case inputs algorithm exit loop prematurely arrays equal elements arrays elements pair equal elements inputs comparison repetition innermost loop variable limits repeated outer loop variable limits cworst computed sum faster equality obtained applying summation formula result perfectly predictable worst case algorithm distinct pairs elements matrices efficiency definition based algorithm computing product definition matrix elements computed scalar dot products rows matrix columns matrix row col pair indices algorithm matrixmultiplication multiplies square matrices definition based algorithm input matrices output matrix input size matrix arithmetical operations innermost loop multiplication addition principle designation algorithm basic operation choose repetition innermost loop executed counting automatically established tradition multiplication basic operation section set sum total multiplications executed algorithm depends size input matrices investigate worst case average case efficiencies separately multiplication executed repetition algorithm innermost loop governed variable ranging lower bound upper bound multiplications pair specific values variables total multiplications expressed triple sum compute sum formula starting innermost sum equal simple result summation machinations algorithm computes elements product matrix product elements computed scalar dot product element row matrix element column matrix takes multiplications total multiplications kind reasoning expected answering problem exercises estimate running algorithm machine product cmm cmn multiplication machine accurate estimate account spent additions cmm caa cmn addition estimates differ multiplicative constants growth erroneous impression outlined succeeds analyzing nonrecursive algorithm irregular loop variable sum complicated analyze difficulties intrinsic average case analysis obstacles prove insur mountable caveats simple nonrecursive algorithms subsequent chapters algorithm loop variable manner previous examples algorithm finds binary digits binary representation positive decimal integer algorithm binary input positive decimal integer output binary digits binary representation frequently executed operation loop comparison determines loop body executed times comparison executed larger repetitions loop body choice important significant feature fact loop variable takes values lower upper limits alternative computing times loop executed halved repetition loop log exact formula times comparison executed log bits binary representation formula applying analysis technique based recurrence relations discuss technique section pertinent analysis recursive algorithms exercises compute sums growth sums notation simplest function sample variance measurements computed divisions multiplications additions subtractions additions subtractions bunched required computing variance formulas algorithm mystery input nonnegative integer algorithm compute basic operation times basic operation executed efficiency class algorithm improvement algorithm altogether efficiency class prove fact algorithm secret input array real numbers minval maxval minval maxval minval questions problem algorithm enigma input matrix real numbers false true questions problem algorithm implementation matrix multiplication algorithm ample reducing additions algorithm effect algorithm efficiency determine asymptotic growth total times doors toggled locker doors puzzle problem exercises prove formula mathematical induction insight year school boy named carl friedrich gauss grew greatest mathematicians times mental arithmetic table filled repeating numbers diagonals shown total sum table numbers cra version important algorithm study algorithm input matrix real numbers efficiency class algorithm glaring inefficiency pseudocode eliminated speed algorithm von neumann neighborhood algorithm starts single square iterations adds squares iterations gar parlance cellular automata theory cells von neumann neighborhood range results illustrated page numbering total decimal digits needed num bering pages assume pages numbered consecutively starting mathematical analysis recursive algorithms section apply general framework analysis algorithms recursive algorithms novices idea recursive algorithm compute factorial function arbitrary nonneg ative integer definition compute recursive algorithm computes recursively input nonnegative integer output simplicity indicator algorithm input size bits binary expansion basic operation algorithm multiplication executions denote function computed formula alternatively times comparison executed counting total calls algorithm problem section exercises multiplications needed compute equality compute multiplications spent compute multiplication needed result equation defines sequence equation defines explicitly function implicitly function equations called recurrence relations brevity recurrences recurrence relations important role analysis algorithms areas applied mathematics studied courses discrete mathematics discrete structures tutorial provided appendix goal solve recurrence relation explicit formula terms infinitely sequences recurrence examples determine solution uniquely initial condition tells sequence starts inspecting condition makes algorithm recursive calls tells things calls smallest algorithm executed defined inspecting pseudocode exiting line algorithm performs multiplications initial condition calls multiplications succeeded setting recurrence relation initial condition algorithm multiplications embark discussion solve recurrence reiterate important dealing recursively defined functions factorial function defined recurrence multiplications needed compute recursive algorithm pseudocode beginning section showed defined recurrence solve difficult solution sequence starts increases systematic fashion techniques solving recurrence relations called method backward substitutions method idea reason immediately applies solving recurrence substitute inspecting lines emerging pattern makes predict line general formula pattern strictly speaking correctness formula proved mathematical induction easier solution verify correctness remains advantage initial condition substitute pattern formula ultimate result backward substitutions disappointed exerting effort obvious benefits method illustrated simple solve difficult recurrences simple iterative algorithm accumulates product consecutive integers requires multiplications overhead space maintaining recursion stack issue efficiency important problem computing section function values large fast realistically compute exact values small simple convenient vehicle standard approach analyzing recursive algorithms generalizing experience investigating recursive algorithm computing outline general investigating recursive algo rithms general analyzing efficiency recursive algorithms parameter parameters indicating input size algorithm basic operation times basic operation executed vary inputs size worst case average case efficiencies investigated separately set recurrence relation initial condition times basic operation executed solve recurrence ascertain growth solution educational workhorse recursive algorithms tower hanoi puzzle mythical monks disks sizes slide pegs initially disks peg size largest smallest goal disks peg auxiliary disk forbidden larger disk smaller problem elegant recursive solution illustrated figure disks peg auxiliary recursively disks peg auxiliary largest disk directly peg finally recursively disks peg auxiliary simply single disk directly source peg destination peg figure recursive solution tower hanoi puzzle apply general outlined tower hanoi problem disks obvious choice input size indicator moving disk algorithm basic operation moves depends recurrence equation obvious initial condition recurrence relation moves solve recurrence method backward substitutions pattern sums left suggests generally substitutions initial condition achieved formula solution recurrence exponential algorithm run unimaginably moderate values problem section exercises fact algorithm poor fact difficult prove efficient algorithm problem intrinsic difficulty makes computationally hard makes important general careful recursive algorithms succinctness mask inefficiency recursive algorithm makes single analysis purposes construct tree recursive calls tree nodes correspond recursive calls parameter generally parameters calls tower hanoi tree figure counting nodes tree total calls tower hanoi algorithm tree figure tree recursive calls recursive algorithm tower hanoi puzzle agrees obtained earlier investigate recursive version algorithm discussed section algorithm binrec input positive decimal integer output binary digits binary representation binrec set recurrence initial condition additions algorithm additions computing binrec addition algorithm returned leads recurrence recursive calls equal additions initial condition presence function argument makes method backward substitutions stumble values powers standard approach solving recurrence solve advantage theorem called smoothness appendix claims broad assumptions growth observed growth values alternatively solution powers fine tune solution formula valid arbitrary apply recipe recurrence takes backward substitutions encounter problems substitute returning original variable log fact prove problem section exercises exact solution arbitrary slightly refined formula log section introduction analysis recursive algorithms techniques expanded section discuss fibonacci numbers analysis involves difficult recurrence relations solved method backward substitutions exercises solve recurrence relations solve set solve recurrence relation calls recursive algorithm computing recursive algorithm computing sum cubes algorithm input positive integer output sum cubes set solve recurrence relation times algo rithm basic operation executed algorithm straightforward nonrecursive algorithm computing sum recursive algorithm input positive integer set recurrence relation function values solve deter algorithm computes set recurrence relation multiplications algorithm solve set recurrence relation additions subtractions algorithm solve tower hanoi original version tower hanoi puzzle published douard lucas french mathematician world disks moved mystical tower brahma estimate years monks disk minute assume monks eat sleep die moves ith largest disk algorithm nonrecursive algorithm tower hanoi puzzle imple ment language choice restricted tower hanoi version tower hanoi puzzle disks moved peg disk peg disk peg prohibition placing larger disk smaller remains design recursive algorithm problem moves prove exact additions recursive algorithm binrec arbitrary positive decimal integer log set recurrence relation additions nonrecursive version algorithm section solve design recursive algorithm computing nonnegative integer based formula set recurrence relation additions algorithm solve draw tree recursive calls algorithm calls algorithm good algorithm solving problem recursive algorithm riddle input array real numbers temp riddle temp algorithm compute set recurrence relation algorithm basic operation solve algorithm graph defined adjacency matrix algorithm graphcomplete input adjacency matrix undirected graph output true false vertex graph definition graphcomplete algorithm efficiency class worst case determinant matrix denoted det defined recursive formula det odd element row column matrix obtained matrix deleting row column set recurrence relation multiplications algorithm implementing recursive definition solving recurrence solution growth compared von neumann neighborhood revisited cells von neumann neighborhood range problem exercises setting solving recurrence relation frying hamburgers fried small grill hold hamburgers hamburger fried sides frying hamburger takes minute hamburgers fried recursive algorithm executing task minimum hamburger hamburgers apply procedure recursively remaining hamburgers set solve recurrence algorithm hamburgers algorithm hamburgers minimum recursive algorithm executes task minimum celebrity problem celebrity group people person task celebrity questions people design efficient algorithm celebrity determine group person questions algorithm worst case computing nth fibonacci section fibonacci numbers famous sequence defined simple recurrence initial conditions fibonacci numbers introduced leonardo fibonacci solution problem size rabbit population problem section exercises examples fibonacci numbers discovered natural world predicting prices stocks commodities interesting applications fibonacci numbers science worst case inputs euclid algorithm discussed section consecutive elements fibonacci sequence section briefly algorithms computing nth element sequence benefits discussion opportunity method solving recurrence relations analysis recursive algorithms explicit formula apply method backward substitutions solve recurrence easily discernible pattern advantage theorem describes solutions homogeneous linear recurrence constant efficients fixed real numbers called coefficients recurrence generic term unknown sequence applying theorem recurrence initial conditions appendix formula hard formula includes arbitrary integer powers irrational numbers yields elements fibonacci sequence benefits formula immediately implies grows exponentially fibonacci rabbits constant golden ratio antiquity considered pleasing ratio rectangle sides human eye consciously ancient architects sculptors observation fraction infinitely small infinity fact prove impact term obtained rounding term nearest integer words nonnegative integer rounded nearest integer algorithms sake simplicity operations additions multiplications unit cost fibonacci numbers grow infinitely large grow rapidly detailed analysis offered warranted fact size numbers efficient method computing primary caveats algorithms outline analysis examples student design analysis algorithms begin recurrence initial conditions obvious recursive algorithm computing algorithm computes nth fibonacci recursively definition input nonnegative integer output nth fibonacci embarking formal analysis efficient algorithm formal analysis algorithm basic operation addition additions performed algorithm computing numbers additions needed computing algorithm addition compute sum recurrence similar recurrence equal recurrences called inhomogeneous general techniques solving inhomogeneous recurrences appendix textbook discrete mathematics recurrence special leads faster solution inhomogeneous recurrence homogeneous rewriting substituting homogeneous recurrence solved manner recur rence solved explicit formula avoided noting fact recurrence starts runs ahead size bits log binary representation efficiency class worse doubly exponential poor efficiency class algorithm anticipated nature recurrence recursive calls sizes smaller instances slightly smaller size encountered situation reason algorithm inefficiency recursive tree calls tracing algorithm execution tree figure values function evaluated extremely inefficient faster algorithm simply computing successive elements fibonacci sequence iteratively algo rithm algorithm fib computes nth fibonacci iteratively definition input nonnegative integer output nth fibonacci figure tree recursive calls computing fibonacci definition based algorithm makes additions linear function exponential function bits binary representation extra array storing preceding elements fibonacci sequence avoided storing values accomplish task problem section exercises alternative computing nth fibonacci lies formula efficiency algorithm determined efficiency exponentiation algorithm computing simply multiplying times algorithm faster algorithms exponentiation problem discuss log algorithms problem chapters special exercised implementing approach computing nth fibonacci intermediate results irrational numbers make approximations accurate final yields result finally exists log algorithm computing nth fibonacci manipulates integers based equality efficient computing matrix powers exercises web site dedicated applications fibonacci numbers study fibonacci rabbits problem pair rabbits sur rounded wall pairs rabbits year initial pair rabbits male female newborn rabbit pairs fertile month life birth male female pair month climbing stairs ways climb stair case stairs stair staircase climbed ways numbers fibonacci numbers closed formula valid direct substitutions function satisfies recurrence initial conditions maximum values java primitive types int smallest nth fibonacci memory allocated int recursive definition based algorithm computing nth bonacci times computed prove algorithm text requires space prove equality modulo divisions euclid algorithm consec utive fibonacci numbers algorithm input dissecting fibonacci rectangle sides secutive fibonacci numbers design algorithm dissect squares size efficiency class algorithm language choice implement algorithms computing digits nth fibonacci based recursive definition based algorithm iterative definition based algorithm fib experiment largest programs run minute empirical analysis algorithms sections algorithms nonrecursive recursive analyzed mathematically techniques applied success fully simple algorithms power mathematics enhanced advanced techniques sed pur gra gre limitless fact seemingly simple algorithms proved difficult analyze mathematical precision certainty pointed section true average case analysis principal alternative mathematical analysis algorithm ficiency empirical analysis approach implies steps spelled general empirical analysis algorithm efficiency understand experiment purpose efficiency metric measured measurement unit operation unit characteristics input sample range size implementing algorithm algorithms exper imentation generate sample inputs run algorithm algorithms sample inputs data observed analyze data obtained discuss steps goals pursue analyzing algorithms empirically checking accuracy theoretical assertion algorithm efficiency comparing efficiency algorithms solving problem imple mentations algorithm developing hypothesis algorithm efficiency class ascertaining efficiency implementing algorithm machine experiment design pend experimenter seeks goal experiment dictate algorithm efficiency measured alternative insert counter counters implementing algorithm times algorithm basic operation executed straightforward operation mindful possibility basic operation executed places executions accounted straightforward task modified ensure works correctly terms problem solves counts yields alternative implementing algorithm easiest unix alternatively running code fragment tstart completion tfinish computing difference tfinish tstart function clock purpose java method currenttimemillis class important facts mind typically accurate results repeated runs inputs obvious remedy make measurements average median sample observation high speed modern puters running register reported standard overcome obstacle run extra loop times total running loop repetitions running sharing unix reported spent cpu programs defeats purpose experiment devoted specifically execution units called ticks difference divided constant indicating ticks unit unix called user automatically provided measuring physical running disadvantages principal dependence machine important technical shared counting executions basic operation physical running specific information algorithm performance computing environment importance experimenter algorithm asymptotic efficiency class addition measuring spent segments pinpoint bottleneck performance missed abstract deliberation algorithm basic operation data called profiling important resource empirical analysis algorithm running data obtained tools computing environments efficiency basic operation counting clocking sample inputs experiment goal sample representing typical input understand typical input classes algorithms traveling salesman problem discuss researchers developed set instances benchmark ing input sample developed experimenter typically make decisions sample size small sample range instance sizes typically trivially small excessively large procedure generating instances range chosen instance sizes adhere pattern generated randomly range chosen principal advantage size changing pattern impact easier analyze sample sizes generated doubling compute ratios observed metric ratios exhibit behavior typical algorithms basic efficiency classes discussed section major disadvantage nonrandom sizes possibility algorithm investigation exhibits atypical behavior sample chosen sizes sample algorithm runs slowly odd size inputs empirical results misleading important issue sizes experiment sample instances size included observed metric vary considerably instances size wise instances size sample developed methods statistics experimenter make cisions shortage books subject instances size included sample averages medians observed values size computed investigated addition individual sample points empirical analysis requires generating random numbers pattern input sizes typically instances generated randomly generating random numbers digital difficult problem principle problem solved approximately reason scientists numbers pseudorandom practical easiest natural numbers advantage random generator language libraries typically output pseudo random variable uniformly distributed interval pseudo random variable desired transformation continuous random variable uniformly distributed interval variable uniformly distributed integer values integers alternatively implement algorithms generating pseudo random numbers widely studied algorithms linear congruential method algorithm random seed generates sequence pseudorandom numbers linear congruential method input positive integer positive integer parameters seed output sequence pseudorandom integers uniformly distributed integer values pseudorandom numbers obtained treating integers generated digits decimal seed mod simplicity pseudocode misleading devil lies details choosing algorithm parameters partial recommendations based results sophisticated mathematical analysis knuii details seed chosen arbitrarily set current date large conveniently word size selected integer pattern digits mod chosen empirical data obtained result experiment recorded presented analysis data presented numerically table graphically scatterplot points cartesian coordinate good idea options feasible methods unique strengths weaknesses principal advantage tabulated data lies opportunity manip ulate easily compute ratios candidate represent efficiency class algorithm ratios converge pos itive constant large careless novices assume constant incorrect definition compute ratios running reacts doubling input size discussed section ratios slightly logarithmic algorithms converge linear quadratic cubic algorithms obvious convenient cases scatterplot ascertaining algorithm probable efficiency class logarithmic algorithm scat terplot concave shape figure fact distinguishes basic efficiency classes linear algorithm points tend aggregate straight line generally contained straight lines figure scatterplots functions convex shape figure making difficult differentiate scatterplot cubic algorithm convex shape rapid metric values exponential algorithm require logarithmic scale vertical axis val ues loga plotted commonly logarithm base coordinate scatterplot exponential algorithm resemble linear function plies logb vice versa applications empirical analysis predict gorithm performance instance included experiment sample ratios constant sample instances approximate prod uct instances approach caution values sample range mathematicians predictions extrapolation opposed interpolation deals values sample range unleashing standard tech niques statistical data analysis prediction majority techniques based specific probabilistic assumptions valid experimental data section pointing basic differ ences mathematical empirical analyses algorithms princi pal strength mathematical analysis independence specific inputs principal weakness applicability investigating average case efficiency principal strength empirical analysis lies applicability algorithm results sample instances experiment figure typical plots logarithmic linear convex functions exercises sorting algorithm studied counter inserted key comparisons algorithm sortanalysis input array orderable elements output total key comparisons comparison counter inserted prove make correction run problem properly inserted counter coun ters key comparisons random arrays sizes analyze data obtained hypothesis algorithm average case efficiency estimate key comparisons randomly generated array size sorted algorithm problem measuring running milliseconds hypothesize efficiency class algorithm based empirical observations basic operation size scale transformation make logarithmic scatterplot linear distinguish scatterplot algorithm scatterplot algorithm empirically largest divisions euclid algo rithm computing gcd positive integer empirically smallest pair integers euclid algorithm make divisions gcd average case efficiency euclid algorithm inputs size measured average divisions davg algorithm computing gcd davg scatterplot davg algorithm average case efficiency class run experiment ascertain efficiency class sieve eratos thenes section run timing experiment algorithms computing gcd presented section algorithm visualization addition mathematical empirical analyses algorithms study algorithms called algorithm visualization defined images convey information algorithms information visual illustration algorithm operation formance kinds inputs execution speed algorithms problem accomplish goal algorithm visualiza tion graphic elements points line segments dimensional bars represent interesting events algorithm operation principal variations algorithm visualization static algorithm visualization dynamic algorithm visualization called algorithm animation static algorithm visualization shows algorithm progress series images algorithm animation shows continuous movie presentation algorithm operations animation arguably sophisticated option difficult implement early efforts area algorithm visualization watershed event happened appearance minute color titled sorting algorithm visualization classic produced university toronto ronald baecker assistance sherman bae contained visualizations sorting algorithms half discussed provided convincing demonstration relative speeds success sorting algorithms perennial vorite algorithm animation sorting problem lends naturally visual presentation vertical horizontal bars sticks heights lengths rearranged sizes figure presentation convenient illustrating actions typical sorting algorithm small inputs larger files sorting ingenious idea presenting data scatterplot points coordinate plane coordinate representing item position representing item representation process sorting transformation random scatterplot points diagonal figure addition sorting algorithms figure initial final screens typical visualization sorting algorithm representation comparing exchanging items event animated easily appearance sorting great algorithm animations created appearance java figure initial final screens typical visualization sorting algorithm scatterplot representation world wide web range scope algorithm group algorithms problem sorting application area geometric algorithms general purpose animation systems catalog links existing visualizations maintained nsf supported algovizproject contained links survey existing visualizations low quality content heavily skewed easier topics sorting sha principal applications algorithm visualization research education potential benefits researchers based expectations algo rithm visualization uncover unknown features algorithms researcher visualization recursive tower hanoi algo rithm odd numbered disks colored colors noticed disks color direct contact algorithm execution observation helped developing recursive version classic algorithm bentley mcilroy ben mentioned algorithm animation improving library implementation leading sorting algorithm application algorithm visualization education seeks students learning algorithms evidence effectiveness decisively mixed experiments register positive learning outcomes failed increasing body evidence creating sophisticated software systems fact appears student involvement visualization important specific features visualization software experiments low tech visualizations prepared students effective passive exposure sophisticated software systems summarize successes research education reported literature impressive deeper understanding human perception images required true potential algorithm visualization fulfilled summary kinds algorithm efficiency space efficiency fast algorithm runs space efficiency deals extra space requires algorithm efficiency principally measured function input size counting times basic operation executed basic operation contributes running typically consuming operation algorithm innermost loop algorithms running differ considerably inputs size leading worst case efficiency average case efficiency case efficiency established framework analyzing efficiency primarily grounded growth algorithm running input size infinity notations asymptotic orders growth functions expressing algorithm efficiencies large algorithms fall classes constant logarithmic linear linearithmic quadratic cubic exponential main tool analyzing efficiency nonrecursive algorithm set sum expressing executions basic operation ascertain sum growth main tool analyzing efficiency recursive algorithm set recurrence relation expressing executions basic operation ascertain solution growth succinctness recursive algorithm mask inefficiency fibonacci numbers important sequence integers element equal sum predecessors algorithms computing fibonacci numbers drastically efficiencies empirical analysis algorithm performed running implementing algorithm sample inputs analyzing data observed basic operation physical running involves generating pseudorandom numbers applicability algorithm principal strength approach dependence results instance sample main weakness algorithm visualization images convey information algorithms principal variations algorithm visualization static algorithm visualization dynamic algorithm visualization called algorithm animation
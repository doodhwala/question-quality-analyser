prays miracle prayer reduces great god grant ivan turgenev russian novelist short story writer conquer general algorithm design technique fame catchy deserved efficient algorithms specific implementations general strategy conquer algorithms general problem divided subproblems ideally equal size subproblems solved typically recursively dif ferent algorithm employed subproblems small solutions subproblems combined solution original problem conquer technique diagrammed figure depicts case dividing problem smaller subproblems widely occurring case conquer algorithms designed executed single processor problem computing sum numbers problem instances problem compute sum numbers compute sum remaining numbers simply sums computed applying method recursively values sum efficient compute sum numbers moment reflection efficient brute summation problem size subproblem size solution subproblem solution original problem figure conquer technique typical case small summing numbers algorithm formal analysis common sense compute sums lead negative conquer algorithm necessarily efficient brute solution prayers goddess algorithmics chapter epigraph answered spent executing conquer turns significantly smaller solving problem method fact conquer approach yields important efficient algorithms science discuss classic examples algorithms chapter sequential algorithms keeping mind conquer technique ideally suited parallel computations subproblem solved simultaneously processor conquer algorithm called pairwise summation substantially accumulated error sum numbers represented approximately digital hig mentioned typical case conquer problem instance size divided instances size generally instance size divided instances size needing solved constants assuming size power simplify analysis recurrence running function accounts spent dividing instance size instances size combining solutions sum recurrence called general conquer recurrence growth solution depends values constants growth function efficiency analysis conquer algorithms greatly simplified theorem appendix master theorem recurrence log nlogb analogous results hold notations recurrence additions conquer sum computation algorithm inputs size nlogb nlog solution efficiency class drudgery solving recurrence approach establish solution growth unknown multiplicative constant solving recurrence equation specific initial condition yields exact powers pointing recurrence covers decreaseby constant factor algorithms discussed previous chapter fact people algorithms binary degenerate cases andconquer subproblems half size solved decrease constant factor divideand conquer design paradigms mergesort perfect successful application conquer technique sorts array dividing halves sorting recursively merging smaller sorted arrays single sorted algorithm mergesort sorts array recursive mergesort input array orderable elements output array sorted nondecreasing mergesort merge merging sorted arrays pointers array indices initialized elements arrays merged elements pointed compared smaller added array constructed index smaller element incremented successor array copied operation repeated arrays exhausted remaining elements array copied array algorithm merge merges sorted arrays sorted array input arrays sorted output sorted array elements operation algorithm illustrated figure mergesort operation efficient mergesort assuming simplicity power recurrence relation key comparisons cmerge analyze cmerge key comparisons performed merging stage comparison total elements arrays needing processed reduced worst case arrays element smaller elements alternating arrays worst case cmerge recurrence cworst master theorem cworst log fact easy exact solution worst case recurrence cworst log key comparisons mergesort worst case theoretical minimum general comparison based sorting algorithm large comparisons algo rithm average case turns gon log noteworthy advantage mergesort quick sort heapsort important advanced sorting algorithms discussed stability problem section exercises principal short coming mergesort linear extra storage algorithm requires merging resulting algorithm complicated theoretical main ideas leading variations mergesort algorithm implemented merging pairs array elements merging sorted pairs power slight bookkeeping complications arise avoids space overhead stack recursive calls sorted parts sort recursively merge scheme sorting files residing secondary memory devices called multiway mergesort exercises write pseudocode conquer algorithm finding sition largest element array numbers algorithm output arrays elements largest set solve recurrence relation key comparisons algorithm brute algorithm problem write pseudocode conquer algorithm finding values largest smallest elements array numbers set solve recurrence relation key comparisons algorithm brute algorithm problem write pseudocode conquer algorithm exponenti ation problem computing positive integer set solve recurrence relation multiplications algorithm section theoretical minimum log algorithm brute algorithm problem mentioned chapter logarithm bases irrelevant contexts arising analyzing algorithm efficiency class true asser tions master theorem logarithms growth solutions recurrences apply mergesort sort alphabetical mergesort stable sorting algorithm solve recurrence relation key comparisons mergesort worst case assume set recurrence relation key comparisons mergesort case inputs solve set recurrence relation key moves version mergesort section taking key moves account algorithm efficiency class array real numbers pair inversion numbers design log algorithm counting inversions implement version mergesort language choice tromino puzzle tromino accurately tromino shaped tile formed squares problem chess board missing square trominoes oriented arbitrary squares board missing overlaps gol design conquer algorithm problem quicksort important sorting algorithm based conquer approach mergesort divides input elements position array quicksort divides encountered idea array partition section discussed selection problem partition arrangement array elements left element equal elements greater equal partition achieved final position sorted array sorting subarrays left independently method difference mergesort division problem subproblems entire combining solutions entire division stage required combine solutions subproblems pseudocode quicksort algorithm quicksort sorts subarray quicksort input subarray array defined left indices output subarray sorted nondecreasing partition split position quicksort partition algorithm lomuto partition discussed section alternatively partition generally subarray sophisticated method suggested hoare prominent british scientist invented quicksort hoare age invented algorithm sort words machine translation project russian english hoare thought bubblesort amazing luck thought quicksort hard assessment lucky wonderful career computing discovering sorting algorithm hoa years received turing award fundamental contributions definition design programming languages knighted services education science selecting pivot element respect subarray strategies selecting pivot issue analyze algorithm efficiency simplest strategy selecting subarray element lomuto algorithm scan subarray ends comparing subarray elements pivot left scan denoted index pointer starts element elements smaller pivot left subarray scan skips elements smaller pivot stops encountering element greater equal pivot left scan denoted index pointer starts element subarray elements larger pivot subarray scan skips elements larger pivot stops encountering element smaller equal pivot stopping scans encountering element equal pivot yield splits arrays lot duplicates makes algorithm run faster array equal elements split subarrays sizes reducing problem size scanning entire array scans situations arise depending scanning indices crossed scanning indices crossed simply exchange resume scans incrementing decrementing scanning indices crossed partitioned subarray exchanging pivot finally scanning indices pointing element pointing equal subarray partitioned split position combine case crossed indices exchanging pivot pseudocode implementing partitioning procedure algorithm hoarepartition partitions subarray hoare algorithm element pivot input subarray array defined left indices output partition split position returned function swap undo swap index subarray bounds pseudocode checking possibility index incremented append array sentinel index advancing position sophisticated method pivot selection mentioned section makes sentinel unnecessary sorting array quicksort figure discussion quicksort efficiency noting key comparisons partition achieved scanning indices coincide splits middle subarrays case key comparisons case satisfies recurrence cbest master theorem cbest log solving yields cbest log worst case splits skewed extreme subarrays size subarray partitioned unfortunate situation increasing arrays inputs problem solved strictly increasing array pivot left scan left scan indicating split position figure quicksort operation array transformations pivots shown bold tree recursive calls quicksort input values subarray bounds split position partition obtained making comparisons partition exchanging pivot algorithm left strictly increasing array sort sorting strictly increasing arrays diminishing sizes processed total key comparisons equal cworst utility quicksort average case behavior cavg average key comparisons quicksort randomly ordered array size partition position comparisons achieve partition left subarrays elements assuming partition split position probability recurrence relation cavg solution trickier worst case analyses turns cavg log average quicksort makes comparisons case innermost loop efficient runs faster mergesort heapsort log algorithm discuss chapter randomly ordered arrays nontrivial sizes justifies algorithm inventor quicksort importance persistent efforts years refine basic algorithm improvements discovered researchers pivot selection methods randomized quicksort random element median method median leftmost rightmost middle element array switching insertion sort small subarrays elements systems sorting small subarrays finishing algorithm insertion sort applied entire sorted array modifications partitioning algorithm partition segments smaller equal larger pivot problem section exercises robert sedgewick sed world leading expert quicksort improvements combination cut running algorithm sorting algorithm quicksort weaknesses stable requires stack parameters subarrays sorted size stack log sorting smaller subarrays obtained partitioning worse space efficiency heapsort sophisticated ways choosing pivot make quadratic running worst case eliminate completely performance randomly ordered arrays sensitive implementation details algorithm architecture data february issue computing science engineering joint publication american institute physics ieee society selected quicksort algorithms greatest development practice science engineering century exercises apply quicksort sort alphabetical draw tree recursive calls partitioning procedure outlined section prove scanning indices pointing element pointing equal prove scanning indices element position left pointed showing quicksort stable sorting algorithm array elements sentinel mentioned text needed single sentinel suffices input version quicksort section arrays equal elements worst case input case input strictly decreasing arrays worst case input case input quicksort median pivot selection strictly increas ing arrays worst case input case input strictly decreasing arrays estimate times faster quicksort sort array random numbers insertion sort true false element arrays sorted faster insertion sort quicksort design algorithm rearrange elements array real num bers negative elements positive elements algorithm efficient space efficient dutch national flag problem rearrange array characters red white blue colors dutch national flag dij design linear algorithm problem solution dutch national flag problem quicksort implement quicksort language choice run sample inputs verify theoretical assertions algorithm efficiency nuts bolts collection bolts widths nuts allowed nut determine nut larger smaller matches nuts bolts problem nut design algorithm problem average case efficiency log raw binary tree traversals related properties section conquer technique applied binary trees binary tree defined finite set nodes consists root disjoint binary trees called left subtree root binary tree special case ordered tree figure standard interpretation alternative definition binary tree section definition divides binary tree smaller structures left subtree problems binary trees solved applying conquer technique recursive algorithm computing height binary tree recall height defined length longest path root leaf computed maximum heights root left tleft tright figure standard representation binary tree subtrees account extra root convenient define height tree recursive algorithm height computes recursively height binary tree input binary tree output height max height tlef height tright problem instance size nodes binary tree comparisons compute maximum numbers additions algorithm recurrence relation tlef tright solve recurrence solution addition frequently executed operation algorithm checking typical binary tree algorithms tree comparison executed additions single node tree comparison addition numbers helps analysis tree algorithms draw tree extension replacing subtrees special nodes extra nodes shown squares figure called external original nodes shown circles called internal definition extension binary tree single external node easy height algorithm makes addition internal node extended tree makes comparison figure binary tree left extension internal nodes shown circles external nodes shown squares tree internal external node ascertain algorithm efficiency external nodes extended binary tree internal nodes checking figure similar examples easy hypothesize external nodes internal nodes prove equality total nodes internal external node root children internal node equation immediately implies equality applies nonempty binary tree definition node children binary tree denote numbers parental nodes leaves returning algorithm height comparisons tree additions important conquer algorithms binary trees classic traversals preorder inorder postorder traversals nodes binary tree recursively visiting tree root left subtrees differ timing root preorder traversal root visited left subtrees visited inorder traversal root visited visiting left subtree visiting subtree postorder traversal root visited visiting left subtrees traversals illustrated figure pseudocodes straightforward repeating descriptions traversals standard feature data structures textbooks efficiency analysis identical analysis height algorithm recursive node extended binary tree finally questions binary trees require traversals left subtrees insert operations binary tree require processing subtrees considered section applications conquer examples variable size decrease technique preorder inorder postorder figure binary tree traversals exercises design conquer algorithm computing levels binary tree algorithm single node trees efficiency class algorithm seeks compute leaves binary tree algorithm leafcounter computes recursively leaves binary tree input binary tree output leaves leafcounter tlef leafcounter tright algorithm prove make correction compute height binary tree asymptotic ficiency section conquer algorithm stack explicitly implicitly algorithm altogether prove equality mathematical induction traverse binary tree preorder inorder postorder write pseudocode classic traversal algorithms preorder postorder binary trees assuming algorithm recur sive recursive calls classic traversal algorithms yields sorted applied binary tree prove property draw binary tree nodes labeled inorder postorder traversals tree yield lists inorder postorder permutations labels inorder postorder traversal lists binary tree design algorithm constructs binary tree lists labels generated inorder postorder traversals tree algorithm inputs problem solution internal path length extended binary tree defined sum lengths paths internal nodes root internal node similarly external path length extended binary tree defined sum lengths paths external nodes root external node prove internal nodes tree write computing internal path length extended binary tree investigate empirically average key comparisons searching randomly generated binary tree chocolate puzzle chocolate break pieces break straight line broken design algorithm solves problem minimum breaks minimum justify properties binary tree multiplication large integers strassen matrix multiplication section surprising algorithms seemingly straightfor ward tasks multiplying integers multiplying square matrices achieve asymptotic efficiency ingenious application conquer technique multiplication large integers applications notably modern cryptography require manipulation inte gers decimal digits integers single word modern require special treatment practi cal supports investigations algorithms efficient manipulation large integers section outline interesting algorithm multiplying numbers conventional pen pencil algorithm mul tiplying digit integers digits multiplied digits total digit multiplications numbers digits pad shorter leading zeros equalize lengths impossible design algorithm digit multiplica tions turns case miracle conquer accomplish feat demonstrate basic idea algorithm case digit integers numbers represented formula yields digit multiplications pen pencil algorithm fortunately compute middle term digit multiplication taking advantage products computed special numbers multiplied pair digit numbers product computed formula product digits product digits product sum digits sum digits sum apply multiplying digit integers positive numbers middle promised advantage conquer technique denote half digits half notations implies taking advantage digit numbers product halves product halves product sum halves sum halves sum apply method computing products power recursive algorithm computing product digit integers pure recursion stopped deem small numbers size directly digit multiplications algorithm make multiplica tion digit numbers requires multiplications digit numbers recurrence multiplications solving backward substitutions yields log nlog advantage property logarithms alogb clogb additions subtractions decreased num ber multiplications requiring operations digit additions subtractions executed algorithm multiplying digit decimal integers operations needed compute products digit numbers formulas require additions subtraction recurrence applying master theorem stated beginning chapter nlog means total additions subtractions asymptotic growth multipli cations asymptotic advantage algorithm practical depends quality implementing algorithm wide disparity reported results machines conquer algorithm reported outperform conventional method numbers decimal digits run faster numbers decimal digits area importance modern cryptography outperformance crossover machine switching conventional algorithm multiplicands smaller crossover finally oriented language java smalltalk aware languages special classes dealing large integers discovered year russian mathematician anatoly karatsuba conquer algorithm proved wrong prevailing opinion efficiency integer multiplication algorithm discovery encouraged researchers asymptotically faster algorithms algebraic problems algorithm section strassen matrix multiplication conquer approach digit multiplications multiplying integers surprised similar feat accomplished multiplying matrices algorithm published strassen str principal insight algorithm lies discovery product matrices multiplications opposed required brute algorithm section accomplished formulas matrices strassen algorithm makes multipli cations additions subtractions brute algorithm requires multiplications additions numbers lead multiplying matrices strassen algorithm importance stems asymptotic superiority matrix infinity matrices power matrices padded rows columns zeros product submatrices difficult verify submatrices numbers product computed strassen formulas numbers replaced submatrices products matrices computed recursively method strassen algorithm matrix multiplication evaluate asymptotic efficiency algorithm multiplications strassen algorithm multiplying matrices power recurrence relation log nlog smaller required brute algorithm savings multiplications achieved expense making extra additions strassen algorithm matrices algorithm matrices make additions subtractions matrices size additions numbers simply multiplied observations yield recurrence relation closed solution recurrence problem section exercises simply establish solution growth master theorem nlog words additions growth multiplications puts strassen algorithm nlog efficiency class brute method strassen discovery algorithms multiplying matrices real numbers progressively smaller constants invented fastest algorithm coopersmith winograd coo efficiency decreasing values exponents obtained expense increasing complexity algorithms large multiplicative constants practical interesting theoretical view closer theoretical lower bound matrix multiplication multiplications gap bound algorithm remains unresolved matrix multiplication computationally equivalent important problems solving systems linear equations discussed chapter exercises smallest largest numbers digits product decimal digit integers compute applying conquer algorithm outlined text prove equality alogb clogb section nlog log closed formula multiplications multiplication large integer multiplication algorithm addition assuming power sake simplicity subtle assumption setting recurrences true final answers assumption digit additions pen pencil algorithm multiplying digit integers disregard potential carries verify formulas underlying strassen algorithm multiplying matrices apply strassen algorithm compute exiting recursion computing products matrices brute algorithm solve recurrence additions required strassen algo rithm assume power pan discovered conquer matrix multiplication algorithm based multiplying matrices multiplications asymptotic efficiency pan algorithm additions strassen algorithm practical implementations strassen algorithm brute method matrix sizes smaller crossover run experiment determine crossover closest pair convex hull problems conquer section discussed brute approach solving classic prob lems computational geometry closest pair problem convex hull problem dimensional versions problems solved brute algorithms sec tion discuss sophisticated asymptotically efficient algorithms problems based conquer technique closest pair problem set points cartesian plane sake simplicity assume points distinct assume points ordered nondecreasing coordinate sort efficeint sorting algorithm mergesort convenient points sorted nondecreasing coordinate denote problem solved obvious brute algorithm points subsets points drawing vertical line median coordinates points left line points line solve closest pair problem min figure idea conquer algorithm closest pair problem rectangle points closer dmin recursively subsets smallest distances pairs points min necessarily smallest distance pairs points closer pair sides separating line combining solutions smaller subproblems points limit attention points symmetric vertical width separating line distance pair points figure points width separating line obtained ordered nondecreasing coor dinate scan updating information dmin minimum distance encounter closer pair points initially dmin subsequently dmin chance closer dmin difference coordinates dmin geometri cally means rectangle shown figure principal insight exploited algorithm observation rectangle points half left rectangle distance easy prove total points rectangle exceed prob lem section exercises careful analysis reduces joh algorithm points moving pseudocode algorithm advice section computing square roots innermost loop algorithm efficientclosestpair solves closest pair problem conquer input array points cartesian plane sorted nondecreasing coordinates array points sorted nondecreasing coordinates output euclidean distance closest pair points minimal distance brute algorithm points array points array remaining points array points array efficientclosestpair min points array num dminsq num dminsq min dminsq sqrt dminsq algorithm spends linear dividing problem problems half size combining obtained solutions assuming usual power recurrence running algorithm applying master theorem log necessity presort input points efficiency class sorting log algorithm mergesort fact efficiency class achieve proved algorithm problem log natural assumptions operations algorithm pre convex hull problem revisit convex hull problem introduced section smallest convex polygon points plane conquer algorithm called quickhull resemblance quicksort set points cartesian plane assume points sorted nondecreasing coordinates ties resolved increasing coordinates points involved difficult prove geometrically obvious fact leftmost rightmost distinct extreme points set convex hull figure straight line points directed line separates points sets set points left line set points line left line directed forms counterclockwise cite analytical condition based checking determinant formed coordinates points line extreme points convex hull excluded consideration boundary convex hull polygonal chains upper boundary lower boundary upper boundary called upper hull sequence line segments vertices points lower boundary called lower hull sequence line segments vertices points fact convex hull entire set composed upper lower hulls constructed independently similar fashion observation exploited algorithms problem concreteness discuss quickhull proceeds construct upper hull lower hull constructed manner figure upper lower hulls set points pmax figure idea quickhull upper hull simply line segment endpoints algorithm identifies pmax farthest line figure maximizes angle pmaxppn selected pmax maximizes area triangle vertices algorithm identifies points set left line pmax points make set points left line make set difficult prove pmax vertex upper hull points pmaxpn vertices upper hull eliminated consideration points left lines pmax algorithm constructing upper hulls pmax recursively simply concatenate upper hull entire set figure algorithm geometric operations implemented fortunately advantage fact analytical geometry arbitrary points cartesian plane area triangle equal half magnitude determinant expression positive left line formula constant lies left line determined points distance line quickhull worst case efficiency quicksort problem section exercises average case performance algorithm benefit quicksort savings average balanced split problem smaller subproblems significant fraction points pmaxpn figure eliminated processing natural assumption points chosen randomly uniform dis tribution convex region circle rectangle average case efficiency quickhull turns linear ove exercises dimensional version closest pair problem finding closest numbers set real num bers design algorithm directly based conquer technique determine efficiency class good algorithm problem prove conquer algorithm closest pair problem examines vertical figures points closer dmin minimum distance points encountered algorithm version conquer dimensional closest pair algorithm presorting input set simply sort sets nondecreasing coordinates recursive assuming sorting mergesort set recurrence relation running worst case solve implement conquer closest pair algorithm outlined section language choice web visualization algorithm closest pair problem algorithm visualization represent voronoi polygon set points plane defined perimeter set points plane closer union voronoi polygons points called voronoi diagram voronoi diagram set points visualization algorithm generating voronoi diagram web study examples diagrams based observations solution previous generalized general case pmax quickhull algorithm analytically case efficiency quickhull specific inputs make quickhull run quadratic implement quickhull language choice creating decagons points plane line devise algorithm construct decagons vertices points decagons convex simple boundary decagons common shortest path fenced area dimensional clidean plane shape convex polygon vertices points necessarily points min max design efficient algorithm comput ing length shortest path oro summary conquer general algorithm design technique solves problem dividing smaller subproblems ideally equal size solving recursively combining solutions solution original problem efficient algorithms based technique inapplicable inferior simpler algorithmic solutions running conquer algorithms satisfies recurrence master theorem establishes growth solutions mergesort conquer sorting algorithm works dividing input array halves sorting recursively merging sorted halves original array sorted algorithm efficiency log cases key comparisons theoretical minimum principal drawback significant extra storage requirement quicksort conquer sorting algorithm works partitioning input elements relative preselected element quicksort noted superior efficiency log algorithms sorting randomly ordered arrays quadratic worst case efficiency classic traversals binary tree preorder inorder postorder similar algorithms require recursive processing left subtrees considered examples conquer technique analysis helped replacing subtrees tree special external nodes conquer algorithm multiplying digit integers requires digit multiplications strassen algorithm multiplications matrices exploiting conquer technique algorithm matrices multiplications conquer technique successfully applied important problems computational geometry closest pair problem convex hull problem
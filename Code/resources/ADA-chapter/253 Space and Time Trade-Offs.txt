things mercy things johann wolfgang von ethe space offs algorithm design issue theoreticians practitioners computing problem computing values function points domain premium precompute function values table human computers advent electronic computers process burdening libraries volumes mathematical tables lost appeal widespread electronic computers underlying idea proven development important algorithms problems general terms idea preprocess problem input additional information obtained accelerate solving problem afterward approach input enhancement discuss algorithms based counting methods sorting section boyer moore algorithm string matching simplified version sug gested horspool section technique exploits space offs simply extra space facilitate faster flexible access data approach prestructuring highlights facets variation space processing problem standard terms synonymously technique preprocessing preconditioning confusingly terms applied methods idea preprocessing extra space chapter confusion input enhancement special space technique discussed solved input enhancement variety deals access structuring illustrate approach hashing section indexing trees section algorithm design technique related space idea dynamic programming strategy based recording solu tions overlapping subproblems problem table solu tion problem obtained discuss developed technique separately chapter final comments interplay space algo rithm design resources space design situations fact align bring algorithmic solution minimizes running space consumed situation arises algorithm space efficient data structure represent problem input leads faster algorithm problem traversing graphs efficiency principal traversal algorithms depth breadth depends data structure repre senting graphs adjacency matrix representation adjacency representation numbers vertices edges input graphs sparse edges relative vertices adjacency representation efficient space running points view situation arises manipulation sparse matrices sparse polynomi als percentage zeros objects sufficiently high space ignoring zeros objects representation processing discuss space offs mentioning hugely important area data compression data compres sion size reduction goal technique solving problem discuss data compression algorithm chapter reader interested topic wealth algorithms books sorting counting applying input enhancement technique discuss application sorting problem obvious idea element sorted total elements smaller element results table numbers positions elements sorted element position index counting sorted array sort simply copying elements positions sorted algorithm called comparison counting sort figure array initially final state array figure sorting comparison counting algorithm comparisoncountingsort sorts array comparison counting input array orderable elements output array elements sorted nondecreasing efficiency algorithm quadratic algorithm considers pairs element array formally times basic operation comparison executed equal sum encountered times algorithm makes key comparisons selection sort addition linear extra space positive algorithm makes minimum key moves placing directly final position sorted array counting idea productively situation elements sorted small set values assume sort values applying general sorting algorithm advantage additional information values sorted scan compute simply make elements equal remaining elements equal generally element values integers lower bound upper bound compute frequency values array positions sorted filled positions overwrite elements realistic situation sorting items information keys overwrite elements array hold sorted elements values equal lowest copied elements positions elements copied positions accumulated sums frequencies called distribution statistics method distribution counting sorting array values set overwritten process sorting frequency distribution arrays array values frequencies distribution values distribution values proper positions rences elements final sorted array index array positions distribution values reduced element positions convenient process input array left element distribution position array hold sorted decrease distribution proceed element array entire processing depicted figure sorting distribution counting distribution values decremented shown bold pseudocode algorithm distributioncountingsort sorts array integers range distribution counting input array integers output array elements sorted nondecreasing initialize frequencies compute frequencies reuse distribution downto assuming range array values fixed linear algorithm makes consecutive passes input array efficiency class efficient sorting algorithms mergesort quicksort heapsort encountered important efficiency obtained exploiting specific nature inputs sorting distribution counting works addition trading space exercises exchange numeric values variables extra storage comparison counting algorithm correctly arrays equal values assuming set values sort alphabetical distribution counting algorithm distribution counting algorithm stable design line algorithm sorting array size values distinct integers ancestry problem asks determine vertex ancestor vertex binary generally rooted ordered tree vertices design input enhancement algorithm sufficient information solve problem pair tree vertices constant technique virtual initialization efficient initialize elements array elements constant initialized utilizing variable counter initialized elements auxiliary arrays size defined counter indices elements initialized index element initialized index element initialized kth element counter initialized sketch state arrays signments general scheme initialized distance sorting egyptian stone statues standing row art gallery hall curator statues ordered height minimize total distance statues moved assume simplicity statues heights azi write multiplying sparse matrices matrix write multiplying sparse polynomials degrees good idea write plays classic game tic tac toe human user storing positions game board input enhancement string matching section technique input enhancement applied problem string matching recall problem string matching requires finding occurrence string characters called pattern longer string characters called text discussed brute algorithm problem section simply matches pairs characters pattern text left mismatch occurs shifts pattern position trial maximum trials worst case comparisons worst case efficiency brute algorithm class average comparisons pattern shift random natural language texts average case efficiency turns faster algorithms discovered exploit input enhancement idea preprocess pattern information table information actual pattern text idea bestknown algorithms knuth morris pratt algorithm knu boyer moore algorithm boy principal difference algorithms lies characters pattern counterparts text knuthmorris pratt algorithm left boyer moore algorithm left idea leads simpler algorithms pursue boyer moore algorithm starts aligning pattern beginning characters text trial fails shifts pattern comparisons trial algorithm left starting character pattern underlying idea boyer moore algorithm simple actual implementation working method discussion simplified version boyer moore algorithm suggested horspool hor addition simpler horspool algorithm necessarily efficient boyer moore algorithm random strings horspool algorithm searching pattern barber text starting pattern moving left pairs characters pattern text pattern characters successfully matching substring stopped altogether continued occurrence pattern desired mismatch occurs shift pattern make large shift risking possibility missing matching substring text horspool algorithm determines size shift character text aligned character pattern case character matches counterpart pattern general possibilities case pattern letter safely shift pattern entire length shift character pattern aligned text character pattern case occurrences character pattern letter shift align rightmost occurrence pattern text case character pattern characters letter situation similar case pattern shifted entire pattern length case finally character pattern characters letter situation similar case rightmost occurrence characters pattern aligned text examples demonstrate left character comparisons lead farther shifts pattern shifts position brute algorithm characters pattern trial lose superiority fortunately idea input enhancement makes repetitive comparisons unnecessary precompute shift sizes table indexed characters encountered text natural language texts space punctuation symbols special characters information text eventual searching required table entries shift sizes computed formula pattern length characters pattern distance rightmost characters pattern character pattern barber table entries equal entries simple algorithm computing shift table entries initialize entries pattern length scan pattern left repeating times character pattern overwrite entry table character distance character pattern algorithm scans pattern left overwrite character rightmost occurrence algorithm shifttable fills shift table horspool boyer moore algorithms input pattern alphabet characters output table size indexed alphabet characters filled shift sizes computed formula size table summarize algorithm horspool algorithm pattern length alphabet pattern text construct shift table align pattern beginning text matching substring pattern reaches character text starting character pattern characters pattern text characters matched mismatching pair encountered case retrieve entry column shift table text character aligned character pattern shift pattern characters text pseudocode horspool algorithm horspoolmatching implements horspool algorithm string matching input pattern text output index left matching substring matches shifttable generate table shifts position pattern matched characters table application horspool algorithm searching pattern barber text comprises english letters spaces denoted underscores shift table mentioned filled character shift actual text proceeds simple demonstrate worst case efficiency hor spool algorithm problem section exercises random texts efficiency class horspool algorithm faster average brute algorithm fact mentioned efficient sophisticated predecessor discovered boyer moore boyer moore algorithm outline boyer moore algorithm comparison rightmost character pattern character text fails algorithm thing horspool algorithm shifts pattern characters retrieved table precomputed explained earlier algorithms act differently positive pattern characters matched successfully mismatch encountered text pattern situation boyer moore algorithm determines shift size quantities guided text character caused mismatch counterpart pattern called badsymbol shift reasoning shift reasoning horspool algorithm pattern shift pattern text conveniently size shift computed formula entry precomputed table horspool algorithm matched characters text pattern barber text characters failing letter text shift pattern positions formula mismatching character text occurs pattern provided pattern barber text characters failing letter shift pattern positions shift pattern negative positions fall brute thinking simply shift pattern position summarize bad symbol shift computed boyer moore algorithm quantity positive negative expressed compact formula max shift guided successful characters pattern refer ending portion pattern suffix size denote suff shift good suffix shift apply reasoning guided filling bad symbol shift table based single alphabet character pattern suffixes sizes good suffix shift table case occurrence suff pattern accurate occurrence suff preceded character rightmost occurrence useless shift pattern occurrence suff preceded character simply failed trial case shift pattern distance rightmost occurrence preceded character rightmost occurrence suff rightmost occurrence pattern abcbab distances pattern abcbab occurrence suff preceded character rightmost occurrence cases shift pattern entire length pattern dbcbab shift pattern entire length characters shifting pattern entire length occurrence suff preceded character rightmost occurrence pattern abcbab shifting matching substring starts text aligned characters pattern shift pattern dbcbab abcbab pattern substring prefix beginning pattern suffix ending pattern erroneous shift based suffix size occurrence pattern preceded character rightmost occurrence longest prefix size matches suffix size prefix exists shift size computed distance prefix suffix set pattern length values good suffix table boyer moore algorithm pattern abcbab pattern abcbab prepared summarize boyer moore algorithm entirety boyer moore algorithm pattern alphabet pattern text construct bad symbol shift table earlier pattern construct good suffix shift table earlier align pattern beginning text matching substring pattern reaches character text starting character pattern characters pattern text character pairs matched mismatching pair encountered character pairs matched successfully case retrieve entry column bad symbol table text mismatched character retrieve entry good suffix table shift pattern positions computed formula max shifting maximum shifts log ical shifts based observations text mismatched character matched group pattern rightmost characters imply shifting characters spectively lead aligning pattern matching substring text interested shifting pattern missing matching substring maximum numbers searching pattern baobab text english letters spaces bad symbol table good suffix table filled pattern baobab actual pattern text figure proceeds pattern fails counterpart text algorithm retrieves bad symbol table shifts tern max positions successfully matches pairs characters failure comparison space character text algorithm retrieves bad symbol table good suffix table shift pattern max iteration good suffix leads farther shift pattern successfully matches pair failure comparison space character text algorithm retrieves bad symbol table good suffix table shift max figure string matching boyer moore algorithm pattern max iteration bad symbol leads farther shift pattern finds matching substring text successfully matching characters pattern counterparts text searching occurrence pattern worst case effi ciency boyer moore algorithm linear algorithm runs fast large alphabets relative length pattern people simplified versions horspool algorithm dealing natural language strings exercises apply horspool algorithm pattern baobab text bess knew baobabs problem searching genes dna sequences hor spool algorithm dna sequence represented text alphabet gene segment pattern construct shift table gene segment chromo tcctattctt apply horspool algorithm locate pattern dna sequence ttatagatctcgtattcttttatagatctcctattctt character comparisons horspool algorithm searching patterns binary text zeros searching text length pattern length horspool algorithm worst case input case input horspool algorithm make character comparisons brute algorithm make searching pattern text horspool algorithm discovers matching substring large shift make character comparisons boyer moore algorithm make searching patterns binary text zeros boyer moore algorithm correctly bad symbol table pattern shifts boyer moore algorithm correctly good suffix table pattern shifts characters pattern counterpart text horspool algorithm characters left boyer moore algorithm implement horspool algorithm boyer moore algorithm brute algorithm section language choice run experiment efficiencies matching random binary patterns random binary texts random natural language patterns natural language texts strings characters establish cyclic shift plea cyclic shift leap vice versa formally cyclic shift obtained concatenating character suffix character prefix design space efficient algorithm task space efficiencies algorithm design efficient algorithm task space efficiencies algorithm hashing section efficient implement dictionaries recall dictionary abstract data set operations searching lookup insertion deletion defined elements set arbitrary nature numbers characters alphabet character strings practice important case records student records school citizen records governmental office records library typically records comprise fields responsible keeping information entity represents student fields student date birth sex home address major fields called key identifying entities represented records student discussion assume implement dictionary records keys hashing based idea distributing keys dimensional array called hash table distribution computing keys predefined function called hash function assigns integer called hash address key keys nonnegative integers hash function mod remainder division keys letters alphabet assign letter position alphabet denoted ord apply kind function integers finally character string unsophisticated option mod option compute ord mod constant larger ord general hash function conflicting require ments hash table size excessively large compared keys sufficient jeopardize implementation efficiency hash function distribute keys cells hash table evenly requirement makes desirable applications hash function dependent bits key hash function easy compute obtained treating ord digits based computing decimal horner finding remainder dividing figure collision keys hashing choose hash table size smaller keys collisions phenomenon keys hashed cell hash table figure collisions expected considerably larger problem section exercises fact worst case keys hashed cell hash table fortunately appropriately chosen hash table size good hash function situation rarely hashing scheme collision resolution mechanism principal versions hashing called chaining closed hashing called addressing hashing chaining hashing keys stored linked lists attached cells hash table keys hashed cell words money parted hash function simple function strings mentioned positions word letters alphabet compute sum remainder division table key word hash mod key word installed ninth cell mod final result process figure collision keys mod dictionary implemented table linked lists simply applying key procedure creating table illustrate key kid hash table figure compute hash function key kid attached cell linked key collisions case traverse linked comparing string kid string unsuccessful general efficiency searching depends lengths linked lists dictionary table sizes quality keys money parted hash addresses money parted figure hash table construction chaining hash function hash function distributes keys cells hash table evenly keys ratio called factor hash table plays crucial role efficiency hashing average pointers chain links inspected successful searches unsuccessful searches turns standard assumptions searching randomly selected element hash function distributing keys uniformly table cells results natural identical searching sequentially linked gained hashing reduction average size factor size hash table factor small imply lot lists inefficient space large longer linked lists longer times factor amazingly efficient scheme makes key average price comparisons true addition comparisons spend computing hash function key constant operation independent remarkable efficiency result method ingenuity expense extra space dictionary operations insertion deletion identical searching insertions problem section exercises modification deletion performed searching key deleted removing efficiency operations identical searching average case keys equal hash table size closed hashing addressing closed hashing keys stored hash table linked lists implies table size large keys strategies employed collision resolution simplest called linear probing checks cell collision occurs cell key installed cell occupied availability cell successor checked hash table reached wrapped beginning table treated circular array method illustrated figure word hash function illustrate chaining key computing hash function table construction cell unsuccessful cell occupant equal matching key cell manner encounter matching key successful cell unsuccessful word lit table figure lit mod cell immediately kid mod kid parted declare unsuccessful insertion operations straightforward version hashing deletion simply delete key state hash table figure unable key afterward computing algorithm location unsuccessful result simple solution keys money parted hash addresses money parted money figure hash table construction linear probing lazy deletion previously occupied locations special symbol distinguish locations occupied mathematical analysis linear probing difficult problem chaining simplified versions results state average times algorithm access hash table factor successful unsuccessful searches accuracy approximations increases larger sizes hash table numbers surprisingly small densely populated tables large percentage values hash table closer performance linear prob ing deteriorates phenomenon called clustering cluster linear probing sequence contiguously occupied cells wrapping final state hash table figure clusters clus ters bad news hashing make dictionary operations efficient clusters larger probability element attached cluster increases addition large clusters probabil ity clusters coalesce key insertion causing clustering collision resolution strategies suggested alleviate problem important hashing scheme hash function determine fixed increment probing sequence collision location mod location table probed sequence incre ment table size prime common divisor condition satisfied automatically prime functions recommended literature mod small tables mod larger problem solved young graduate student mathematics named donald knuth important scientists multivolume treatise art programming knui knuii knuiii knuiv remains comprehensive influential algorithmics published mathematical analysis hashing proved difficult partial results considerable practical experience method good hashing functions primary secondary hashing perior linear probing performance deteriorates table natural solution situation rehashing current table scanned keys relocated larger table worthwhile main properties hashing balanced trees principal competitor implementing dictionaries asymptotic efficiency hashing searching insertion deletion implemented average worst case balanced trees average efficiencies log average worst cases ordering preservation balanced trees hashing assume existence key ordering makes hashing suitable applications iterate keys der require range queries counting keys lower upper bounds discovery ibm researchers hashing important applications standard technique stor ing symbol table symbols generated compilation hashing handy applications checking positions generated chess playing sidered modifications proved storing large dictionaries disks variation hashing called extendible hashing disk access expensive compared probes performed main mem ory preferable make probes disk accesses location computed hash function extendible hashing disk bucket hold keys key bucket identified keys read main memory searched key section discuss trees principal alternative storing large dictionaries exercises input hash function mod construct hash table largest key comparisons successful table average key comparisons successful table input hash function mod construct closed hash table largest key comparisons successful table average key comparisons successful table good idea hash function letter natural language word probability keys hashed cell hash table size hash function distributes keys evenly cells table birthday paradox birthday paradox asks people room chances birthday month day unexpected problem implication hashing result questions chaining version hashing insert keys knew keys dictionary distinct dictionary operations benefit modification keys linked sorted dictio nary operations benefit modification advantage keys stored entire table sorted hashing elements distinct efficiency application efficiency brute algorithm section presorting based algorithm section table average case entry worst case entry efficiency classes implementations adt dictionary unordered ordered binary balanced array tree hashing insertion deletion discussed hashing context techniques based space offs takes advantage general strategy write hashing problem natural language text generate distinct words occurrences word text insert counters pro gram empirical efficiency hashing theoretical results figure parental node tree trees idea extra space facilitate faster access data set partic ularly important data set large records stored disk principal device organizing data sets index information location records key values data sets structured records opposed unstruc tured data text images video important index organization tree introduced bayer mcgreight bay extends idea tree section permitting single key node tree version data records keys stored leaves increasing keys parental nodes indexing specifically parental node ordered keys assumed sake simplicity distinct keys interposed pointers node children keys subtree smaller keys subtree greater equal smaller equal smallest key subtree keys greater equal smallest key figure addition tree structural properties root leaf children node root leaves children keys tree perfectly balanced leaves node depicted figure called node nodes classic binary tree nodes tree introduced section comprises nodes figure tree figure searching tree similar searching binary tree starting root chain pointers leaf key keys leaf keys stored sorted parental nodes leaves binary keys node large make worthwhile key comparisons concerned typical application data structure storing large data disk nodes tree correspond disk pages needed access disk page typically orders magnitude larger needed keys fast memory disk accesses principal indicator efficiency similar data structures nodes tree access key equal height tree estimate height smallest keys tree positive height root tree key nodes keys total minimum keys nodes children nodes total minimum keys general nodes keys finally leaf nodes key tree nodes height inequality series standard simplifications problem section exercises inequality reduces yields upper bound height tree nodes log inequality immediately implies searching tree log operation important ascertain efficiency class actual disk accesses implied formula table values estimates records typical values tree upper bound mind table entries upper estimates disk accesses actual applications rarely exceeds tree root nodes stored fast memory minimize disk accesses operations insertion deletion straightforward ing log outline insertion algorithm deletion algorithm references aho cor straightforward algorithm inserting tree similar algorithm insertion tree outlined section apply procedure key leaf room leaf position keys sorted room leaf split half sending half records node smallest key node pointer inserted leaf parent immediately key pointer leaf recursive procedure percolate tree root created halves root keys split children root figure shows result inserting tree figure restriction leaves items aware algorithms implementing inser tions tree possibility recursive node splits split nodes encountered searching leaf possibility node splits moving key node sibling inserting tree figure moving smallest key leaf sibling keys replacing key parent smallest figure tree obtained inserting tree figure child modification space expense slightly complicated algorithm tree indexing large considered tree varieties types trees binary trees avl trees btree constructed successive insertions data records initially tree considered tree keys reside leaves upper levels organized tree comprising index entire structure called fact tree exercises examples index real life applications involve computers prove equality derivation upper bound height tree derivation inequality minimum tree guarantees disk accesses searching records exceed assume root page stored main memory draw tree obtained inserting tree figure assume leaf items outline algorithm finding largest key tree modifica tion insert operation leaf key encounters node keys node split nodes sending middle key node parent node root middle key created construct tree inserting keys initially tree principal advantage insertion procedure compared trees section disadvantage write implementing key insertion algorithm tree write visualization key insertion algorithm tree summary space offs algorithm design issue theoreticians practitioners computing algorithm design technique trading space prevalent trading space input enhancement principal varieties trading space algorithm design idea preprocess problem input additional information obtained accelerate solving problem afterward sorting distribution counting important algorithms string matching examples algorithms based technique distribution counting special method sorting lists elements small set values horspool algorithm string matching considered simplified version boyer moore algorithm algorithms based ideas input enhancement left comparisons pattern characters algorithms bad symbol shift table boyer moore table called good suffix shift table prestructuring technique exploits space offs extra space facilitate faster flexible access data hashing trees important examples prestructuring hashing efficient approach implementing dictionaries based idea mapping keys dimensional table size limitations table make collision resolution mechanism principal varieties hashing chaining keys stored linked lists hash table closed hashing addressing keys stored table enable searching insertion deletion average tree balanced tree generalizes idea tree allowing multiple keys node principal application called tree keeping index information data stored disk choosing tree appropriately implement operations searching insertion deletion disk accesses extremely large files
ideas gleaming jeweler velvet calculus algorithm calculus rich body mathematical analysis gave rise modern science algorithm modern world david berlinski advent algorithm study algorithms professional practical theoretical reasons study algo rithms practical standpoint standard set important algorithms areas computing addition design algorithms analyze efficiency theoretical stand study algorithms called algorithmics recognized cornerstone science david harel delightful pointedly titled algorithmics spirit computing algorithmics science core science fairness relevant science business technology har student computing related compelling reasons study algorithms bluntly programs algorithms applications indispensable aspects professional personal lives studying algorithms necessity people reason studying algorithms usefulness developing alytical skills algorithms special kinds solutions problems answers precisely defined procedures answers specific algorithm design techniques interpreted problem solving strategies involved precision inherently imposed algorithmic thinking limits kinds problems solved algorithm living happy life rich famous required precision important educational advantage donald knuth prominent scientists history algorithmics person trained science deal algorithms construct manipulate understand analyze knowledge preparation writing good programs general purpose mental tool definite aid understanding subjects chemistry linguistics music reason understood person understand teaching person understand teaching expressing algorithm formalize things algorithms leads deeper understanding simply comprehend things traditional knu notion algorithm section examples algorithms problem computing greatest common divisor reasons choice deals problem familiar erybody middle school days makes important problem solved algorithms typically algorithms differ idea sophistication efficiency algorithms deserves introduced age peared euclid famous treatise years ago enduring power importance finally investigation algorithms leads general observations important properties algo rithms general section deals algorithmic problem solving discuss important issues related design analysis algorithms aspects algorithmic problem solving range analysis problem means expressing algorithm establishing correctness analyzing efficiency section magic recipe designing algorithm arbitrary problem established fact recipe material section organizing designing analyzing algorithms section devoted problem types proven partic ularly important study algorithms application fact textbooks sed organized problem types hold view shared organization based algorithm design techniques superior case important aware princi pal problem types commonly encountered problem types real life applications demonstrate algorithm design techniques section review fundamental data structures meant reference deliberate discussion topic detailed exposition wealth good books subject tailored programming language algorithm universally agreed wording notion general agreement concept means algorithm sequence unambiguous instructions solving problem obtaining required output legitimate input finite definition illustrated simple diagram figure reference instructions definition implies thing capable understanding instructions keeping mind electronic invented word meant human involved ing numeric calculations nowadays computers ubiquitous electronic devices indispensable majority algorithms intended eventual implementation notion algorithm assumption examples illustrating notion algorithm section methods solving problem computing greatest common divisor integers examples illustrate important points nonambiguity requirement algorithm promised range inputs algorithm works carefully algorithm represented ways algorithms solving problem algorithm input output figure notion algorithm algorithms problem based ideas solve problem dramatically speeds recall greatest common divisor nonnegative integers denoted gcd defined largest integer divides evenly remainder euclid alexandria century outlined algorithm solving problem volumes elements famous systematic exposition geometry modern terms euclid algorithm based applying repeatedly equality gcd mod remainder division mod equal gcd greatest common divisor initial gcd computed gcd impressed algorithm finding greatest common divisor larger numbers problem section exercises structured description algorithm euclid algorithm computing gcd proceed assign remainder assign alternatively express algorithm pseudocode algorithm euclid computes gcd euclid algorithm input nonnegative integers output greatest common divisor mod euclid algorithm eventually observation integer pair smaller iteration negative iteration mod smaller integer eventually algorithm stops problems algorithms computing greatest common divisor methods problem simply based definition greatest common divisor largest integer divides numbers evenly common divisor greater smaller numbers denote min checking divides simply decrease process eventually numbers algorithm reaches stops consecutive integer checking algorithm computing gcd assign min remainder division remainder division proceed decrease euclid algorithm presented correctly input numbers illustrates important set algorithm inputs explicitly carefully procedure finding greatest common divisor familiar middle school middle school procedure computing gcd prime factors prime factors common factors prime expansions common factor occurring times repeated min times compute product common factors greatest common divisor numbers gcd nostalgia days learned method noting procedure complex slower euclid algorithm discuss methods finding comparing running times algorithms chapter addition inferior efficiency middleschool procedure qualify presented legitimate algorithm prime factorization steps defined unambiguously require prime numbers strongly middle school math teacher unnecessary nitpicking issue resolved write implementing procedure incidentally defined ambiguity easier rectify factorization steps common elements sorted lists simple algorithm generating consecutive primes exceeding integer invented ancient greece sieve eratosthenes algorithm starts initializing prime candidates consecutive integers iteration algorithm eliminates multiples moves item eliminates multiples straightforward version overhead numbers eliminated needed multiples eliminated previous remaining algorithm continues fashion numbers eliminated remaining integers primes needed application algorithm finding primes exceeding passes needed eliminate num bers eliminated previous iterations algorithm remaining numbers consecutive primes equal largest multiples make iterations algorithm multiples eliminated current multiple smaller multiples eliminated earlier passes observation helps eliminating greater exceed rounded denoted called floor function assume pseudocode function computing alternatively inequality loop continuation condition algorithm sieve implements sieve eratosthenes input positive integer output array prime numbers equal ndo pseudocode eliminated previous passes element eliminated remaining elements array primes incorporate sieve eratosthenes middle school procedure legitimate algorithm computing greatest common divisor positive integers special exercised input numbers equal mathematicians prime strictly speaking method inputs leave section comment examples considered section majority algorithms today implemented programs deal mathematical problems algorithms helping daily routines professional personal ubiquity algorithms today world resolve fascinating engines information age exercises research khorezmi khwarizmi word algorithm derived origins words algorithm algebra common official purpose patent promotion arts algorithms patentable country write driving directions school home precision required algorithm description write recipe cooking favorite dish precision required algorithm design algorithm computing positive integer assignment comparison algorithm basic arithmetical operations design algorithm common elements sorted lists numbers lists output maximum comparisons algorithm makes lengths lists gcd applying euclid algorithm estimate times faster gcd euclid algorithm compared algorithm based checking secutive integers min gcd prove equality gcd mod pair positive integers euclid algorithm pair integers smaller maximum times algorithm execution input minimum divisions euclid algorithm inputs maximum divisions euclid algorithm inputs euclid algorithm presented euclid treatise subtractions integer divisions write pseudocode version euclid algorithm euclid game bog starts unequal positive integers board players player write board positive equal difference numbers board numbers board player loses game choose game extended euclid algorithm determines greatest common divisor positive integers necessarily positive description extended euclid algorithm knui implement language choice modify integer solutions diophantine equation set integer coefficients locker doors lockers hallway numbered sequentially initially locker doors closed make passes lockers starting locker ith toggle door ith locker door closed locker doors closed fundamentals algorithmic problem solving reiterating important introduction chapter algorithms procedural solutions problems solutions answers specific instructions answers emphasis precisely defined constructive procedures makes science distinct disciplines distinguishes oretical mathematics practitioners typically satisfied proving existence solution problem possibly investigating solution properties briefly discuss sequence steps typically designing analyzing algorithm figure understanding problem practical perspective thing designing algorithm understand completely problem read problem description carefully questions doubts problem small examples special cases questions needed types problems arise computing applications review section problem algorithm solving helps understand algorithm works strengths weaknesses choose algorithms readily algorithm design sequence steps outlined section exciting easy task input algorithm specifies instance problem algorithm solves important set instances algorithm recall variations set instances greatest common divisor algorithms discussed previous section algorithm correctly majority inputs boundary algorithm works correctly legitimate inputs skimp algorithmic problem solving process run unnecessary rework ascertaining capabilities computational device completely understand problem ascertain capabilities computational device algorithm intended vast majority understand problem computational means exact approximate solving algorithm design technique design algorithm prove correctness analyze algorithm code algorithm figure algorithm design analysis process algorithms today destined programmed closely resembling von neumann machine architecture outlined prominent hungarian american mathematician john von neumann collaboration burks goldstine essence architecture captured called random access machine ram central assumption instructions executed operation algorithms designed executed machines called sequential algorithms central assumption ram model hold newer computers execute operations concurrently parallel algorithms advantage capability called parallel algorithms studying classic techniques design analysis algorithms ram model remains cornerstone algorithmics foreseeable future speed memory disposal designing algorithm scientific qualified section scientists study algorithms terms independent specification parameters designing algorithm practical tool problem solve computers today unimaginably fast situations task important problems complex nature process huge volumes data deal applications critical situations imperative aware speed memory choosing exact approximate problem solving principal decision choose solving problem solving approximately case algorithm called exact algorithm case algorithm called approximation algorithm opt approximation algorithm important problems simply solved instances examples extracting square roots solving nonlinear equations evaluating definite integrals algorithms solving problem unacceptably problem intrinsic complexity problems involving large choices examples difficult problems chapters approximation algorithm sophisticated algorithm solves problem algorithm design techniques components algorithmic problem solving design algorithm solve problem main seeks teaching general design techniques algorithm design technique algorithm design technique strategy paradigm general approach solving problems algorithmically applicable variety problems areas computing table contents majority chapters devoted individual design techniques distill key ideas proven designing algorithms learning techniques utmost importance reasons guidance designing algorithms problems satisfactory algorithm language famous proverb learning techniques akin learning fish opposed fish caught true general techniques necessarily applicable problem encounter constitute powerful collection tools handy studies algorithms cornerstone science interested classifying principal subject science exception algorithm design techniques make classify algorithms underlying design idea natural categorize study algorithms designing algorithm data structures algorithm design techniques powerful set general proaches algorithmic problem solving designing algorithm problem challenging task design techniques simply inapplicable problem techniques combined algorithms hard pinpoint applications design techniques design technique plicable algorithm requires nontrivial ingenuity algorithm designer practice tasks choosing general techniques applying easier rarely easy pay attention choosing data structures appro priate operations performed algorithm sieve eratosthenes introduced section run longer linked array implementation gorithm design techniques discussed chapters intimately structuring restructuring data problem instance years ago influential textbook proclaimed fundamental importance algo rithms data structures programming title algorithms data structures programs wir world oriented pro gramming data structures crucially important design analysis algorithms review basic data structures section methods algorithm designed algorithm fashion section euclid algorithm words free pseudocode options widely nowadays algorithms natural language obvious appeal inherent ambi guity natural language makes succinct description algorithms surprisingly difficult important skill strive process learning algorithms pseudocode mixture natural language programming language constructs pseudocode precise natural language usage yields succinct algorithm descriptions surprisingly scientists agreed single pseudocode leaving textbook authors design dialects fortunately dialects familiar modern programming language understand dialect selected minimal difficulty reader sake simplicity omit declarations variables indentation scope statements previous section arrow assignment operation slashes comments earlier days computing dominant vehicle algorithms flowchart method expressing algorithm collection connected geometric shapes descriptions algorithm steps representation technique proved inconvenient simple algorithms nowadays algorithm books state art computing reached algorithm description natural language pseudocode fed electronic directly converted written language algorithm preferable algorithm implementation proving algorithm correctness algorithm prove correctness prove algorithm yields required result legitimate input finite correctness euclid algorithm computing greatest common divisor stems correctness equality gcd mod proof problem exercises simple observation integer smaller iteration algorithm fact algorithm stops integer algorithms proof correctness easy complex common technique proving correctness mathematical induction algorithm iterations natural sequence steps needed proofs mentioning tracing algorithm performance specific inputs worthwhile activity prove algorithm correctness conclusively algorithm incorrect instance input algorithm fails notion correctness approximation algorithms straightforward exact algorithms approximation algorithm error produced algorithm exceed predefined limit examples investigations chapter analyzing algorithm algorithms qualities correctness important efficiency fact kinds algorithm efficiency indicating fast algorithm runs space ficiency indicating extra memory general framework specific techniques analyzing algorithm efficiency chapter desirable characteristic algorithm simplicity effi ciency precisely defined investigated mathematical rigor simplicity beauty considerable degree eye beholder people euclid algorithm simpler middle school procedure computing gcd clid algorithm simpler consecutive integer checking algorithm simplicity important algorithm characteristic strive sim pler algorithms easier understand easier resulting programs bugs undeniable aes thetic appeal simplicity simpler algorithms efficient complicated alternatives true case judicious compromise desirable characteristic algorithm generality fact issues generality problem algorithm solves set inputs accepts issue easier design algorithm problem posed general terms problem determining integers prime common divisor equal easier design algorithm general problem computing greatest common divisor integers solve problem gcd situations designing general algorithm unnecessary difficult impossible unnecessary sort numbers median smallest element standard formula roots quadratic equation generalized polynomials arbitrary degrees set inputs main designing algorithm set inputs natural problem integers equal inputs greatest common divisor algorithm unnatural standard formula roots quadratic equation holds complex coefficients implement generality capability explicitly required satisfied algorithm efficiency simplicity generality drawing board redesign algorithm fact evaluation positive searching algorithmic solutions recall algorithms previous section computing greatest common divisor generally algorithm fine tune algorithm improvements implementation sieve eratosthenes compared initial outline section mind observation antoine saint exupe french writer pilot aircraft designer arrived perfection longer coding algorithm algorithms destined ultimately implemented pro grams programming algorithm presents peril opportunity peril lies possibility making transition algorithm pro gram incorrectly inefficiently influential scientists strongly correctness proven mathematical rigor considered developed special techniques proofs gri power techniques formal verification small programs practical validity programs established testing programs art science books devoted testing debugging important debug implement algorithm assume inputs algorithms sets require verification implementing algorithms programs actual applications verifications implementing algorithm correctly sufficient diminish algorithm power inefficient implemen tation modern compilers safety net regard code optimization mode aware standard tricks computing loop invariant expression loop collecting common subexpressions replac ing expensive operations cheap ker ben good discussion code tuning issues related algorithm ming typically improvements speed constant factor algorithm make difference running orders magnitude algorithm selected speedup effort design simplicity essay collection jon bentley ben essays deal variety issues algorithm design implementation justifiably titled programming pearls wholeheartedly recommend writings jon bentley antoine saint exupe working additional opportunity allowing pirical analysis underlying algorithm analysis based timing inputs analyzing results obtained dis cuss advantages disadvantages approach analyzing algorithms section conclusion emphasize main lesson process depicted figure good algorithm result repeated effort rework fortunate algorithmic idea perfect improved good news makes ultimate result enjoyable naming joy algorithms real world project schedule impatience boss perfection expensive fact called designing algorithm engineering activity calls compromises competing goals constraints resources designer resources academic world leads interesting difficult investigation algorithm optimality efficiency algorithm complexity problem solves minimum effort algorithm exert solve problem problems algorithm sorts array comparing values elements log comparisons arrays size section seemingly easy problems integer multiplication scientists final important issue algorithmic problem solving problem solved algorithm talking problems solution finding real roots quadratic equation negative discriminant cases output indicating problem solution algorithm talking ambiguously stated problems unambiguous problems simple undecidable unsolvable algorithm important problem appears section fortunately vast majority problems practical computing solved algorithm leaving section misconception possibly caused mechanical nature diagram figure designing algorithm dull activity truth inventing discovering algorithms creative rewarding process designed convince case exercises world puzzle peasant finds riverbank wolf goat cabbage river boat room peasant item wolf goat cabbage absence wolf eat goat eat cabbage solve problem peasant prove solution peasant vegetarian cabbage eat goat cabbage solve problem wolf protected species world puzzle people rickety bridge begin minutes night flashlight maximum people bridge party crosses people flashlight walked thrown person takes minute bridge person takes minutes person takes minutes person takes minutes pair rate slower person pace rumor internet interviewers software company located seattle problem interviewees formulas considered algorithm comput ing area triangle lengths positive numbers angle sides aha height base write pseudocode algorithm finding real roots equation arbitrary real coefficients assume availability square root function sqrt standard algorithm finding binary representation positive decimal integer english pseudocode algorithm favorite atm machine dispensing cash description english pseudocode convenient problem computing solved instances problem algorithm problem internet problem computing greatest common divisor algorithm simpler efficient algorithm finding distance closest elements array numbers algorithm mindistance input array numbers output minimum distance elements dmin make improvements algorithmic solution problem algorithm altogether implementation influential books problem solving titled solve pol written hungarian american mathematician george lya summarized ideas summary internet outlined section common important problem types limitless sea problems encounters computing areas attracted attention researchers large driven problem practical importance specific characteristics making problem interesting research subject fortunately motivating forces reinforce cases section important problem types sorting searching string processing graph problems combinatorial problems geometric problems numerical problems subsequent chapters illustrate algorithm design techniques methods algorithm analysis sorting problem rearrange items nondecreasing problem meaningful nature items ordering mathematicians relation total ordering practical sort lists numbers characters alphabet character strings important records similar maintained schools students libraries holdings companies employees case records choose piece information sorting choose sort student records alphabetical names student grade average specially chosen piece information called key scientists sorting keys items records integers sorted begin sorted required output task ranking internet results ranking students gpa scores sorting makes questions easier important searching dictionaries books class lists sorted examples usefulness presorting section similar vein sorting auxiliary important algorithms areas geometric algorithms data compression greedy approach important algorithm design technique discussed requires sorted input scientists discovered dozens sorting algorithms fact inventing sorting algorithm likened designing proverbial mousetrap happy sorting mousetrap continues perseverance admirable view facts good sorting algorithms sort arbitrary array size log comparisons algorithm sorts key comparisons opposed comparing small pieces keys substantially reason embarrassment algorithmic riches sorting algorithms algorithm solution situations algorithms simple faster complex randomly ordered inputs sorted lists suitable lists residing fast memory adapted sorting large files stored disk properties sorting algorithms special mention sorting algorithm called stable preserves relative equal elements input words input equal elements positions sorted positions property desirable students sorted alphabetically sort student gpa stable algorithm yield students gpa sorted alphabetically generally speaking algorithms exchange keys located stable faster general comment applies important sorting algorithms notable feature sorting algorithm extra memory algorithm requires algorithm require extra memory possibly memory units important sorting algorithms searching problem deals finding called key set multiset permits elements plenty searching algorithms choose range straightforward sequential spectacularly efficient binary algorithms based representing underlying set conducive searching algorithms importance real world applications indispensable storing retriev ing information large databases searching single algorithm fits situations algorithms faster require memory fast applicable sorted arrays sorting algorithms stability problem issues arise specifically applications underlying data frequently relative searches searching considered conjunction operations addition deletion data set item situations data structures algorithms chosen strike requirements operation organizing large data sets efficient searching poses special challenges important implications real world applications string processing recent decades rapid proliferation applications dealing nonnumer ical data intensified researchers computing practitioners string handling algorithms string sequence characters alphabet strings text strings comprise letters numbers special characters bit strings comprise zeros gene sequences modeled strings characters character alphabet pointed string processing algorithms important science conjunction languages compiling issues problem searching word text attracted special attention researchers string matching algorithms exploit special nature searching invented simple algorithm chapter discuss algorithms based remarkable idea boyer moore chapter graph problems oldest interesting areas algorithmics graph algorithms informally graph thought collection points called vertices connected line segments called edges formal definition section graphs interesting subject study theoretical practical reasons graphs modeling wide variety applications transportation communication social economic networks project scheduling games studying technical social aspects internet active areas current research involving scientists economists social scientists eas basic graph algorithms graph traversal algorithms points network shortest path algorithms route cities topological sorting graphs directed edges set courses prerequisites consistent contradictory fortunately algorithms considered illustrations general design techniques chapters graph problems computationally hard examples traveling salesman problem graph coloring problem traveling salesman problem tsp problem finding shortest cities visits city addition obvious applications involving route planning arises modern applications circuit board vlsi chip fabrication ray crystallography genetic engineering graph coloring problem seeks assign smallest colors vertices graph adjacent vertices color problem arises applications event scheduling events represented vertices connected edge events scheduled solution graph coloring problem yields optimal schedule combinatorial problems abstract perspective traveling salesman problem graphcoloring problem examples combinatorial problems explicitly implicitly combinatorial permutation combination subset satisfies constraints desired combinatorial required additional property maximum minimum cost generally speaking combinatorial problems difficult problems computing theoretical practical standpoint difficulty stems facts combinatorial objects typically grows extremely fast problem size reaching unimaginable magnitudes moderate sized instances algorithms solving problems acceptable scientists algorithms conjecture proved disproved remains important unresolved issue theoretical science discuss topic section combinatorial problems solved efficient algorithms considered fortunate exceptions shortest path problem mentioned earlier exceptions geometric problems geometric algorithms deal geometric objects points lines poly gons ancient greeks interested developing procedures algorithms solving variety geometric problems constructing simple geometric shapes triangles circles unmarked ruler compass years intense geometric algorithms disappeared resurrected age computers rulers compasses bits bytes good human ingenuity today people interested geometric algorithms applications mind graphics robotics tomography discuss algorithms classic problems computational geometry closest pair problem convex hull problem closest pair problem explanatory points plane closest pair convex hull problem asks smallest convex polygon points set interested geometric algorithms wealth material specialized monographs deb oro pre numerical problems numerical problems large special area applications problems involve mathematical objects continuous nature solving equations systems equations computing definite integrals evaluating functions majority mathematical problems solved approximately principal difficulty stems fact problems typically require manipulating real numbers represented approximately large arithmetic operations performed approximately represented numbers lead accumulation error drastically distort output produced seemingly algorithm sophisticated algorithms developed years area critical role scientific engineering applications years computing industry shifted focus business applications require primarily algorithms information storage retrieval transportation networks presentation users result revolutionary numerical analysis lost dominating position industry science programs important literate person rudimentary idea numerical algorithms discuss classical numerical algorithms sections exercises algorithm sorting problem sorts array counting elements smaller elements information element position sorted array algorithm comparisoncountingsort sorts array comparison counting input array orderable values output array elements sorted nondecreasing apply algorithm sorting algorithm stable algorithms searching problem good succinct description algorithm english algorithms opportunity design simple algorithm string matching problem nigsberg bridges nigsberg bridge puzzle universally accepted problem gave birth graph theory solved great swiss born mathematician leonhard euler problem asked single stroll bridges city nigsberg starting sketch river islands bridges state problem graph problem solution draw stroll smallest bridges required make stroll icosian game century euler discovery problem famous puzzle invented renowned irish mathematician sir william hamilton presented world icosian game board circular wooden board graph carved hamiltonian circuit path visits graph vertices returning starting vertex graph problem design algorithm determine route subway passenger designated station developed subway similar cities washington london problem statement vague typical real life problems reasonable criterion defining route model problem graph rephrase traveling salesman problem combinatorial terms rephrase graph coloring problem combinatorial terms map graph coloring problem color map neighboring regions colored color map smallest colors design algorithm problem set points cartesian plane determine circumference write reads inputs coordinates endpoints line segments determines segments common fundamental data structures vast majority algorithms operate data ways organizing data critical role design analysis algorithms data structure defined scheme organizing related data items nature data items dictated problem range elementary data types integers characters data structures dimensional array dimensional arrays implementing matrices data structures proved important algorithms undoubtedly familiar quick review provided linear data structures important elementary data structures array linked dimensional array sequence items data stored contiguously memory accessible array index figure majority cases index integer shown figure languages array index range integer bounds low high nonnumerical indices data items months year month names element array accessed constant array element located feature positively distinguishes arrays linked lists discussed arrays implementing variety data structures promi nent string sequence characters alphabet termi nated special character indicating string strings composed zeros called binary strings bit strings indispensable pro cessing textual data defining languages compiling programs written studying abstract computational models operations strings differ typically arrays numbers computing string length comparing strings determine precedes lexicographic alphabetical der concatenating strings forming string strings appending linked sequence elements called nodes kinds information data links called pointers nodes linked special pointer called null absence node successor singly linked node single pointer element figure access node linked starts node traverses pointer chain node reached needed access element singly linked array depends element located positive linked lists item figure array elements item null figure singly linked elements null item null figure doubly linked elements require preliminary reservation memory insertions deletions efficiently linked reconnecting pointers exploit flexibility linked structure variety ways convenient linked special node called header node information linked current length addition pointer element pointer linked element extension structure called doubly linked node pointers successor predecessor figure array linked principal choices representing abstract data structure called linear simply finite sequence data items collection data items arranged linear basic operations performed data structure searching inserting deleting element special types lists stacks queues important stack insertions deletions called stack visualized horizontally vertically akin stack plates operations mimics closely result elements added pushed stack deleted popped structure operates lifo fashion stack plates plate stacks multitude applications indispensable implementing recursive algorithms elements deleted structure called operation called dequeue elements added called rear operation called enqueue operates fifo fashion akin customers served single teller bank queues important applications algorithms graph problems important applications require selection item highest priority dynamically changing set candidates data structure seeks applications called priority collection data items totally ordered universe integer real numbers principal operations priority ing largest element deleting largest element adding element priority implemented operations yield priority straightforward implementations data struc ture based array sorted array options yields efficient solution implementation priority based ingenious data structure called discuss heaps important sorting algorithm based section graphs mentioned previous section graph informally thought collection points plane called vertices nodes connected line segments called edges arcs formally graph defined pair sets finite nonempty set items called vertices set pairs items called edges pairs vertices unordered pair vertices pair vertices adjacent connected undirected edge vertices endpoints edge incident edge incident endpoints graph called undirected edge undirected pair vertices pair edge directed vertex called edge tail vertex called edge leaves enters graph edge directed called directed graphs called digraphs convenient vertices graph digraph letters integer numbers application calls character strings figure graph depicted figure vertices undirected edges digraph depicted figure vertices directed edges figure undirected graph digraph definition graph forbid loops edges connecting vertices explicitly stated graphs loops definition disallows multiple edges vertices undirected graph inequality edges undirected graph vertices loops largest edges graph edge connecting vertices product includes edge graph pair vertices connected edge called standard notation graph vertices graph edges missing called dense graph edges relative vertices called sparse dealing dense sparse graph choose represent graph running algorithm designed graph representations graphs algorithms represented ways adjacency matrix adjacency lists adjacency matrix graph vertices boolean matrix row column graph vertices element ith row column equal edge ith vertex equal edge adjacency matrix graph figure adjacency matrix undirected graph symmetric adjacency lists graph digraph collection linked lists vertex vertices adjacent vertex vertices connected edge lists header identifying vertex compiled figure represents graph figure adjacency lists figure adjacency matrix adjacency lists graph figure adjacency lists columns adjacency matrix vertex graph sparse adjacency representation space adjacency matrix extra storage consumed pointers linked lists situation dense graphs general representations convenient depends nature problem algorithm solving possibly input graph sparse dense weighted graphs weighted graph weighted digraph graph numbers assigned edges numbers called weights costs graphs motivated numerous real world applica tions finding shortest path points transportation communication network traveling salesman problem mentioned earlier principal representations graph easily adopted accommo date weighted graphs weighted graph represented adjacency matrix element simply weight edge ith vertex edge special symbol edge matrix called weight matrix cost matrix approach illustrated figure weighted graph figure plications convenient main diagonal adjacency matrix adjacency lists weighted graph nodes adjacent vertex weight edge figure paths cycles properties graphs important great applications connectivity acyclicity based notion path vertex graph defined sequence adjacent connected edge vertices starts ends vertices path distinct path simple length path total vertices vertex sequence defining path edges path simple path length graph figure path simple length figure weighted graph weight matrix adjacency lists figure graph connected case directed graph interested directed paths directed path sequence vertices consecutive pair vertices connected edge directed vertex listed vertex listed directed path graph figure graph connected pair vertices path make model connected graph connecting balls representing graph vertices strings representing edges single piece graph connected model connected pieces called connected components graph formally connected component maximal expandable vertex edge connected subgraph graph graphs figures connected graph figure path graph figure connected components vertices graphs connected components real world appli cations graph representing interstate highway united states important applications graph consideration cycles path positive length starts ends vertex traverse edge graph figure graph cycles acyclic discuss acyclic graphs subsection trees tree accurately free tree connected acyclic graph figure graph cycles necessarily connected called forest connected components tree figure subgraph graph figure tree forest figure free tree transformation rooted tree trees important properties graphs par ticular edges tree vertices graph figure demonstrates property suffi cient graph tree connected graphs sufficient convenient checking connected graph rooted trees important property trees fact vertices tree exists simple path vertices property makes select arbitrary vertex free tree root called rooted tree rooted tree depicted placing root tree vertices adjacent root vertices edges root figure presents transformation free tree rooted tree rooted trees important role science important free trees fact sake brevity referred simply trees obvious application trees describing hierarchies directories organizational charts enterprises obvious applications implementing dictionaries efficient access large data sets section data encoding section discuss chapter trees helpful analysis recursive algorithms finish tree applications mention called state space trees underline important algorithm design techniques backtracking bound sections vertex tree vertices simple path root vertex called ancestors vertex considered ancestor set ancestors excludes vertex referred set proper ancestors edge simple path root vertex parent called child vertices parent siblings vertex children called leaf vertex child called parental vertices vertex ancestor descendants proper descendants exclude vertex descendants vertex edges connecting subtree rooted vertex tree figure root tree vertices leaves vertices parental parent children siblings vertices subtree rooted depth vertex length simple path root height tree length longest simple path root leaf depth vertex tree figure height tree levels starting root depth vertex simply tree height maximum vertices fact authors define height tree levels makes height tree larger height defined length longest simple path root leaf ordered trees ordered tree rooted tree children vertex ordered convenient assume tree diagram children ordered left binary tree defined ordered tree vertex children child designated left child parent binary tree binary tree figure binary tree root left child vertex binary tree called left subtree vertex left subtrees binary trees binary tree defined recursively makes solve problems involving binary trees recursive algorithms figure binary tree binary tree null figure standard implementation binary tree figure numbers assigned vertices binary tree figure assigned parental vertex larger numbers left subtree smaller numbers subtree trees called binary trees binary trees binary trees wide variety applications science encounter binary trees generalized general types trees called multiway trees indispensable efficient access large data sets efficiency important algorithms binary trees extensions depends tree height fore inequalities height binary tree nodes important analysis algorithms log binary tree implemented computing purposes collection nodes vertices tree node informa tion vertex assigned pointers nodes representing left child vertex spectively figure illustrates implementation binary tree figure representation arbitrary ordered tree simply providing parental vertex pointers equal children representation prove inconvenient children varies widely nodes inconvenience nodes pointers binary trees left pointer child vertex pointer sibling representation called child sibling representation siblings vertex linked nodes pointers singly linked element pointed left pointer parent figure illustrates representation tree figure difficult representation effectively transforms ordered tree binary tree ordered tree representation rotating pointers degrees clockwise figure sets dictionaries notion set plays central role mathematics set unordered collection possibly distinct items called elements null figure child sibling representation tree figure binary tree representation set specific set defined explicit listing elements property set elements prime smaller important set operations checking membership item set finding union sets comprises elements finding intersection sets comprises common elements sets implemented applications ways considers sets subsets large set called universal set elements subset represented bit string size called bit vector ith element ith element included set represented bit string representing sets makes implement standard set operations fast expense potentially large storage common represent set computing purposes structure set elements option feasible finite sets fortunately mathematics kind sets applications principal points distinction sets lists set identical elements requirement uniqueness circumvented introduction multiset bag unordered collection items necessarily distinct set unordered collection items changing elements set defined ordered collection items important theoretical distinction fortunately important applications mentioning set represented depending application maintaining sorted computing operations set multiset searching item adding item deleting item collection data structure implements operations called dictionary relationship data structure problem searching mentioned section dealing searching dynamic context efficient implementation dictionary strike compromise efficiency searching efficiencies operations ways dictionary implemented range unsophisticated arrays sorted sophisticated techniques hashing balanced trees discuss applications computing require dynamic partition element set collection disjoint subsets initialized collection element subsets collection subjected sequence intermixed union operations problem called set union problem discuss efficient algorithmic solutions problem section conjunction important applications noticed review basic data structures mentioned specific operations typically performed structure intimate relationship data operations recognized scientists led idea abstract data adt set abstract objects representing data items collection operations performed illustrations notion reread definitions priority dictionary abstract data types implemented older procedural languages pascal aho convenient oriented languages java abstract data types means classes exercises implement operations array takes array size delete ith element array delete ith element sorted array remaining array sorted solve searching problem numbers advantage fact sorted answers lists represented arrays lists represented linked lists stack operation sequence starts stack operation sequence starts enqueue dequeue enqueue dequeue adjacency matrix undirected graph prop erty matrix graph loop edge connecting vertex iii graph isolated vertex edges incident questions adjacency representation detailed description algorithm transforming free tree rooted vertex free tree prove inequalities bracket height binary tree vertices log adt priority implemented unsorted array sorted array binary tree implement dictionary small size knew elements distinct names states united states implementation dictionary operation applications data structure answering calls priorities sending backlog orders customers received implementing calculator computing simple arithmetical expressions anagram checking design algorithm checking words anagrams word obtained permuting letters words tea eat anagrams summary algorithm sequence nonambiguous instructions solving problem finite input algorithm specifies instance problem algorithm solves algorithms natural language pseudocode implemented programs ways classify algorithms principal alternatives group algorithms types problems solve group algorithms underlying design techniques based important problem types sorting searching string processing graph problems combinatorial problems geometric problems numerical problems algorithm design techniques strategies paradigms general approaches solving problems algorithmically applicable variety problems areas computing designing algorithm undoubtedly creative activity sequence interrelated actions involved process summarized figure good algorithm result repeated efforts rework problem solved algorithms computing greatest common divisor integers euclid algorithm consecutive integer checking algorithm middle school method enhanced sieve eratosthenes generating primes algorithms operate data makes issue data structuring critical efficient algorithmic problem solving important elementary data structures array linked representing abstract data structures stack graph adjacency matrix adjacency lists binary tree set abstract collection objects operations performed called abstract data adt stack priority dictionary important examples abstract data types modern oriented languages implementation adts means classes
science removed brute sword crowbar edward lytton leila chapter thing robert byrne master pool billiards player writer introducing framework methods algorithm analysis preceding chapter ready embark discussion algorithm design strategies chapters devoted design strategy subject chapter brute important special case exhaustive brute straightforward approach solving problem directly based problem statement definitions concepts involved implied strategy definition intellect prescription brute approach brute strategy easiest apply exponentiation problem compute nonzero nonnegative integer problem trivial vehicle illustrating algorithm design strategies brute computing mod large integers principal component leading encryption algorithm definition exponentiation times suggests simply computing multiplying times encountered brute algorithms consecutive integer checking algorithm computing gcd section definition based algorithm matrix multiplication section examples chapter algorithms based brute approach rarely source clever efficient algorithms brute proach overlooked important algorithm design strategy strategies brute applicable wide riety problems fact general approach difficult problems tackle impor tant problems sorting searching matrix multiplication string matching brute approach yields reasonable algorithms practi cal limitation instance size expense designing efficient algorithm unjustifiable instances prob lem solved brute algorithm solve instances acceptable speed fourth inefficient general brute algo rithm solving small size instances problem finally brute algorithm important theoretical educational pur pose yardstick efficient alternatives solving problem selection sort section application brute approach problem sorting orderable items numbers characters alphabet character strings rearrange nondecreasing mentioned section dozens algorithms developed solving important problem learned forget problem afresh mind unburdened previous knowledge sorting algo rithms straightforward method solving sorting problem reasonable people algorithms discussed selection sort prime candidates selection sort selection sort scanning entire smallest element exchange element putting smallest element final position sorted scan starting element smallest elements exchange element putting smallest element final position generally ith algorithm searches smallest item elements swaps amin final positions elements passes sorted pseudocode algorithm simplicity assumes implemented array algorithm selectionsort sorts array selection sort input array orderable elements output array sorted nondecreasing min swap min action algorithm illustrated figure analysis selection sort straightforward input size elements basic operation key comparison min times executed depends array size sum figure sorting selection sort line corresponds iteration algorithm tail vertical element bold smallest element elements left vertical final positions considered subsequent iterations encountered sum analyzing algorithm section compute sum distributing summation symbol immediately sum decreasing integers selection sort algorithm inputs key swaps precisely repetition loop property distinguishes selection sort positively sorting algorithms sort brute application sorting problem adjacent elements exchange repeatedly bubbling largest element position bubbles largest element passes sorted sort represented diagram final positions pseudocode algorithm bubblesort sorts array sort input array orderable elements output array sorted nondecreasing swap action algorithm illustrated figure key comparisons sort version arrays size obtained sum identical sum selection sort figure passes sort line shown swap elements vertical final positions considered subsequent iterations algorithm key swaps depends input worst case decreasing arrays key comparisons sworst case application brute strategy version algorithm obtained improved modest effort specifically crude version sort exploiting observation makes exchanges sorted algorithm problem section exercises version runs faster inputs worst average cases fact elementary sorting methods sort inferior choice catchy heard general lesson learned important repeating application brute approach results algorithm improved modest effort exercises algorithm considered appli cation brute approach problem solved brute algorithm efficiency brute algorithm computing function bits binary representation compute mod large positive integer circumvent problem large magnitude algorithms problems exercises algorithm based brute approach design brute algorithm computing polynomial anxn determine worst case efficiency class design linear algorithm designed problem design algorithm linear efficiency problem network topology specifies computers printers devices connected network figure illustrates common topologies networks ring star fully connected mesh ring star fully connected mesh boolean matrix supposed adjacency matrix graph modeling network topologies task determine topologies matrix represents design brute algorithm task efficiency class tetromino tilings tetrominoes tiles squares types tetrominoes shown straight tetromino square tetromino tile overlaps chessboard straight tetrominoes square tetrominoes stack fake coins stacks identical coins stacks counterfeit coins stacks genuine coin weighs grams fake weighs grams analytical scale determine exact weight coins devise brute algorithm stack fake coins determine worst case efficiency class minimum weighings needed stack fake coins sort alphabetical selection sort selection sort stable definition stable sorting algorithm section implement selection sort linked lists efficiency array version sort alphabetical sort prove sort makes exchanges sorted algorithm stopped write pseudocode method incorporates improvement prove worst case efficiency improved version quadratic sort stable alternating disks row disks colors dark light alternate dark light dark light dark disks light disks left moves allowed make interchange positions neighboring disks design algorithm solving puzzle determine moves takes gar sequential brute string matching previous section applications brute approach sorting porblem discuss applications strategy problem searching deals canonical problem searching item deals string matching problem sequential encountered brute algorithm general searching problem called sequential section algorithm simply compares successive elements key encountered successful exhausted finding unsuccessful simple extra employed implementing sequential append key successful eliminate altogether pseudocode enhanced version algorithm sequentialsearch implements sequential key sentinel input array elements key output index element equal element straightforward improvement incorporated sequential sorted searching stopped element greater equal key encountered sequential excellent illustration brute proach characteristic strength simplicity weakness inferior effi ciency efficiency results obtained section standard version sequential enhanced version slightly algorithm remains linear worst average cases discuss searching algorithms efficiency brute string matching recall string matching problem introduced section string characters called text string characters called pattern substring text matches pattern precisely index leftmost character matching substring text pattern matches string matching algorithm simply working entire text exhausted brute algorithm string matching problem obvious align pattern characters text matching pairs characters left pairs characters algorithm mismatching pair encountered case shift pattern position resume character comparisons starting character pattern counterpart text position text beginning matching substring provided text positions indexed position characters entire pattern algorithm make comparisons algorithm bruteforcestringmatch implements brute string matching input array characters representing text array characters representing pattern output index character text starts matching substring unsuccessful operation algorithm illustrated figure algorithm shifts pattern single character comparison worst case worse algorithm make comparisons shifting pattern problem section exercises asks specific situation worst case algorithm makes figure brute string matching pattern characters compared text counterparts bold character comparisons puts class typical word natural language text shifts comparisons average case efficiency considerably worst case efficiency searching random texts shown linear sophisticated efficient algorithms string searching widely boyer moore outlined section simplification suggested horspool exercises comparisons sentinel version sequential worst case average case probability successful shown section average key comparisons sequential sentinel standard assumptions inputs formula cavg probability successful determine fixed values formula yields maximum cavg minimum cavg gadget testing firm determine highest floor story headquarters gadget fall breaking firm identical gadgets experiment broken repaired experiment completed remaining gadget design algorithm efficiency class solve problem determine character comparisons brute algorithm searching pattern gandhi text life increasing speed assume length text characters starts comparisons successful unsuccessful brute algorithm searching patterns binary text zeros text length pattern length constitutes worst case input brute string matching algorithm character comparisons input solving string matching problem advantage comparing pattern text characters left problem counting text substrings cabaaxbya design brute algorithm problem determine effi ciency class design efficient algorithm problem gin write visualization brute string matching algorithm word popular diversion united states word puzzles player set words square table filled single letters word read horizontally left vertically degree diagonal directions formed consecutively adjacent cells table boundaries read direction zigzagging cell table words word cell write solving puzzle battleship game write based version brute pattern matching playing game battleship rules game opponents game case human player game played identical boards tables squares opponent places ships opponent player ships occupies squares board destroyer squares submarine squares cruiser squares battleship squares aircraft carrier squares ship horizontally vertically ships touching game played opponents taking turns shooting ships result shot displayed hit case hit player playing missing goal sink opponent ships opponent succeeds sink ship squares occupied ship hit closest pair convex hull problems brute section straightforward approach prob lems dealing finite set points plane problems theoretical arise important applied areas computational ometry operations research closest pair problem closest pair problem calls finding closest points set points simplest variety problems computational geometry deals proximity points plane higher dimensional spaces points represent physical objects airplanes offices database records statistical samples dna sequences air traffic controller interested closest planes probable collision candidates regional postal service manager solution closest pair problem candidate office locations closed important applications closest pair problem cluster analy sis statistics based data points hierarchical cluster analysis seeks orga nize hierarchy clusters based similarity metric numerical data metric euclidean distance text nonnumerical data metrics hamming distance problem section ercises algorithm begins element cluster merges successively larger clusters combining closest pair clusters simplicity dimensional case closest pair prob lem assume points standard fashion cartesian coordinates distance points standard euclidean distance brute approach solving problem leads vious algorithm compute distance pair distinct points pair smallest distance compute distance pair points pairs points pseudocode computes distance closest points closest points requires trivial modification algorithm bruteforceclosestpair finds distance closest points plane brute input points output distance closest pair points min sqrt square root basic operation algorithm computing square root age electronic calculators square root button led computing square root simple operation addition multiplication starters integers square roots irrational numbers approximately computing approximations trivial fact computing square roots loop avoided realize simply square root function values smaller square root smaller square root mathematicians square root function strictly increasing basic operation algorithm squaring times executed computed speeding innermost loop algorithm decrease algorithm running constant factor problem section exercises asymptotic efficiency class chapter discuss linearithmic algorithm problem based sophisticated design technique convex hull problem computing convex hull finding convex hull set points plane higher dimensional space important people important problems computational geometry prominence variety applications problem solved larger task sev eral applications based fact convex hulls convenient approximations shapes data sets imation replacing objects convex hulls speeds collision detection idea path planning mars mission rovers convex hulls computing accessibility maps produced satellite images geographic information systems detecting outliers statisti cal techniques efficient algorithm computing diameter set points largest distance points set convex hull largest distance extreme points finally convex hulls important solving optimization problems extreme points set solution candidates definition convex set definition set points finite infinite plane called convex points set entire line segment endpoints belongs set sets depicted figure convex straight line triangle rectangle generally convex polygon circle entire plane sets depicted figure finite set distinct points boundary convex polygon circumference examples sets convex ready notion convex hull intuitively convex hull set points plane smallest convex polygon boundary formulation enthusiasm problem barricading sleeping tigers shortest length interpretation harel har lively fenceposts erected spots tigers sleep tamer interpretation notion points represented nails driven large sheet plywood representing plane rubber band nails snap convex hull area bounded snapped rubber band figure formal definition convex hull applicable arbitrary sets points line definition convex hull set points smallest convex set smallest requirement means convex hull subset convex set convex hull set points convex hull line segment connecting points set triangle rectangle generally convex polygon region set points boundary shape figure convex sets convex figure rubber band interpretation convex hull points line convex hull triangle vertices points line convex hull line segment endpoints points farthest convex hull larger set figure study examples makes theorem expected result theorem convex hull set points line convex polygon vertices points line polygon degenerates line segment endpoints points figure convex hull set points convex polygon vertices convex hull problem constructing convex hull set points solve points vertices polygon mathematicians vertices polygon extreme points definition extreme convex set middle line segment endpoints set extreme points triangle vertices extreme points circle points circumference extreme points convex hull set points figure extreme points special properties points convex set exploited simplex method important algorithm discussed section algorithm solves linear programming problems finding minimum maximum linear function variables subject linear constraints problem section exercises sections general discussion interested extreme points identification solves convex hull problem solve problem completely bit points set extreme points set convex hull pairs points connected boundary convex hull issue addressed listing extreme points clockwise counterclockwise solve convex hull problem brute manner frontal dismayed convex hull problem obvious algorithmic solution simple inefficient algorithm based observation line segments making boundary convex hull line segment connecting points set points convex hull boundary points set straight line points verify property set figure repeating pair points yields line segments make convex hull boundary elementary facts analytical geometry needed implement algorithm straight line points coordinate plane defined equation line divides plane half planes points line points line simply expression points leave implementation details efficiency algorithm pairs distinct points efficient algorithms important problem discuss exercises assuming sqrt takes times longer oper ations innermost loop bruteforceclosestpoints assumed estimate faster algorithm run improvement discussed section design efficient algorithm based brute strategy solve closest pair problem points real line real numbers representing coordinates villages located straight road office built villages design efficient algorithm office location minimizing average distance villages office design efficient algorithm office location minimizing maximum distance village office sake simplicity assume points set line modification needed general case left exercises alternative ways define distance points cartesian plane manhat tan distance defined prove satisfies axioms distance function points iii sketch points cartesian plane manhattan distance origin equal euclidean distance true false solution closest pair problem metrics euclidean manhattan hamming distance strings equal length defined positions symbols named richard hamming prominent american scientist engineer introduced seminal paper error detecting error correcting codes hamming distance axioms distance metric listed problem efficiency class brute algorithm closest pair problem points strings symbols distance measured hamming distance odd pie fight people positioned field euclidean plane unique nearest neighbor person cream pie hurls pie nearest neighbor assuming odd target true false remains person hit pie car closest pair problem posed dimensional space euclidean distance points defined efficiency class brute algorithm dimensional closest pair problem convex hulls sets extreme points line segment square boundary square straight line design linear algorithm determine extreme points convex hull set points plane modification brute algorithm convex hull problem points straight line write implementing brute algorithm convex hull problem small instance linear programming problem maximize subject sketch cartesian plane problem feasible region defined set points satisfying problem constraints region extreme points solve optimization problem theorem linear programming problem nonempty bounded feasible region solution extreme points feasible region exhaustive important problems require finding element special property domain grows exponentially faster instance size typically problems arise situations involve explicitly implicitly combinatorial objects permutations combinations subsets set problems optimization problems element maximizes minimizes desired characteristic path length assignment cost exhaustive simply brute approach combinatorial prob lems suggests generating element problem domain lecting constraints finding desired element optimizes objective function idea exhaustive straightforward implementation typically requires algorithm generating combinatorial objects dis cussion algorithms chapter assume illustrate exhaustive applying important problems traveling salesman problem knapsack problem assignment problem traveling salesman problem traveling salesman problem tsp intriguing researchers years seemingly simple formulation important applications interesting connections combinatorial problems layman terms problem asks shortest set cities visits city returning city started problem conveniently modeled weighted graph vertices representing cities edge weights distances problem stated problem finding shortest hamiltonian circuit graph hamiltonian circuit defined passes vertices graph named irish mathematician sir william rowan hamilton interested cycles application algebraic discoveries easy hamiltonian circuit defined sequence adjacent vertices vin vertex sequence vertices distinct assume loss generality circuits vertex cycles tours generating permutations intermediate cities compute lengths shortest figure presents small instance problem solution method inspection figure reveals pairs tours differ direction cut vertex permutations half choose intermediate vertices permutations precedes implicitly defines direction improvement brighten efficiency picture total permutations needed makes exhaustive approach impractical small values glass half cutting half solve small instance problem investigation circuits starting vertex permutations larger factor knapsack problem algorithmics items weights values knapsack capacity valuable subset items knapsack idea putting shoes thief steal optimal figure solution small instance traveling salesman problem exhaustive valuable loot fits knapsack plane valuable set items remote location exceeding plane capacity figure presents small instance knapsack problem exhaustive approach problem leads generating subsets set items computing total weight subset feasible subsets total weight exceeding knapsack capacity finding subset largest solution instance figure subsets element set exhaustive leads algorithm efficiently individual subsets generated traveling salesman knapsack problems considered exhaustive leads algorithms extremely inefficient input fact problems examples socalled hard problems polynomial algorithm nphard problem scientists algorithms important conjecture proven sophisticated approaches backtracking bound sections enable solve instances knapsack item subset total weight total feasible figure instance knapsack problem solution exhaustive information optimal selection bold similar problems exponential alternatively approximation algorithms section assignment problem solved exhaustive people assigned execute jobs person job person assigned job assigned person cost accrue ith person assigned job quantity pair problem assignment minimum total cost small instance problem table entries representing assignment costs job person easy instance assignment problem completely cost matrix terms matrix problem select element row matrix selected elements columns total sum selected elements smallest obvious strategy finding solution works select smallest element row smallest elements column fact smallest element entire matrix component optimal solution opting exhaustive unavoidable evil feasible solutions assignment problem tuples ith component column element selected ith row job assigned ith person cost matrix assignment person job person job person job person job requirements assignment problem imply correspondence feasible assignments permutations integers exhaustive approach assignment problem require generating permutations integers computing total cost assignment summing elements cost matrix finally selecting smallest sum iterations applying algorithm instance shown figure asked exercises cost figure iterations solving small instance assignment problem exhaustive permutations considered general case assignment problem exhaustive impractical small instances problem fortunately efficient algorithm problem called hungarian method hungarian mathematicians nig egerva underlies method kol good news fact problem domain grows exponentially faster necessarily imply efficient algorithm solving fact examples problems examples exception polynomial algorithms problems domain grows exponentially instance size provided solve mentioned algorithms possibly exercises assuming generated constant efficiency class exhaustive algorithm outlined text traveling salesman problem algorithm programmed makes additions estimate maximum cities problem solved hour hours iii year century outline exhaustive algorithm hamiltonian circuit problem outline algorithm determine connected graph represented adjacency matrix eulerian circuit efficiency class algorithm application exhaustive instance assign ment problem started text assignment problem optimal solution smallest element cost matrix partition problem positive integers partition disjoint subsets sum elements prob lem solution design exhaustive algorithm problem minimize subsets algorithm generate clique problem graph positive integer deter graph clique size subgraph vertices design exhaustive algorithm problem exhaustive applied sorting problem determine efficiency class algorithm queens problem classic puzzle placing queens chessboard queens row column diagonal positions queens square queens row queens row column estimate solutions problem exhaustive based approaches capable checking positions magic squares magic square arrangement integers matrix occurring row column main diagonal sum prove magic square exists sum equal design exhaustive algorithm generating magic squares internet library algorithm generating magic squares implement algorithms exhaustive run experiment determine largest algorithms magic square minute famous alphametic puzzle digits mathematical expression sum replaced letters called cryptarithm addition puzzle words make sense alphametic published renowned british puzzlist henry dudeney money conditions assumed correspondence letters decimal digits letter represents digit dif ferent letters represent digits digit left digit numbers solve alphametic means digit letter represents solution uniqueness assumed verified solver write solving cryptarithms exhaustive assume cryptarithm sum words solve dudeney puzzle expected solved published depth breadth term exhaustive applied important algorithms systematically process vertices edges graph traversal algorithms depth dfs breadth bfs algorithms proved applications involving graphs artificial intelligence operations research addition indispensable efficient investigation fundamental properties graphs connectivity presence depth starts graph traversal arbitrary vertex marking visited iteration algorithm proceeds unvisited vertex adjacent vertices resolved arbitrarily practical adjacent unvisited candidates chosen dictated data structure representing graph examples break ties alphabetical vertices process continues dead vertex adjacent unvisited vertices encountered dead algorithm backs edge vertex visiting unvisited vertices algorithm eventually halts backing starting vertex dead vertices connected component starting vertex visited unvisited vertices depth restarted convenient stack operation depth vertex stack vertex reached figure dfs traversal graph traversal stack subscript vertex visited pushed stack dead popped stack dfs forest tree edges shown solid dashed lines vertex starts vertex stack dead vertex ends accompany depth traversal constructing called depth forest starting vertex traversal serves root tree forest unvisited vertex reached attached child vertex reached edge called tree edge set edges forms forest algorithm encounter edge leading previously visited vertex predecessor parent tree edge called edge connects vertex ancestor parent depth forest figure depth traversal stack depth forest shown pseudocode depth algorithm dfs implements depth traversal graph input graph output graph vertices marked consecutive integers encountered dfs traversal vertex unvisited vertex marked dfs visits recursively unvisited vertices connected vertex path numbers encountered global variable vertex adjacent marked dfs brevity dfs pseudocode ease formed create wrong impression sophistication algorithm true power depth algorithm action graph diagram adjacency matrix adjacency lists graph figure smaller efficient depth difficult algorithm fact efficient takes proportional size data structure representing graph adjacency matrix representation traversal adjacency representation graph vertices edges dfs forest obtained product dfs traversal deserves comments begin forest graph edges classified dfs traversal disjoint classes tree edges types dfs forest undirected graph tree edges dfs traversal previously unvisited vertices edges class forest edges vertices previously visited vertices predecessors traversal vertices ancestors forest parents dfs traversal forest representation graph pro vides proved extremely helpful development efficient gorithms checking important properties graphs dfs yields orderings vertices reached pushed stack vertices dead ends popped stack orders qualitatively applications advantage important elementary applications dfs checking connectivity checking acyclicity graph dfs halts visiting vertices discovery applications important breakthrough achieved american scientists john hopcroft robert tarjan contributions turing award prestigious prize computing field tar nected path starting vertex checking graph connectivity dfs traversal arbitrary vertex algorithm halts vertices graph visited graph connected generally dfs identifying connected components graph checking presence graph advantage graph representation dfs forest edges graph acyclic edge vertex ancestor edge figure graph comprises path sequence tree edges dfs forest edge applications dfs sophisticated applications finding articulation points graph included vertex connected graph articulation removal edges incident breaks graph disjoint pieces breadth depth traversal brave algorithm home breadth traversal cautious proceeds concentric manner visiting vertices adjacent starting vertex unvisited vertices edges vertices connected component starting vertex visited unvisited vertices algorithm restarted arbitrary vertex connected component graph convenient difference depth operation breadth initialized traversal starting vertex marked visited iteration algorithm identifies unvisited vertices adjacent vertex marks visited adds vertex removed similarly dfs traversal accompany bfs traversal constructing called breadth forest traversal starting vertex serves root tree forest unvisited vertex reached vertex attached child vertex reached edge called tree edge leading previously visited vertex predecessor parent tree encountered edge noted edge figure breadth traversal breadth forest shown figure bfs traversal graph traversal numbers indicating vertices visited added removed bfs forest tree edges shown solid dotted lines pseudocode breadth algorithm bfs implements breadth traversal graph input graph output graph vertices marked consecutive integers visited bfs traversal vertex unvisited vertex marked bfs visits unvisited vertices connected vertex path numbers visited global variable initialize vertex adjacent vertex marked vertex figure illustration bfs based algorithm finding minimum edge path graph bfs tree identifies minimum edge path breadth efficiency depth adjacency matrix representation adjacency representation depth yields single ordering vertices fifo structure vertices added removed structure bfs forest undirected graph kinds edges tree edges tree edges previously unvisited vertices edges vertices visited edges dfs tree vertices adjacent levels bfs tree bfs connectivity acyclicity graph essentially manner dfs applicable straightforward applications finding articulation points helpful situations dfs bfs finding path fewest edges vertices bfs traversal vertices vertex reached simple path root bfs tree vertex path sought path graph figure fewest edges paths vertices correctness application appears stem immediately bfs operates mathematical proof validity elementary cor section table summarizes main facts depth breadth table main facts depth dfs breadth bfs dfs bfs data structure stack vertex orderings ordering edge types undirected graphs tree edges tree edges applications connectivity acyclicity articulation points minimum edge paths efficiency adjacency matrix efficiency adjacency lists exercises graph write adjacency matrix adjacency lists graph assume matrix rows columns vertices adjacency lists alphabetical vertex labels starting vertex resolving ties vertex alphabetical traverse graph depth construct depth tree vertices reached pushed traversal stack vertices dead ends popped stack define sparse graphs implemen tation dfs efficiency graphs adjacency matrix adjacency lists graph vertices edges true false dfs forests traversals starting ver tices trees true false dfs forests tree edges traverse graph problem breadth construct breadth tree traversal vertex resolve ties vertex alphabetical prove edge bfs tree undirected graph vertices adjacent levels bfs tree graph acyclicity breadth traversals dfs bfs faster case examples supporting connected components graph depth breadth graph bipartite vertices partitioned disjoint subsets edge connects vertex graph bipartite vertices colored colors edge vertices colored colors graphs called colorable graph bipartite graph design dfs based algorithm checking graph bipartite design bfs based algorithm checking graph bipartite write graph outputs vertices connected component message graph acyclic model maze vertex starting finishing dead ends points maze path connecting vertices paths maze construct graph maze traversal dfs bfs maze jugs sime denis poisson famous french mathemati cian physicist interested mathematics encountering version puzzle pint jug jugs pint capacity pints jugs completely filling emptying jugs solve puzzle breadth summary brute straightforward approach solving problem directly based problem statement definitions concepts involved principal strengths brute approach wide applicability simplicity principal weakness subpar efficiency brute algorithms application brute approach results algorithm improved modest effort noted algorithms considered examples brute approach definition based algorithm matrix multiplication selection sort sequential straightforward string matching algorithm exhaustive brute approach combinatorial problems suggests generating combinatorial problem selecting constraints finding desired traveling salesman problem knapsack problem assignment problem typical examples problems solved theoretically exhaustive algorithms exhaustive impractical small instances problems applied depth dfs breadth bfs principal graph traversal algorithms representing graph depth breadth forest investigation important properties graph algorithms efficiency adjacency matrix representation adjacency representation
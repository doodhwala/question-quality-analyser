greed lack word good greed works michael douglas actor role gordon gecko wall street revisit making problem faced subconsciously millions cashiers world specific coins denominations locale section assume denominations ordered decreasing widely coin denominations united states quarter dime nickel penny coins denominations cents quarter dimes pennies consciously logical strategy making sequence choices alternatives coin denominations greedy thinking leads giving quarter reduces remaining cents coins disposal quarter violated problem constraints selection dime reducing remaining cents giving dime left cents pennies solution instance making problem optimal fact prove greedy algorithm yields optimal solution positive integer coin denominations easy coin denominations yield optimal solution amounts approach applied opening paragraph making prob lem called greedy scientists general design technique fact applicable optimization problems greedy approach suggests constructing solution sequence steps panding partially constructed solution obtained solution problem reached central technique choice feasible problem constraints locally optimal local choice feasible choices irrevocable changed subsequent steps algorithm requirements technique suggests greedy alternative sequence locally optimal choices yield globally optimal solution entire problem refrain philosophical discussion greed good bad movie chapter epigraph hero algorithmic perspective greedy strategy works problems sequence locally optimal choices yield optimal solution instance problem case problems greedy algorithm interested satisfied approximate solution sections chapter discuss classic algorithms minimum spanning tree problem prim algorithm kruskal algorithm remarkable algorithms fact solve problem applying greedy approach ways yield optimal solution section classic algorithm dijkstra algorithm shortest path problem weighted graph section devoted huffman trees principal application huffman codes important data compression method interpreted application greedy technique finally examples approximation algorithms based greedy approach discussed section greedy algorithms intuitively appealing simple optimization problem easy figure proceed greedy manner possibly small instances problem difficult prove greedy algorithm yields optimal solution common ways illustrated proof section mathematical induction partially constructed solution obtained greedy algorithm iteration extended optimal solution problem prove optimality greedy algorithm advancing problem goal problem minimum moves needed chess knight corner board diagonally corner knight moves shaped jumps squares horizontally vertically square perpendicular direction greedy solution goal finish squares sequence moves solves problem advances obtained equation minimum solution distance goal manhattan distance sum difference row numbers difference column numbers squares greedy algorithm decreases knight simply final result obtained greedy algorithm optimal based algorithm output operates problem placing maximum chips board chips adjacent vertically horizontally diagonally squares prescription greedy strategy chip leave squares chips starting upper left corner board chips shown figure solution optimal partition board squares shown figure impossible chip squares implies total nonadjacent chips board exceed final comment mention sophisticated theory developed greedy technique based abstract combinatorial structure called matroid interested reader books cor variety internet resources subject figure placement chips adjacent squares partition board proving impossibility placing chips graph figure graph spanning trees minimum spanning tree prim algorithm problem arises naturally practical situations points cheapest path ery pair points direct applications design kinds networks communication transportation electrical providing cheapest achieve connectivity identifies clusters points data sets classification purposes archeology biology sociology sciences helpful constructing approximate solutions difficult problems traveling salesman problem section represent points vertices graph connections graph edges connection costs edge weights posed minimum spanning tree problem defined formally definition spanning tree undirected connected graph connected acyclic subgraph tree vertices graph weights assigned edges minimum spanning tree spanning tree smallest weight tree defined sum weights edges minimum spanning tree problem finding minimum spanning tree weighted connected graph figure presents simple illustrating notions constructing minimum spanning tree exhaustive obstacles spanning trees grows exponentially graph size dense graphs generating spanning trees graph easy fact difficult finding minimum spanning tree weighted graph efficient algorithms problem section outline prim algorithm pri robert prim rediscovered algorithm published years earlier czech mathematician vojte jarni czech journal prim algorithm constructs minimum spanning tree sequence expanding subtrees initial subtree sequence consists single vertex selected arbitrarily set graph vertices iteration algorithm expands current tree greedy manner simply attaching nearest vertex tree nearest vertex tree connected vertex tree edge smallest weight ties broken arbitrarily algorithm stops graph vertices included tree constructed algorithm expands tree vertex iterations total iterations vertices graph tree generated algorithm obtained set edges tree expansions pseudocode algorithm prim algorithm constructing minimum spanning tree input weighted connected graph output set edges composing minimum spanning tree set tree vertices initialized vertex minimum weight edge edges nature prim algorithm makes vertex current tree information shortest edge connecting vertex tree vertex information attaching labels vertex nearest tree vertex length weight edge vertices adjacent tree vertices indicating infinite distance tree vertices null nearest tree vertex alternatively split vertices tree sets fringe unseen fringe vertices tree adjacent tree vertex candidates tree vertex selected unseen vertices graph called unseen affected algorithm labels finding vertex added current tree simple task finding vertex smallest distance set ties broken arbitrarily identified vertex added tree operations set tree vertices remaining vertex connected shorter edge current distance update labels weight edge figure demonstrates application prim algorithm specific graph prim algorithm yield minimum spanning tree prove induction subtrees generated prim algorithm subgraph minimum spanning tree immediately implies tree sequence minimum spanning tree vertices graph basis induction trivial consists single vertex minimum spanning tree inductive assume minimum spanning tree prove generated prim algorithm minimum spanning tree prove contradiction assuming minimum spanning tree graph minimum weight edge vertex prim algorithm assumption minimum spanning tree formed figure addition edge connecting vertex coincides delete edge spanning tree entire graph weight equal weight equal weight spanning tree minimum spanning tree contradicts assumption minimum spanning tree completes correctness proof prim algorithm efficient prim algorithm depends data structures chosen graph priority set vertex priorities distances nearest tree vertices figure set operates priority graph represented weight matrix priority implemented unordered array algorithm running iterations array implementing priority traversed delete minimum update priorities remaining vertices implement priority min mirror image structure discussed section fact plemented constructing negating key values min binary tree element equal implementation fringe unseen split pursued unseen vertices adjacent moved fringe tree vertices remaining vertices illustration figure application prim algorithm parenthesized labels vertex middle column nearest tree vertex edge weight selected vertices edges shown bold figure correctness proof prim algorithm children principal properties heaps valid min heaps obvious modifications root min smallest largest element deletion smallest element insertion element min size log operations operation changing element priority problem section exercises graph represented adjacency lists priority plemented min running algorithm log algorithm performs deletions smallest element makes verifications possibly element priority min size exceeding operations noted earlier log operation running implementation prim algorithm log connected graph section greedy algorithm minimum spanning tree problem greedy manner prim algorithm exercises write pseudocode greedy algorithm making problem coin denominations input efficiency class algorithm design greedy algorithm assignment problem section greedy algorithm yield optimal solution job scheduling problem scheduling jobs dura tions execution single processor jobs executed job schedule minimizes total spent jobs spent job sum spent job waiting spent execution design greedy algorithm problem greedy algorithm yield optimal solution compatible intervals real line representing times activity requiring resource task largest intervals overlap investigate greedy algorithms based earliest shortest duration earliest finish algorithms prove algorithm yields optimal solution counterexample showing case bridge crossing revisited generalization bridge crossing puzzle problem exercises people bridge crossing times conditions problem people bridge speed slower flashlight group design greedy algorithm problem bridge algorithm yield minimum crossing instance problem prove instance smallest people averaging identical vessels pints allowed operation vessels split total equally achieve minimum vessel initial set sequence operations rumor spreading people possession rumor rumors sending electronic messages assume sender includes rumors message addressee design greedy algorithm yields minimum messages send rumors bachet problem weights optimal set weights scale integer largest range provided weights free cup scale weights cups scale apply prim algorithm graph priority vertices tree apply prim algorithm graph priority fringe vertices current tree adjacent tree vertex notion minimum spanning tree applicable connected weighted graph connectivity applying prim algorithm prim algorithm correctly graphs negative edge weights minimum spanning tree graph obtained prim algorithm gnew graph obtained adding vertex edges weights connecting vertex vertices struct minimum spanning tree gnew adding edges prim algorithm spanning tree connected graph weights edges good algorithm problem prove weighted connected graph distinct weights minimum spanning tree outline efficient algorithm changing element min efficiency algorithm kruskal algorithm previous section considered greedy algorithm grows mini mum spanning tree greedy inclusion nearest vertex vertices tree remarkably greedy algorithm mini mum spanning tree problem yields optimal solution named kruskal algorithm joseph kruskal discovered algorithm year graduate student kru kruskal algorithm minimum spanning tree weighted connected graph acyclic subgraph edges sum edge weights smallest difficult prove subgraph tree algorithm constructs minimum spanning tree expanding sequence subgraphs acyclic necessarily connected inter mediate stages algorithm begins sorting graph edges nondecreasing weights starting subgraph scans sorted adding edge current subgraph inclusion create simply skipping edge algorithm kruskal algorithm constructing minimum spanning tree input weighted connected graph output set edges composing minimum spanning tree sort nondecreasing edge weights ecounter initialize set tree edges size initialize processed edges ecounter eik acyclic eik ecounter correctness kruskal algorithm proved repeating essen tial steps proof prim algorithm previous section fact tree prim algorithm generally acyclic subgraph kruskal algorithm turns obstacle overcome figure demonstrates application kruskal algorithm graph illustrating prim algorithm section algorithm operations disconnectedness intermediate subgraphs applying prim kruskal algorithms small graph create impression simpler impres sion wrong iterations kruskal algorithm addition edge edges selected create tree edges sorted edges illustration figure application kruskal algorithm selected edges shown bold figure edge connecting vertices create difficult created edge connects vertices connected path vertices connected component figure connected component subgraph generated kruskal algorithm tree cycles view observations convenient slightly interpretation kruskal algorithm operations progression series forests vertices graph edges initial forest consists trivial trees comprising single vertex graph final forest consists single tree minimum spanning tree graph iteration algorithm takes edge sorted graph edges finds trees vertices trees unites larger tree adding edge fortunately efficient algorithms crucial vertices tree called unionfind algorithms discuss subsection efficient union algorithm running kruskal algorithm dominated needed sorting edge weights graph efficient sorting algorithm efficiency kruskal algorithm log disjoint subsets union algorithms kruskal algorithm applications require dynamic partition element set collection disjoint subsets initialized collection element subsets element collection subjected sequence intermixed union operations union operations sequence bounded union increases subset size elements entire set dealing abstract data collection disjoint subsets finite set operations makeset creates element set assumed operation applied elements set returns subset union constructs union disjoint subsets adds collection deleted makeset creates set applying operation times initializes structure collection singleton sets performing union yields union disjoint subsets implementations abstract data element disjoint subsets collection subset representative implemen tations impose specific constraints representative requiring smallest element subset representative assumed set elements mapped integers principal alternatives implementing data structure called quick optimizes efficiency operation called quick union optimizes union operation quick array indexed elements underlying set array values representatives subsets elements subset implemented linked header pointers elements figure scheme implementation makeset requires assigning element representative array initializing corre sponding linked single node efficiency operation initialization singleton subsets efficiency retrieve representative array executing union takes longer straightforward solution simply append update information representative elements subset representatives element index representative size null figure linked representation subsets obtained quick performing union lists size considered deleted collection delete collection easy verify algorithm sequence union operations union runs compared alternatives simple efficiency sequence union operations append shorter lists longer ties broken arbitrarily size assumed storing elements header modification called figure forest representation subsets quick union result union size worst case efficiency single plication union operation worst case running legitimate sequence union size operations turns log proof assertion element set disjoint subsets manipulate times representative updated sequence union size operations large set elements representative updated smaller subset involved computing union size large size subset representative updated resulting set elements updated resulting set elements general updated times resulting set elements entire set elements log total updates representatives elements exceed log union size efficiency sequence unions finds log quick union principal alternative implementing disjoint subsets represents subset rooted tree nodes tree subset elements node root element considered subset representative tree edges directed children parents figure addition mapping set elements tree nodes implemented array pointers maintained mapping shown figure sake simplicity implementation makeset requires creation single node tree operation initialization singleton subsets union implemented attaching root tree root tree deleting tree collection making pointer root null efficiency operation specific usefulness amortized efficiency mentioned chapter figure path compression performed pointer chain node tree root element returned subset representative efficiency single operation tree representing subset degenerate linked nodes bound improved straightforward union operation attaching smaller tree root larger ties broken arbitrarily size tree measured nodes version called union size height version called union rank options require storing node tree node descendants height subtree rooted node easily prove case height tree logarithmic making execute log quick union efficiency sequence unions finds log fact efficiency obtained combining variety quick union path compression modification makes node encountered execution operation tree root figure sophisticated analysis tar similar techniques efficiency sequence unions finds slightly worse linear exercises apply kruskal algorithm minimum spanning tree graphs statements true false minimum weight edge connected weighted graph edges minimum spanning tree graph minimum weight edge connected weighted graph edges minimum spanning tree graph edge weights connected weighted graph distinct graph minimum spanning tree edge weights connected weighted graph distinct graph minimum spanning tree algorithm kruskal make minimum spanning forest arbitrary graph minimum spanning forest trees minimum spanning trees graph connected components kruskal algorithm correctly graphs negative edge weights design algorithm finding maximum spanning tree spanning tree largest edge weight weighted connected graph rewrite pseudocode kruskal algorithm terms operations disjoint subsets adt prove correctness kruskal algorithm prove efficiency log union size version quick union web sites animations kruskal prim algorithms discuss merits demerits design conduct experiment empirically efficiencies prim kruskal algorithms random graphs sizes densities steiner tree villages located vertices unit square euclidean plane asked shortest network roads path pair villages roads network write generating random maze based prim algorithm kruskal algorithm dijkstra algorithm section single source shortest paths problem vertex called source weighted connected graph shortest paths vertices important stress interested single shortest path starts source visits vertices difficult problem version traveling salesman problem introduced section discussed single source shortest paths problem asks family paths leading source vertex graph paths edges common variety practical applications shortest paths problem popular study obvious widely applications transportation planning packet routing communi cation networks internet multitudes obvious applications finding shortest paths social networks speech recognition document formatting robotics compilers airline crew scheduling world tainment mention pathfinding video games finding solutions puzzles state space graphs section simple algorithms finding shortest paths floyd algorithm general pairs shortest paths problem discussed chapter algorithm single source shortest paths problem called dijkstra algorithm applicable undirected directed graphs nonnegative weights plications condition satisfied limitation impaired popularity dijkstra algorithm dijkstra algorithm finds shortest paths graph vertices distance source finds shortest path source edsger dijkstra noted dutch pioneer science industry computing discovered algorithm mid dijkstra algorithm graph problem posed solved amazing thing publish amazing algorithms considered scientific topic figure idea dijkstra algorithm subtree shortest paths shown bold nearest source vertex selected comparing lengths subtree paths increased distances vertices adjacent subtree vertices vertex nearest general ith iteration commences algorithm identified shortest paths vertices nearest source vertices source edges shortest paths leading source subtree graph figure edge weights nonnegative vertex nearest source vertices adjacent vertices set vertices adjacent vertices referred fringe vertices candidates dijkstra algorithm selects vertex nearest source vertices treated fringe vertices connected tree vertices edges infinitely large weights ith nearest vertex algorithm computes fringe vertex sum distance nearest tree vertex weight edge length shortest path source previously determined algorithm selects vertex smallest sum fact suffices lengths special paths central insight dijkstra algorithm facilitate algorithm operations vertex labels numeric length shortest path source vertex algorithm vertex added tree length shortest path source vertex path parent vertex tree constructed left unspecified source vertices adjacent current tree vertices labeling finding nearest vertex simple task finding fringe vertex smallest ties broken arbitrarily identified vertex added tree operations fringe set tree vertices remaining fringe vertex connected edge weight update labels figure demonstrates application dijkstra algorithm specific graph labeling mechanics dijkstra algorithm similar prim algorithm section construct expanding subtree vertices selecting vertex priority remaining vertices important solve problems operate priorities computed manner dijkstra algorithm compares path lengths edge weights prim algorithm compares edge weights pseudocode dijkstra algorithm spelled prim algorithm section terms explicit operations sets labeled vertices set vertices shortest path priority fringe vertices pseudocode source vertex fringe vertices adjacent iteration completed algorithm dijkstra algorithm single source shortest paths input weighted connected graph nonnegative weights vertex output length shortest path penultimate vertex initialize priority vertex null insert initialize vertex priority decrease update priority deletemin delete minimum priority element vertex adjacent decrease efficiency dijkstra algorithm depends data structures implementing priority representing input graph reasons explained analysis prim algorithm section tree vertices remaining vertices illustration shortest paths identified nonnumeric labels backward destination vertex left column source lengths numeric labels tree vertices length figure application dijkstra algorithm closest vertex shown bold graphs represented weight matrix priority implemented unordered array graphs represented adjacency lists priority implemented min log upper bound achieved prim dijkstra algorithms priority implemented sophisticated data structure called fibonacci cor complexity considerable overhead make improvement primarily theoretical exercises adjustments dijkstra algorithm underlying graph solve problems solve single source shortest paths problem directed weighted graphs shortest path vertices weighted graph digraph variation called single pair shortest path problem shortest paths vertex weighted graph digraph variation called single destination shortest paths problem solve single source shortest paths problem graph nonnegative numbers assigned vertices length path defined sum vertex numbers path solve instances single source shortest paths problem vertex source counterexample shows dijkstra algorithm weighted connected graph negative weights tree constructed dijkstra algorithm process solving single source shortest paths problem weighted connected graph true false spanning tree true false minimum spanning tree write pseudocode simpler version dijkstra algorithm finds distances lengths shortest paths shortest paths vertex vertices graph represented weight matrix prove correctness dijkstra algorithm graphs positive weights design linear algorithm solving single source shortest paths problem dags directed acyclic graphs represented adjacency lists minimum sum descent problem exercises solved dijkstra algorithm shortest path modeling assume model weighted connected graph balls representing vertices connected strings appro priate lengths representing edges solve single pair shortest path problem model solve single source shortest paths problem model revisit section determining route subway passenger designated station developed subway washington london write task huffman trees codes encode text comprises symbols symbol alphabet assigning text symbols sequence bits called codeword fixed length encoding assigns symbol bit string length log standard ascii code coding scheme yields shorter bit string average based idea assigning shorter code words frequent symbols longer codewords frequent symbols idea telegraph code invented mid century samuel morse code frequent letters assigned short sequences dots dashes infrequent letters longer variable length encoding assigns codewords lengths symbols introduces problem fixed length encoding bits encoded text represent generally ith symbol complication limit called prefix free simply prefix codes prefix code codeword prefix codeword symbol encoding simply scan bit string group bits codeword symbol bits symbol operation bit string reached create binary prefix code alphabet natural associate alphabet symbols leaves binary tree left edges labeled edges labeled codeword symbol obtained recording labels simple path root symbol leaf simple path leaf continues leaf codeword prefix codeword tree yields prefix code trees constructed manner alphabet frequencies symbol occurrences construct tree assign shorter bit strings high frequency symbols longer low frequency symbols greedy algorithm invented david huffman graduate student mit huf huffman algorithm initialize node trees symbols alphabet frequency symbol tree root tree weight generally weight tree equal sum frequencies tree leaves operation single tree obtained trees smallest weight ties broken arbitrarily problem section exercises make left subtree tree sum weights root tree weight tree constructed algorithm called huffman tree defines manner huffman code symbol alphabet occurrence frequencies text symbols symbol frequency huffman tree construction input shown figure constructing huffman coding tree resulting codewords symbol frequency codeword dad encoded decoded bad occurrence frequencies codeword lengths obtained average bits symbol code fixed length encoding alphabet bits symbol toy huffman code achieves compression ratio standard compression algorithm effectiveness words huffman encoding text memory fixed length encoding extensive experiments huffman codes shown compression ratio scheme typically falls depending characteristics text compressed huffman encoding important compression methods addition simplicity versatility yields optimal minimal length encoding provided frequencies symbol occurrences independent advance simplest version huffman compression calls fact preliminary scanning text frequencies symbol occurrences frequencies construct huffman coding tree encode text scheme makes coding table encoded text make decoding drawback overcome dynamic huffman encoding coding tree updated symbol read source text modern alternatives lempel ziv algorithms assign codewords individual symbols strings symbols allowing achieve robust compressions applications important applications huffman algorithm data compression positive numbers assigned leaves binary tree node define weighted path length sum length simple path root ith leaf construct binary tree minimum weighted path length general problem huffman algorithm solves coding application length codeword frequency ith symbol problem arises situations involving decision making game guessing chosen possibilities integer questions answerable strategies playing game modeled decision trees depicted figure length simple path root leaf tree equal questions needed chosen represented leaf chosen probability sum decision trees discussed section figure decision trees guessing integer length path root ith leaf average questions needed chosen game strategy represented decision tree numbers chosen probability strategy successively eliminate half candidates binary case arbitrary minimum weighted path tree rightmost figure huffman algorithm solve problem general case encountering problem structing optimal binary tree section discussed problem constructing optimal binary tree positive numbers prob abilities assigned node tree section numbers assigned leaves problem turns easier solved greedy algorithm solved complicated dynamic programming algorithm exercises construct huffman code data symbol frequency encode abacabad code decode code data transmission purposes desirable code minimum variance codeword lengths codes average length compute average variance codeword length huffman codes result breaking huffman code construction data symbol probability properties true huffman code codewords frequent symbols length codeword length frequent symbol smaller equal codeword length frequent maximal length codeword huffman encoding alphabet symbols write pseudocode huffman tree construction algorithm efficiency class algorithm constructing huff tree function alphabet size huffman tree constructed linear alphabet symbols sorted frequencies huffman coding tree algorithm codewords symbols efficiency class function alphabet size generate huffman code explicit generation huffman coding tree write constructs huffman code english text encode write decoding english text encoded huffman code experiment encoding range typical compres sion ratios huffman encoding english texts words experiment encoding sensitive compression ratios standard estimates frequencies actual frequencies symbol occurrences english texts card guessing design strategy minimizes expected questions asked game gar deck cards consists ace spades deuces spades threes nines making cards draws card shuffled deck questions answerable summary greedy technique suggests constructing solution optimization problem sequence steps expanding partially constructed solution obtained solution problem reached choice feasible locally optimal irrevocable prim algorithm greedy algorithm constructing minimum spanning tree weighted connected graph works attaching previously constructed subtree vertex closest vertices tree kruskal algorithm greedy algorithm minimum spanning tree problem constructs minimum spanning tree selecting edges nondecreasing weights provided inclusion create checking condition efficiently requires application called union algorithms dijkstra algorithm solves single source shortest path problem finding shortest paths vertex source vertices weighted graph digraph works prim algorithm compares path lengths edge lengths dijkstra algorithm yields solution graph nonnegative weights huffman tree binary tree minimizes weighted path length root leaves predefined weights important application huffman trees huffman codes huffman code optimal prefix free variable length encoding scheme assigns bit strings symbols based frequencies text accomplished greedy construction binary tree leaves represent alphabet symbols edges labeled
intellect distinguishes impossible reason distinguishes senseless max born life views preceding chapters encountered dozens algorithms solving variety problems fair assessment algorithms problem solving tools inescapable powerful instruments executed modern computers power algorithms unlimited limits subject chapter problems solved algorithm problems solved algorithmically polynomial problem solved polynomial algorithms lower bounds efficiency section methods obtaining lower bounds estimates minimum needed solve problem general obtaining nontrivial lower bound simple sounding problem difficult task opposed ascertaining efficiency algorithm task establish limit efficiency algorithm unknown necessitates careful description operations algorithms allowed define carefully rules game speak claims large dustbin impossibility related statements celebrated british physicist lord kelvin heavier air flying machines impossible section discusses decision trees technique applications establish lower bounds efficiency comparison based algorithms sorting searching sorted arrays result questions faster sorting algorithm mergesort binary fastest algorithm searching sorted array intuition answers questions incidentally decision trees great vehicle directing solution puzzles coin weighing problem discussed section deals intractability problems solved polynomial developed area theoretical science called computational complexity theory basic elements theory discuss informally fundamental notions problems important unresolved theoretical science relationship problems section chapter deals numerical analysis science concerns algorithms solving problems continuous mathematics solving equations systems equations evaluating func tions computing integrals nature problems imposes types limitations solved solving approximately requires dealing numbers rep resented digital precision manipulating approximate numbers proper lead inaccurate results solving basic quadratic equation poses sig nificant difficulties require modification canonical formula equation roots lower bound arguments efficiency algorithm ways establish asymp totic efficiency class worst case class stands respect hierarchy efficiency classes outlined section exam ple selection sort efficiency quadratic fast algorithm tower hanoi problem ficiency exponential comparison akin proverbial comparison apples oranges algorithms solve problems alternative possibly fairer approach efficient algorithm respect algorithms problem light selection sort considered log sorting algorithms tower hanoi algorithm turns fastest problem solves ascertain efficiency algorithm respect algorithms problem desirable efficiency algorithm solving problem knowing lower bound improvement achieve quest algorithm problem bound tight algorithm efficiency class lower bound constant factor improvement gap efficiency fastest algorithm lower bound door improvement remains faster algorithm matching lower bound lower bound proved section methods establishing lower bounds illustrate specific examples analyzing efficiency specific algorithms preceding chapters distinguish lower bound class minimum times operation executed problem difficult immediately conclude algorithm finding median numbers simple prove comparison based algorithm problem comparisons worst case odd trivial lower bounds simplest method obtaining lower bound class based counting items problem input processed output items produced algorithm read items process write outputs yields trivial lower bound algorithm generating permutations distinct items size output bound tight good algorithms generating permutations spend constant initial section problem evaluating polynomial degree anxn coefficients easy coefficients processed polynomial evaluation algorithm case unprocessed coefficient polynomial nonzero means algorithm lower bound tight left evaluation algorithm problem exercises horner section linear similar vein trivial lower bound computing product matrices algorithm process elements input matrices generate elements product unknown bound tight trivial lower bounds low trivial bound traveling salesman problem input intercity distances output cities making optimal bound useless algorithm running polynomial function degree obstacle deriving meaningful lower bound method lies determining input processed algorithm solving problem searching element sorted array require processing elements problem determining connectivity undirected graph defined adjacency matrix plausible algorithm existence potential edges proof fact trivial information theoretic arguments approach outlined takes account size problem output information theoretical approach seeks establish lower bound based information game deducing positive integer selected person questions answers uncertainty algorithm solving problem resolve measured log bits needed possibilities accurate yielding bit information algorithm output selected algorithm log steps determine output worst case approach exploited called information theoretic argument connection information theory proved finding called information theoretic lower bounds problems involving comparisons sorting searching underlying idea realized precisely mechanism decision trees importance technique discuss separately section adversary arguments revisit game guessing idea information theoretic argument prove algorithm solves problem log questions worst case playing role hostile adversary make algorithm questions adversary starts numbers potentially selected cheating game concerned prove assertion adversary leaves largest set numbers consistent previously answers strategy leaves half numbers algorithm stops size set reduced adversary exhibit legitimate input algorithm failed simple technical log iterations shrink element set element set halving rounding size remaining set log questions asked algorithm worst case illustrates adversary method establishing lower bounds based logic malevolent honest adversary malevolence makes algorithm consuming path honesty forces consistent choices lower bound obtained measuring needed shrink set potential inputs single input consuming path problem merging sorted lists size single sorted size simplicity assume distinct problem unique solution encountered problem discussing mergesort section recall merging repeatedly comparing elements remaining lists outputting smaller key comparisons worst case algorithm merging algorithm merging faster turns knuth knuiii quotes adversary method proving lower bound key comparisons comparison based algorithm problem adversary true comparison merging algorithm combined consistent combined algorithm explicitly adjacent pairs elements comparisons compared transpose keys consistent comparisons distinguished configuration lower bound key comparisons needed merging algorithm problem reduction encountered problem reduction approach section discussed algorithm problem reducing problem solvable algorithm similar reduction idea finding lower bound problem hard problem lower bound words arbitrary instance problem transformed efficient fashion instance problem algorithm solving solve lower bound lower bound table lists important problems purpose table problems establishing lower bounds problem reduction problem lower bound tightness sorting log searching sorted array log element uniqueness problem log multiplication digit integers unknown multiplication matrices unknown establish lower bounds sorting searching sec tion element uniqueness problem asks duplicates numbers encountered problem sections proof lower bound seemingly simple problem based sophisti cated mathematical analysis scope pre elementary exposition algebraic prob lems table lower bounds quoted trivial improved remains unknown establishing lower bound reduction euclidean minimum spanning tree problem points cartesian plane construct tree minimum total length vertices points problem lower bound element uniqueness problem transform set real numbers set points cartesian plane simply adding points coordinate minimum spanning tree set points shortest edge checking length edge uniqueness numbers reduction implies log lower bound euclidean minimum spanning tree problem final results complexity problems reduction technique relative complexity prob lems formulas problems computing product digit integers squaring digit integer complexity class seemingly simpler similar results matrix operations multi plying symmetric matrices turns complexity class multiplying arbitrary square matrices result based observation problem special case problem multiplying arbitrary square matrices problem multiplying symmetric matrices transpose matrices stands matrix elements zeros needed product easily extracted true matrices original size minor technical complication impact complexity classes results interesting encounter important applications reduction approach comparing problem complexity section exercises prove algorithm solving alternating disk puzzle problem exercises make moves solve lower bound tight prove classic recursive algorithm tower hanoi puzzle section makes minimum disk moves needed solve problem trivial lower bound class problems indi cate bound tight finding largest element array checking completeness graph represented adjacency matrix generating subsets element set determining real numbers distinct problem identifying lighter fake coin identical coins scale information theoretic argument text ques tions guessing game conclude algorithm identifying fake log weighings worst case prove comparison based algorithm finding largest element set real numbers make comparisons worst case tight lower bound sorting array exchanging adjacent elements adversary argument proof efficiency algorithm checks connectivity graph vertices provided operation allowed algorithm inquire presence edge vertices graph lower bound tight minimum comparisons needed comparison based sorting algorithm merge sorted lists sizes elements prove validity product matrices transformation product symmetric matrices section formulas complexity equiva lence multiplication squaring integers complexity equivalence multiplication squaring square matrices multiplication matrices reduced squaring matrix tight lower bound class problem finding closest numbers real numbers tight lower bound class placement problem exercises decision trees important algorithms sorting searching comparing items inputs study performance algorithms device called decision tree figure presents decision tree algorithm finding minimum numbers internal node binary decision tree represents key comparison node left subtree information subsequent comparisons subtree case sake simplicity assume section input items distinct leaf represents outcome algorithm run input size leaves greater outcomes algorithms outcome arrived chain comparisons case decision tree figure important leaves large outcomes algorithm input size traced path root leaf decision tree comparisons algorithm figure decision tree finding minimum numbers run equal length path comparisons worst case equal height algorithm decision tree central idea model lies observation tree leaves dictated outcomes tall leaves specifically difficult prove binary tree leaves height log binary tree height largest leaves largest leaves tree words immediately implies inequality puts lower bound heights binary decision trees worst case comparisons comparison based algorithm problem bound called informationtheoretic lower bound section illustrate technique important problems sorting searching sorted array decision trees sorting algorithms comparison based comparing elements sorted studying properties decision trees algorithms derive important lower bounds efficiencies interpret outcome sorting algorithm finding permutation element indices input puts elements ascending element orderable items real numbers strings outcome obtained sorting figure permutation general outcomes sorting arbitrary element equal abc cba bac cba figure decision tree element selection sort triple node state array sorted redundant comparisons single outcome results previously comparisons inequality implies height binary decision tree comparison based sorting algorithm worst case parisons algorithm log cworst log stirling formula log words log comparisons worst case sort arbitrary element comparison based sorting algorithm mergesort makes comparisons worst case asymptotically optimal implies asymptotic lower bound log tight substantially improved lower bound log improved values log proved comparisons sufficient sort array elements worst case decision trees analyzing average case efficiencies comparison based sorting algorithms compute average comparisons algorithm average depth decision tree leaves average path length root leaves abc bac acb bca figure decision tree element insertion sort element insertion sort decision tree figure standard assumption outcomes sorting equally lower bound average comparisons cavg comparison based algorithm sorting element proved cavg log earlier lower bound log surprised lower bounds average worst cases identical bounds obtained maximizing compar isons average worst cases sorting algorithm average case efficiency significantly worst case efficiency decision trees searching sorted array section decision trees establishing lower bounds key comparisons searching sorted array keys principal algorithm problem binary section comparisons binary worst case cwbsorst formula cwbsorst log figure ternary decision tree binary element array decision trees determine smallest comparisons dealing comparisons key compared element natural ternary decision trees figure presents tree case internal nodes tree array elements compared key leaves matching element case successful interval key belongs case unsuccessful represent algorithm searching sorted array comparisons ternary decision tree similar figure array elements decision trees leaves successful searches unsuccessful minimum height ternary tree leaves log lower bound worst case comparisons cworst log lower bound smaller log worst case comparisons binary large values smaller equal log positive integer problem section exercises prove lower bound binary optimal turns lower bound binary ternary decision trees figure internal nodes tree correspond comparisons terminal nodes successful searches leaves represent unsuccessful searches searching element array figure binary decision tree binary element array comparison decision trees figures illustrates binary decision tree simply ternary decision tree middle subtrees eliminated applying inequality binary decision trees immediately yields cworst log inequality closes gap lower bound worstcase comparisons binary log sophisticated analysis knuiii section shows standard assumptions searches binary makes smallest comparisons average comparisons algorithm turns log successful unsuccessful searches exercises prove mathematical induction log binary tree height leaves log ternary tree height leaves problem finding median element set orderable items information theoretic lower bound comparison based gorithms solving problem draw decision tree algorithm solving problem worst case comparisons algorithm greater information theoretic lower bound algorithm matching lower bound exists algorithm prove impossibility draw decision tree key comparisons worst average cases element basic sort element enhanced sort stops swaps design comparison based algorithm sorting element array smallest element comparisons design comparison based algorithm sorting element array comparisons worst case draw binary decision tree searching element sorted sequen tial lower bounds searching sorted array log positive integer log positive integer information theoretic lower bound finding maximum numbers comparison based algorithms bound tight tournament tree binary tree reflecting results knockout tournament leaves represent players entering tournament internal node represents winner played players represented node children winner tournament represented root tree total games played tournament rounds tournament design efficient algorithm determine player information produced tournament extra games algorithm require advanced fake coin problem coins identical appearance genuine fake unknown fake coin lighter heavier genuine scale sets coins tipping left staying scale sets heavier problem coins genuine fake coin establish lighter heavier genuine prove algorithm problem make log weighings worst case draw decision tree algorithm solves problem coins weighings prove exists algorithm solves problem coins weighings draw decision tree algorithm solves problem coins weighings extra coin genuine draw decision tree algorithm solves classic version problem coins weighings extra coins jigsaw puzzle jigsaw puzzle pieces section puzzle set pieces connected consists connecting sections algorithm minimize moves required puzzle problems study computational complexity problems scientists computing professionals problem solved polynomial algorithm definition algorithm solves problem polynomial worst case efficiency belongs polynomial problem input size big notation problems solvable logarithmic solvable polynomial problems solved polynomial called tractable problems solved polynomial called intractable reasons drawing intractability line entries table discussion section imply solve arbitrary instances intractable problems reasonable instances small huge difference running times polynomials drastically degrees polynomial algorithms degree polynomial higher addition polynomials bound running times algorithms extremely large coefficients polynomial functions convenient properties sum composition polynomials fourth choice class led development extensive theory called computational complexity seeks classify problems inherent difficulty theory problem intractability remains principal models computations reasonable input encoding schemes problem consideration basic notions ideas complexity theory section interested formal treatment theory finding wealth textbooks devoted subject aro problems discussed solved polynomial algorithm computing product greatest common divisor integers sorting searching key pattern text string checking connectivity acyclicity graph finding minimum spanning tree shortest paths weighted graph invited examples informally problems solved polynomial set science theoreticians formal definition includes decision problems answers definition class decision problems solved polynomial deterministic algorithms class problems called polynomial restriction decision problems justified reasons exclude problems solvable polynomial exponentially large output problems arise naturally generating subsets set permutations distinct items apparent outset solved polynomial important problems decision problems natural formulation reduced series decision problems easier study minimum colors needed color vertices graph adjacent vertices colored color exists coloring graph vertices colors called coloring problem series decision problem coloring solution solves optimization version graph coloring problem natural decision problem solved polynomial turns fact decision problems solved algorithm problems called undecidable opposed decidable problems solved algorithm famous undecidable problem alan turing problem called halting problem input determine halt input working indefinitely surprisingly short proof remarkable fact contra diction assume algorithm solves halting problem input halts input halt input output algorithm pair construct halts halt input halt halts input substituting halts halt input halt halts input contradiction outcomes completes proof decidable intractable problems examples surprisingly small arise naturally constructed sake theoretical argument important problems polynomial algorithm impossibility algorithm proved classic monograph garey johnson gar problems areas science mathematics operations research small sample problems fall category hamiltonian circuit problem determine graph hamiltonian circuit path starts ends vertex passes vertices traveling salesman problem shortest cities positive integer distances shortest hamiltonian circuit graph positive integer weights breakthrough contributions theoretical science english mathematician science pioneer alan turing recognition acm principal society computing professionals researchers named award outstanding contributions theoretical science lecture occasion richard karp kar interesting historical account development complexity theory knapsack problem valuable subset items positive integer weights values knapsack positive integer capacity partition problem positive integers determine possi ble partition disjoint subsets sum bin packing problem items sizes positive rational num bers larger smallest bins size graph coloring problem graph chromatic smallest colors assigned graph vertices adjacent vertices assigned color integer linear programming problem maximum minimum linear function integer valued variables subject finite set constraints linear equalities inequalities problems decision problems decision version counterparts coloring problem graph coloring problem problems common exponential worse growth choices function input size solution problems fall umbrella solved polynomial eulerian circuit problem existence traverses edges graph solved checking addition graph connectivity graph vertices degrees striking counterintuitive problem cycles traversing edges eulerian circuits easier seemingly similar problem cycles visiting vertices hamiltonian circuits common feature vast majority decision problems fact solving problems computationally difficult checking proposed solution solves problem computationally easy polynomial proposed solution randomly generated leaving task verifying validity easy proposed vertices hamiltonian circuit graph vertices graph vertices distinct consecutive pair vertices connected edge general observation decision problems led scientists notion nondeterministic algorithm definition nondeterministic algorithm stage procedure takes input instance decision problem nondeterministic guessing stage arbitrary string generated thought candidate solution instance gibberish deterministic verification stage deterministic algorithm takes input outputs represents solution instance solution instance algorithm returns allowed halt nondeterministic algorithm solves decision problem instance problem returns execution words require nondeterministic algorithm capable guessing solution verify validity output instance finally nondeterministic algorithm nondeterministic polynomial efficiency verification stage polynomial define class problems definition class decision problems solved nondeterministic polynomial algorithms class problems called nondeterministic polynomial decision problems class includes problems true problem deterministic polynomialtime algorithm solves verification stage nondeterministic algorithm simply ignores string generated nondeterministic guessing stage hamiltonian circuit problem partition problem decision versions traveling salesman knapsack graph coloring hundreds difficult combinatorial optimization problems cataloged gar halting problem rare examples decision problems leads important theoretical science proper subset classes fact symbolically imply hundreds difficult combinatorial decision problems solved polynomial algorithm scientists failed algorithms persistent efforts years decision problems cast doubts possibility problems informally problem difficult problem class definition problem reduced polynomial shown symbolically figure formal definitions concepts definition decision problem polynomially reducible decision problem exists function transforms instances maps instances computable polynomial algorithm definition immediately implies problem polynomially reducible problem solved polynomial problem solved polynomial definition decision problem belongs class problem polynomially reducible fact closely related decision problems polynomially reducible surprising prove hamiltonian circuit problem polynomially reducible decision version traveling problems problem figure notion problem polynomial reductions problems problem shown arrows salesman problem stated existence problem hamil tonian circuit longer positive integer graph positive integer weights map graph instance hamiltonian circuit problem weighted graph representing stance traveling salesman problem assigning weight edge adding edge weight pair nonadjacent vertices upper bound hamiltonian circuit length vertices transformation polynomial instance hamiltonian circuit problem hamiltonian circuit image length making image instance decision traveling salesman problem conversely hamiltonian circuit length larger length circuit edges making inverse image instance decision traveling salesman problem instance hamiltonian circuit problem completes proof notion completeness requires polynomial reducibility problems unknown problem bewildering variety decision problems short amazing specific examples problems neverthe mathematical feat accomplished independently stephen cook united states leonid levin soviet union paper cook coo showed called cnf satisfiability problem cnf satisfiability problem deals boolean expressions boolean expression represented conjunctive normal expression involving boolean variables negations denoted cnf satisfiability problem asks assign values true false variables boolean expression cnf make entire expression true easy formula true false entire expression true cook levin discovery problems scientists hundreds thousands exam ples problems decision versions men tioned hamiltonian circuit traveling salesman partition bin packing graph coloring problems history science breakthrough discoveries independently simultaneously scientists fact levin introduced general notion completeness decision problems paper lev published years cook leading candidate problem determining integer prime composite portant theoretical breakthrough professor manindra agrawal students neeraj kayal nitin saxena indian institute technology kanpur announced discovery deterministic polynomial algorithm primality testing agr algorithm solve related problem factoring large composite integers lies heart widely encryption method called rsa algorithm riv showing decision problem steps problem randomly generated string checked polynomial determine represents solution problem typically easy problem reducible problem polynomial transitivity polynomial reduction showing problem transformed problem polynomial figure transformation ingenious incomparably simpler proving existence transformation problem hamiltonian circuit problem polynomial reducibility decision traveling salesman problem implies easy decision traveling salesman problem class definition completeness immediately implies exists deterministic polynomial algorithm problem solved polynomial deterministic algo rithm words finding polynomial algorithm problems problem candidate completeness figure proving completeness reduction problem qualitative difference complexity checking proposed solution finding polyno mial vast majority decision problems kinds implications make scientists successful finding mathematical proof intriguing conjecture sur prisingly interviews authors lives discoveries prominent scientists sha cook uncertain eventual resolution dilemma levin contended outcome eventual proves knowing problem important practical implications today means faced problem aim gaining fame fortune designing polynomial algorithm solving instances approaches seek alleviate intractability problems approaches outlined chapter exercises game chess posed decision problem legal positioning chess pieces information determine win decision problem decidable problem solved algorithm running nlog assertions true problem tractable problem intractable impossible examples graphs examples graph hamiltonian circuit eulerian circuit graph eulerian circuit hamiltonian circuit graph hamiltonian circuit eulerian circuit graph includes vertices hamil tonian circuit eulerian circuit clay mathematics institute cmi cambridge massachusetts designated prize solution problem graphs chromatic design polynomial algorithm graph coloring problem deter vertices graph colored colors adjacent vertices colored color brute algorithm solving composite num ber problem successive integers divisors divides evenly composite algorithm problem class state decision version problems outline polynomial algorithm verifies proposed solution solves problem assume proposed solution represents legitimate input verification algorithm knapsack problem bin packing problem partition problem polynomially reducible decision version knapsack problem problems polynomially reducible determine graph positive integer clique size clique size graph subgraph vertices determine graph positive integer vertex size vertex size graph subset edge belongs iii determine graph positive integer independent set size independent set size graph subset vertices adjacent determine problem sequences uppercase lowercase letters select letter sequence selecting upper lowercase versions letter sequences abc choose sequence fourth make required selections sequences kar diagrams contradict current state knowledge complexity classes npc problems npc king arthur expects knights annual dinner camelot unfortu nately knights quarrel arthur quarrels arthur seat guests table quarreling knights sit standard problem model king arthur task research project proof arthur problem solution knight quarrel knights challenges numerical algorithms numerical analysis science cerned algorithms solving mathematical problems description important clarification problems continuous mathematics solving equations systems equations evaluating func tions computing integrals opposed problems discrete mathematics dealing structures graphs trees permutations combinations efficient algorithms mathematical problems stems fact problems arise models real life phe nomena natural world social sciences fact numerical analysis main area research study application science rapid proliferation computers business everyday life applications deal primarily storage retrieval information relative importance numerical analysis shrunk years applications enhanced power modern computers areas fundamental research technology inter ests wide world modern computing important understanding special challenges posed continuous mathematical problems discuss variety difficulties posed modeling task describing real life phenomenon mathematical terms assuming principal obstacles solving mathematical problem major obstacle fact numerical analy sis problems solved approximately replacing infinite finite approximation computed approximating infinite taylor series finite sum terms called nth degree taylor polynomial definite integral function approximated finite weighted sum values composite trapezoidal calculus class figure errors approximations called truncation errors major tasks numerical analysis estimate magnitudes truncation solving linear equations polynomial evaluation discussed sections rare exceptions figure composite trapezoidal errors typically calculus tools elementary advanced approximation max segment endpoints formula makes determine degree taylor polynomial needed predefined accuracy approximation compute formula truncation error smaller proceed estimate formula max bound desired accuracy solve inequality compute values smallest inequality holds similarly approximation standard bound truncation error inequality max interval asked inequality exercises section problems errors called errors caused accuracy represent real numbers digital errors arise irrational numbers definition require infinite digits exact representation rational numbers overwhelming majority situations real numbers represented floating numbers base unsophisticated calculators digits representing fractional called mantissa integer exponent range values approximately symmetric accuracy floating representation depends significant digits representation computers levels precision single precision typically equivalent significant decimal digits precision significant decimal digits extended precision significant decimal digits higher precision arithmetic slows computations overcome problems caused errors higher precision algorithm approximation kind important distinguish absolute error relative error representing approximation absolute error relative error relative error undefined large small numbers represented floating arithmetic phenomena called underflow respec tively arithmetic operation yields result range floating numbers typical examples arise multiplication large numbers division small eliminate problem making simple expression evaluated replacing expression equal computing logarithm expression underflow occurs result operation nonzero fraction small magnitude represented nonzero floating underflow numbers replaced special generated hardware event occurred important addition inaccurate representation numbers arithmetic operations performed exact subtracting equal floating numbers large relative error phenomenon called subtractive cancellation irrational numbers represented floating numbers relative errors approximations small relative error representing difference floating representations large relative error accurate approximations significant magnification error lowaccuracy difference divisor encountered problem discussing gaussian elimination section solution partial pivoting numerical algorithms involve thousands millions arithmetic operations typical inputs algorithms propagation errors major practical theoretical standpoints algorithms errors propagate algorithm operations increasing effect highly undesirable property numerical algorithm called instability problems exhibit high sensitivity input impossible design stable algorithm solve problems called ill conditioned linear equations unknowns solution sensitive small coefficient matrix slightly values solution previous coefficient matrix singular minor coefficients yield solutions infinitely solutions depending values formal detailed discussion degree ill condition coefficient matrix numerical analysis textbooks ger conclude problem finding real roots quadratic equation real coefficients secondary school algebra equation real roots discriminant nonnegative roots formula solution posed problem mathematician concerned solution algorithm designer major obstacle evaluating square root positive integers irrational computed approximately method computing square roots commonly taught secondary school ton method important algorithm solving equations discuss section method generates sequence approximations nonnegative formula initial approximation chosen possibilities difficultto prove sequence decreasing converges generating elements difference consecutive elements predefined error tolerance sufficiently approximation sequence converges fast values prove iterations needed scale interval formula integer apply newton algorithm compute simplicity scaling numbers decimal places standard numerical analysis notation offs approximations exact issue computing square roots squared pun intended home free write based formula impact errors obstacles faced menace subtractive cancellation larger root computed formula large relative error paper george forsythe equation true roots significant digits george forsythe noted numerical analyst played leading role establishing science academic discipline united states words epigraph preface formula computations decimal floating arithmetic significant digits relative error approximating small root large possibility subtractive cancellation formula obtained danger subtractive cancellation denominator computed standard formula danger cancellation positive case symmetric formulas case considered cases obstacles applying formula related limitations floating arithmetic small division fight danger subtractive cancellation computing calculating precision problems overcome william kahan university toronto algorithm considered significant achievement history numerical analysis overview piqued seek information books devoted exclusively numerical algorithms discuss topic chapter classic methods solving equations unknown exercises textbooks define significant digits approximation largest nonnegative integer definition significant digits approximation approximate absolute error exceeding range values range relative errors approximations approximate obtained degree taylor polynomial compute truncation error approx imation result theoretical prediction section derive formula composite trapezoidal composite trapezoidal approximate definite integrals truncation error approximation pare formula esin xdx computed composite trapezoidal large subintervals truncation error smaller solve systems linear equations ill conditioned write solve equation prove nonnegative sequence newton method computing strictly decreasing converges initial approximation prove iterations newton method needed apply iterations newton method compute estimate absolute relative errors approximation summary class algorithms solving problem lower bound efficiency algorithm class trivial lower bound based counting items problem input processed output items produced information theoretic lower bound obtained mecha nism decision trees technique comparison based algorithms sorting searching specifically general comparison based sorting algorithm log key comparisons worst case general comparison based algorithm searching sorted array log key comparisons worst case adversary method establishing lower bounds based logic malevolent adversary forces algorithm consuming path lower bound established reduction reducing problem lower bound problem complexity theory seeks classify problems computational complexity principal split tractable intractable problems solved polynomial purely technical reasons complexity theory concentrates decision problems answers halting problem undecidable decision problem solved algorithm class decision problems solved polynomial class decision problems randomly guessed solutions verified polynomial important problems hamiltonian circuit problem problems reducible problem polynomial proof problem completeness published cook cnf satisfiability problem proper subset important unresolved issue theoretical science discovery polynomial algorithm thousands problems imply numerical analysis science dealing solving continuous mathematical problems types errors solving majority problems truncation error truncation errors stem replacing infinite objects finite approximations errors inaccuracies representing numbers digital subtractive cancellation result subtracting equal floating numbers lead sharp relative roundoff error avoided changing expression higher precision computing difference writing general solving quadratic equations difficult task problem computing square roots solved utilizing newton method problem subtractive cancellation dealt formulas depending coefficient positive negative computing discriminant precision
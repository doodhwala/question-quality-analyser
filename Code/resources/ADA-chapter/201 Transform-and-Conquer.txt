secret life charles schulz american cartoonist creator peanuts chapter deals group design methods based idea transformation general technique transform conquer methods stage procedures transformation stage problem instance modified reason amenable solution conquering stage solved major variations idea differ transform instance figure transformation simpler convenient instance problem instance simplification transformation representation instance representation transformation instance problem algorithm problem reduction sections chapter encounter examples instance simplification variety section deals simple fruitful idea presorting algorithmic problems easier solve input sorted benefits sorting compensate simpler instance problem representation solution instance problem instance figure transform conquer strategy spent dealing unsorted input directly section introduces important algorithms applied mathematics gaussian elimination algorithm solves linear equations transforming special property makes finding solution easy section ideas instance simplification representation applied trees results avl trees multiway balanced trees simplest case trees section presents heaps heapsort familiar important data structure application sorting benefit light transform conquer design section discuss horner remarkable algorithm evaluating polynomials algorithm hall fame horner candidate induction based algorithm elegance efficiency interesting algorithms exponentiation problem based representation idea chapter concludes review applications variety transform conquer problem reduction variety considered radical problem reduced transformed problem powerful idea extensively complexity theory chapter application designing practical algorithms trivial problem transformed make transformation algorithm solving prob lem efficient compared algorithmic alternatives examples discuss important special case mathematical modeling expressing problem terms purely mathematical objects variables functions equations presorting idea science fact sorting algorithms significant degree fact questions easier sorted efficiency algorithms involve sorting efficiency sorting algorithm sake simplicity assume section lists implemented arrays sorting algorithms easier implement array representation discussed elementary sorting algorithms selection sort insertion sort quadratic worst average cases advanced algorithms mergesort log quicksort efficiency log average case quadratic worst case faster sorting algorithms stated section general comparison based sorting algorithm efficiency log worst case result holds average case efficiency examples illustrate idea presorting examples section exercises checking element uniqueness array element unique ness problem familiar considered brute algo rithm problem section brute algorithm compared pairs array elements equal elements pairs left worst case efficiency alternatively sort array consecutive elements array equal elements pair vice versa algorithm presortelementuniqueness solves element uniqueness problem sorting array input array orderable elements output returns true equal elements false sort array false true running algorithm sum spent sorting spent checking consecutive elements requires log comparisons sorting determine efficiency algorithm quadratic sorting algorithm entire algorithm efficient brute good sorting algorithm mergesort worst case efficiency log worst case efficiency entire presorting based algorithm log tsort tscan log computing mode occurs numbers mode values considered mode brute approach computing mode scan compute frequencies distinct values largest frequency sorting algorithms called radix sorts linear terms total input bits algorithms comparing individual bits pieces keys entirety running algorithms proportional input bits essentially log algorithms bits key log accommodate distinct keys input implement idea values encountered frequencies iteration ith element original compared values encountered traversing auxiliary matching frequency incremented current element added distinct values frequency difficult worst case input algorithm equal elements ith element compared elements auxiliary distinct values added frequency result worst case comparisons algorithm creating frequency additional comparisons needed largest frequency aux iliary quadratic worst case efficiency class algorithm alternative sort input equal values adjacent compute mode longest run adjacent equal values sorted array algorithm presortmode computes mode array sorting input array orderable elements output array mode sort array current run begins position modef requency highest frequency runlength runvalue runlength runvalue runlength modef requency modef requency runlength modevalue runvalue runlength modevalue analysis similar analysis running algorithm dominated spent sorting remainder algorithm takes linear log sort method worst case efficiency asymptotic class worst case efficiency brute algorithm searching problem searching array sortable items brute solution sequential section comparisons worst case array sorted apply binary requires log comparisons worst case assuming efficient log sort total running searching algorithm worst case tsort tsearch log inferior sequential true averagecase efficiency spent sorting justified problem section exercises asks estimate minimum searches needed justify presorting finish discussion presorting mention geometric algorithms dealing sets points presorting points sorted coordinates distance line angle presorting conquer algorithms closest pair problem convex hull problem discussed section problems directed acyclic graphs solved easily topologically sorting digraph problems finding longest shortest paths digraphs exercises sections illustrate finally algorithms based greedy technique subject chapter require presorting inputs intrinsic operations exercises problem finding distance closest numbers array numbers distance numbers computed design presorting based algorithm solving problem deter efficiency class efficiency algorithm brute algo rithm problem exercises sets numbers problem finding intersection set numbers design brute algorithm solving problem determine efficiency class design presorting based algorithm solving problem deter efficiency class problem finding smallest largest elements array numbers design presorting based algorithm solving problem deter efficiency class efficiency algorithms brute algo rithm presorting based algorithm iii conquer algorithm problem exercises estimate searches needed justify spent presorting array elements sorting mergesort searching binary assume searches elements array elements sort design efficient algorithm solving problems determine efficiency class bills checks pay bills assuming numbers written checks failed pay simplicity assume written covers student records indicating student home address date birth students states set points cartesian plane simple polygon closed path points line segments polygon edges intersect neighboring edges common vertex problem solution unique solution design efficient algorithm solving problem indi cate efficiency class array real numbers integer array elements sum array design algorithm problem quadratic efficiency intervals real line interval comprises points strictly endpoints maximum intervals common intervals maximum design algorithm problem quadratic efficiency placement distinct integers sequence boxes pre set inequality signs inserted design algo rithm places numbers boxes inequalities numbers boxes shown maxima cartesian plane dominated inequalities strict set points maximum set dominated set figure maximum points set points circled design efficient algorithm finding maximum points set points cartesian plane efficiency class algorithm real world applications algorithm anagram detection design efficient algorithm finding sets anagrams large dictionary english words ben eat ate tea set write implementing algorithm gaussian elimination familiar systems linear equations unknowns recall coefficients equation proportional coef ficients unique solution standard method finding solution equation express variables function substitute result equation yield ing linear equation solution variable applications solve equations unknowns nxn annxn large theoretically solve general izing substitution method solving systems linear equations general design technique method based resulting algorithm extremely cumbersome fortunately elegant algorithm solving systems linear equations called gaussian elimination idea gaussian elimination transform linear equations unknowns equivalent solution original upper triangular coefficient matrix zeros main diagonal method named carl friedrich gauss giants history mathematics isaac newton leonhard euler numerous fundamental contributions theoretical computational mathematics method chinese years europeans rediscovered nxn annxn matrix notations write ann added primes matrix elements sides stress values differ counterparts original upper triangular coefficient matrix arbitrary coefficient matrix easily solve upper triangular coefficient matrix substitutions immediately equation substitute equation substitute values variables equation arbitrary coefficient matrix equivalent upper triangular coefficient matrix series called elementary operations exchanging equations replacing equation nonzero multiple replacing equation sum difference equation multiple equation elementary operation solution obtained series operations solution original upper triangular matrix pivot make coefficients zeros equations specifically equation difference equation multiplied equation coefficient fourth finally nth equation multiples equation makes coefficients equation rid coefficients subtracting multiple equation equations repeating elimination variables ultimately yields upper triangular coefficient matrix gaussian elimination operate coefficient matrix augmented column equations values words write explicitly variable names equality signs solve gaussian elimination row solution substitutions pseudocode stage called forward elimination algorithm forwardelimination applies gaussian elimination matrix coefficients augmented vector values input matrix column vector output equivalent upper triangular matrix values column augments matrix important observations make pseudocode ith row pivot ith iteration algorithm case advantage elementary operation exchange ith row nonzero coefficient ith column unique solution normal case systems consideration row prepared possibility row exchanges potential difficulty possibility small scaling factor large distorted error caused subtraction numbers greatly magnitudes problem row largest absolute coefficient ith column exchange ith row ith iteration pivot modification called partial pivoting guarantees magnitude scaling factor exceed observation fact innermost loop written glaring inefficiency checking pseudocode incorporates partial pivoting eliminates inefficiency algorithm betterforwardelimination implements gaussian elimination partial pivoting input matrix column vector output equivalent upper triangular matrix values column appends column pivotrow swap pivotrow temp efficiency algorithm innermost loop consists single line temp discuss errors section multiplication subtraction computers multi plication unquestionably expensive addition subtraction multiplication quoted algorithm basic operation standard summation formulas rules reviewed section appen dix helpful derivation substitution stage gaussian elimination asked exercises running dominated cubic elimination stage making entire algorithm cubic theoretically gaussian elimination yields exact solution linear equations unique solution discovers solution exists case solutions infinitely practice solving systems significant size method straightforward method lead principal difficulty lies preventing accumulation errors section consult textbooks numerical analysis analyze implementation issues great decomposition gaussian elimination interesting byproduct called composition coefficient matrix fact modern commercial implementa tions gaussian elimination based decomposition basic algorithm outlined beginning section applied gaussian elimination matrix mentioned section computers multiplication necessarily expensive addition subtraction algorithm moot simply times innermost loop executed multiplications subtractions lower triangular matrix main diagonal row multiples forward elimination process upper triangular matrix result elimination turns product matrices equal matrix pair verify fact direct multiplication general proposition proof omit solving equivalent solving solved denote solve easy lower triangular matrix solve upper triangular matrix beginning section solve solution solving means solving solution decomposition matrix solve systems vectors distinct advantage classic gaussian elimination discussed earlier decomposition require extra memory nonzero upper triangular main diagonal nontrivial main diagonal computing matrix inverse gaussian elimination algorithm tackles important problems applied mathematics solving systems linear equations fact gaussian elimination applied problems linear algebra computing matrix inverse matrix denoted identity matrix elements main diagonal elements square matrix inverse exists inverse unique matrix inverse called singular prove matrix singular rows linear combination sum multiples rows convenient matrix nonsingular apply gaussian elimination yields upper triangular matrix zeros main diagonal matrix nonsingular singular special situation square matrices inverses theoretically inverse matrices important role reciprocals matrix algebra overcoming absence explicit division operation matrices analogy linear equation unknown solution written express solution equations unknowns nonsingular vector definition inverse matrix nonsingular matrix compute numbers xij ann xnn unknowns solving systems linear equations coefficient matrix vector unknowns column inverse vector column identity matrix axj solve systems applying gaussian elimination matrix aug mented identity matrix forward elimina tion decomposition solve systems explained earlier computing determinant problem solved gaussian elimination computing determinant matrix denoted det defined recursively consists single element det equal det computed recursive formula det odd element row column matrix obtained matrix deleting row column matrix definition implies formula easy det words determinant matrix simply equal difference products diagonal elements matrix det incidentally formula handy variety applications section quickhull algorithm compute determinant large matrix task rarely needed practice discussing recursive definition implies computing sum terms gaussian elimination central fact determinant upper triangular matrix equal product elements main diagonal easy elementary operations employed elimination algorithm determinant basically remains unchanged multiplied constant elimination algorithm result compute determinant matrix cubic determinants important role theory systems linear equations specifically linear equations unknowns unique solution determinant coefficient matrix det equal solution formulas called cramer det determinant matrix obtained replacing column asked investigate exercises cramer good algorithm solving systems linear equations exercises solve gaussian elimination solve previous decomposition method standpoint general algorithm design techniques classify decomposition method solve problem computing inverse coefficient matrix multiplying vector efficiency class forward elimination stage gaussian elimination write pseudocode substitution stage gaussian elimination running assuming division numbers takes times longer multiplication estimate faster betterforwardelimination forwardelimination assume compiler eliminate inefficiency forwardelimination linear equations unknowns unique solution solve gaussian elimination linear equations unknowns solution apply gaussian elimination linear equations unknowns infinitely solutions apply gaussian elimination gauss jordan elimination method differs gaussian elimination elements main diagonal coefficient matrix pivot row elements main diagonal apply gauss jordan method problem exercises general design strategy algorithm based general multiplications method solving equations unknowns multiplications gaussian elimination method elimination substitution stages linear equations unknowns unique solution det good idea condition applying gaussian elimination apply cramer solve problem exercises estimate times longer solve linear equations unknowns cramer gaussian elimination assume determinants cramer formulas computed independently gaussian elimination lights person game played board composed light panels panel turned toggling state vertically horizontally adjacent panels toggling corner square affects total panels toggling noncorner panel board border affects total squares initial subset lighted squares goal lights solving linear equations coefficients sides modulo arithmetic gaussian elimination solve instance problem panels board initially lit gaussian elimination solve instance problem panels board initially lit balanced trees sections discussed binary tree prin cipal data structures implementing dictionaries binary tree nodes elements set orderable items element node ele ments left subtree smaller element subtree root elements subtree greater transformation set binary tree representation tech nique gain transformation compared straightforward implementation dictionary array gain efficiency searching insertion deletion log erage case worst case operations tree degenerate severely unbalanced height equal scientists expended lot effort structure preserves good properties classical binary tree principally logarithmic efficiency dictionary operations set ele ments sorted avoids worst case degeneracy approaches approach instance simplification variety unbalanced binary tree transformed balanced trees called balancing specific implementations idea differ definition avl tree requires difference heights left subtrees node exceed red black tree tolerates height subtree large subtree node insertion deletion node creates tree violated requirement tree restructured family special transformations called rotations restore required section discuss avl trees information types binary trees utilize idea rebalancing rotations red black trees splay trees references cor sed tar approach representation variety element node tree specific cases trees general important trees differ elements admissible single node tree perfectly balanced discuss simplest case trees tree section leaving discussion trees chapter avl trees avl trees invented russian scientists adelson velsky landis ade data structure named figure avl tree binary tree avl tree numbers nodes factors definition avl tree binary tree factor node defined difference heights node left subtrees height tree defined factor computed difference numbers levels height difference node left subtrees binary tree figure avl tree figure insertion node makes avl tree unbalanced transform tree rotation avl tree local transformation subtree rooted node nodes rotate tree rooted unbalanced node closest newly inserted leaf types rotations fact mirror images simplest rotations shown figure rotation called single rotation rotating edge connecting root left child binary tree figure presents single rotation general rotation performed key inserted left subtree left child tree root insertion symmetric single left rotation mirror image single rotation performed key inserted subtree child tree root insertion asked draw diagram general case single rotation exercises figure rotation types avl trees nodes single rotation single rotation called left rotation fact combination rotations rotation left subtree root rotation tree rooted figure performed key inserted subtree left child tree root insertion single rotation figure general rotation avl tree shaded node inserted rotation figure general rotation avl tree shaded node inserted left subtree root grandchild left rotation mirror image rotation left exercises rotations trivial transformations fortunately constant resulting tree balanced basic requirements binary tree initial tree figure keys subtree smaller keys subtree smaller keys subtree relationships key values hold balanced tree rotation figure construction avl tree successive insertions parenthesized rotation abbreviation root tree reorganized constructing avl tree numbers shown figure algorithm operations mind nodes rotation tree rooted unbalanced node closest newly inserted leaf efficient avl trees tree critical charac teristic tree height turns bounded logarithmic functions specifically height avl tree nodes satisfies inequalities log weird constants offs irrational numbers related fibonacci numbers golden ratio section inequalities immediately imply operations searching insertion log worst case exact formula average height avl tree constructed random lists keys proved difficult extensive experiments log small knuiii searching avl tree requires average comparisons searching sorted array binary operation key deletion avl tree considerably difficult insertion fortunately turns efficiency class insertion logarithmic impressive efficiency characteristics price drawbacks avl trees frequent rotations maintain balances nodes drawbacks prevented avl trees standard structure implementing dictionaries underlying idea rebalancing binary tree rotations proved fruitful led discoveries interesting variations classical binary tree trees mentioned beginning section idea balancing tree key node tree simplest implementation idea trees introduced scientist john hopcroft tree nodes kinds nodes node single key children left child serves root subtree keys child serves root subtree keys greater words node kind node classical binary tree node ordered keys children leftmost child serves root subtree keys middle child serves root subtree keys rightmost child serves root subtree keys greater figure requirement tree leaves words tree perfectly height balanced length path root leaf property buy allowing key node tree searching key tree straightforward root node act binary tree equal root key left node figure kinds nodes tree subtree smaller larger root key root node key comparisons stopped equal root keys root subtrees continued inserting key tree insert key leaf tree leaf performing leaf node insert key depending smaller larger node key leaf node split leaf smallest keys key leaf largest key leaf middle key promoted leaf parent leaf tree root created middle key promotion middle key parent node lead node splits chain leaf ancestors tree construction figure tree efficiency dictionary operations depends tree height upper bound tree height smallest keys tree nodes final tree figure tree height nodes inequality log tree height largest keys tree nodes keys children tree nodes figure construction tree log lower upper bounds height log imply efficiencies searching insertion deletion log worst average case important generalization trees called trees section exercises binary trees avl trees draw binary trees nodes requirement avl trees draw binary tree height avl tree smallest nodes trees draw diagrams single rotation general lists construct avl tree inserting ele ments successively starting tree avl tree real numbers design algorithm comput ing range difference largest smallest numbers tree determine worst case efficiency true false smallest largest keys avl tree write constructing avl tree distinct integers construct tree alphabetical letters insert successively starting tree assuming probabilities searching keys letters largest average key comparisons successful searches tree classical binary tree constructed keys inserted trees true false searching key takes key comparisons searching tree real numbers design algorithm computing range difference largest smallest numbers tree determine worst case efficiency write constructing tree integers heaps heapsort data structure called disordered pile items word definition standard dictionary clever partially ordered data structure suitable implementing priority queues recall priority multiset items orderable characteristic called item priority operations figure illustration definition leftmost tree finding item highest largest priority deleting item highest priority adding item multiset primarily efficient implementation operations makes interesting priority queues arise naturally plications scheduling job executions operating systems traf fic management communication networks arise impor tant algorithms prim algorithm section dijkstra algorithm sec tion huffman encoding section bound applications section data structure serves cornerstone theoretically important sorting algorithm called heapsort discuss algo rithm define investigate basic properties notion definition defined binary tree keys assigned nodes key node provided conditions met shape property binary tree essentially simply plete levels possibly rightmost leaves missing parental dominance property key node greater equal keys children condition considered auto matically satisfied leaves trees figure tree shape property violated parental dominance fails node key values ordered sequence values path root leaf decreasing nonincreasing equal keys allowed left key values authors require key node equal keys children variation min array representation index parents leaves figure array representation relationship key values nodes tree generally left subtrees node important properties heaps difficult prove properties figure exists essentially binary tree nodes height equal log root largest element node considered descendants implemented array recording elements left fashion convenient elements positions array leaving unused putting sentinel greater element representation parental node keys positions array leaf keys occupy positions children key array parental position positions correspondingly parent key position define array element position half array greater equal elements positions max satisfied ideas majority algorithms dealing heaps easier understand heaps binary trees actual implementations simpler efficient arrays construct keys principal alternatives construction algorithm illustrated figure initializes essentially binary tree nodes placing keys heapifies tree starting parental node algorithm checks parental figure construction headed arrows key comparisons verifying parental dominance holds key node algorithm exchanges node key larger key children checks parental dominance holds position process continues parental dominance satisfied eventually holds automatically key leaf completing heapification subtree rooted current parental node algorithm proceeds node predecessor algorithm stops root tree algorithm heapbottomup constructs elements array algorithm input array orderable items output downto false children true efficient algorithm worst case assume simplicity tree largest nodes occurs height tree property heaps beginning section log specific values key tree leaf worst case construction algorithm moving requires comparisons larger child determine exchange required total key comparisons involving key total key comparisons worst case cworst log keys validity equality proved closed formula sum appendix mathematical induction algorithm size constructed comparisons alternative efficient algorithm constructs successive insertions key previously constructed people construction algorithm insert key node key leaf existing sift parent key greater equal structure swap keys parent swapping continues greater parent reaches root illustrated figure insertion operation require key comparisons height nodes log efficiency insertion log delete item important case deleting root key leaving deleting arbitrary key exercises authors textbooks things readers deleting root key algorithm illustrated figure inserting key constructed figure key sifted swap parent larger parent root figure deleting root key deleted swapped key smaller tree heapified exchanging key root larger key children parental dominance requirement satisfied maximum key deletion exchange root key decrease size heapify smaller tree sifting tree construction algorithm verify parental dominance holds swap larger children operation parental dominance condition holds position efficiency deletion determined key comparisons needed heapify tree swap size tree decreased require key comparisons height efficiency deletion log heapsort interesting sorting algorithm discovered williams wil stage algorithm works stage construction construct array stage maximum deletions apply root deletion operation times remaining result array elements eliminated decreasing array implementation heaps element deleted resulting array original array sorted increasing heapsort traced specific input figure input stage construction stage maximum deletions figure sorting array heapsort figure intentionally tree array implementations construction algorithm construction stage algorithm investigate efficiency stage key comparisons needed eliminating root keys heaps diminishing sizes inequality log means log stage heapsort stages log detailed analysis shows efficiency heapsort fact log worst average cases heapsort efficiency falls class mergesort heapsort require extra storage timing experiments random files heapsort runs slowly quicksort competitive mergesort exercises construct algorithm construct successive key insertions algorithm true algorithms yield input outline algorithm checking array determine efficiency smallest largest keys height prove height nodes equal log prove equality section log design efficient algorithm finding deleting element smallest determine efficiency design efficient algorithm finding deleting element determine efficiency classes main operations priority implemented unsorted array sorted array binary tree avl tree sort lists heapsort array representation heaps increasing alphabetical heapsort stable sorting algorithm variety transform conquer technique heapsort repre sorting algorithm heapsort priority implement advanced sorting algorithms mergesort quicksort heapsort language choice investigate performance arrays sizes randomly generated files integers range increasing files integers decreasing files integers spaghetti sort handful uncooked spaghetti individual rods lengths represent numbers sorted outline spaghetti sort sorting algorithm takes advantage unorthodox representation science folklore dew topic chapter general heapsort horner binary exponentiation section discuss problem computing polynomial anxn important special case computing polynomials constitute important class functions wealth good properties approximating types functions problem manipulating polynomials efficiently important centuries discoveries years important fast fourier transform fft practical importance remarkable algorithm based representing polynomial values specially chosen points people important algorithmic discoveries relative complexity discuss fft algorithm interested reader wealth literature subject accessible treatments textbooks kle cor horner elegant efficient algorithm evaluating polynomial named british mathematician horner pub lished early century knuth knuii method isaac newton years horner method design algorithm polynomial evalu ation problem investigate efficiency problems section exercises horner good representation technique based representing formula obtained successively taking common factor remaining polynomials diminishing degrees anx polynomial formula substitute polynomial evaluated hard efficient algorithm unpleasant appearance formula appearance explicitly transformation leading original polynomial coefficients pen pencil calculation conveniently organized tworow table row polynomial coefficients equal listed highest lowest entry row filled left entry computed times entry row coefficient row final entry computed fashion sought evaluate coefficients comparing table entries formula finally pseudocode algorithm shortest imaginable nontrivial algorithm horner evaluates polynomial horner input array coefficients polynomial degree stored lowest highest output polynomial downto multiplications additions sum efficient horner term polynomial degree anxn computing single term brute algorithm require multiplications horner computes addition term terms multiplications surprising horner optimal algorithm polynomial evaluation preprocessing polynomial coefficients scientists years horner publication realization investigating horner byproducts intermediate numbers generated algorithm process evaluating coefficients quotient division final result addition equal remainder division quotient remainder division algorithm synthetic division convenient called division binary exponentiation amazing efficiency horner fades method applied comput ing fact degenerates brute multiplication wasteful additions zeros computing mod essential operation important primality testing encryption methods algorithms computing based representation idea exploit binary representation exponent processes binary string left bit string representing positive integer binary means computed polynomial bixi binary representation compute polynomial applying horner method operations imply computing power abi horner binary polynomial implications leading digit downto abi initializing accumulator scan bit string representing exponent square accumulator current binary digit observations lead left binary exponentiation method computing algorithm leftrightbinaryexponentiation computes left binary exponentiation algorithm input binary digits binary expansion positive integer output product downto product compute left binary exponentiation algorithm binary digits product accumulator algorithm makes multiplications repetition loop total multiplications computing length bit string representing exponent taking account log conclude efficiency leftto binary exponentiation logarithmic algorithm efficiency class brute exponentiation requires multiplications left binary exponentiation binary polynomial yielding applying horner previous method exploits differently abi computed product terms abi product consecutive terms skipping binary digit addition compute simply squaring term computed previous compute powers smallest largest left product accumulator binary digit pseudocode algorithm rightleftbinaryexponentiation computes left binary exponentiation algorithm input binary digits binary expansion nonnegative integer output term initializes product term product term product compute left binary exponentiation method table filled left binary digits terms product accumulator algorithm efficiency logarithmic reason left binary multiplication usefulness binary exponentia tion algorithms reduced reliance availability explicit binary expansion exponent problem section exercises asks design algorithm shortcoming exercises brute algorithm evaluating polynomial algorithm bruteforcepolynomialevaluation computes polynomial highest lowest term brute algorithm input array coefficients polynomial degree stored lowest highest output polynomial downto power total multiplications total additions algorithm write pseudocode brute polynomial evaluation stems substituting variable polynomial formula evaluating lowest term highest determine multiplications additions algorithm estimate faster horner compared lowest highest term brute algorithm problem multiplication significantly larger addition multiplication addition horner efficient expense space efficient brute algorithm apply horner evaluate polynomial results application horner quo tient remainder division apply horner convert binary decimal multiplications additions subtractions needed division polynomial anxn constant operations synthetic division apply left binary exponentiation algorithm compute left binary exponentiation algorithm nonnegative integer exponent apply left binary exponentiation algorithm compute design nonrecursive algorithm computing mimics left binary exponentiation explicitly binary representation good idea general purpose polynomial evaluation algorithm horner evaluate polynomial corollary fundamental theorem algebra polynomial anxn represented roots polynomial generally complex necessarily distinct discuss representations convenient operations polynomial evaluation addition polynomials multiplication polynomials polynomial interpolation set data points polynomial degree problem reduction version mathematicians professor noted mathematician noticed wife wanted tea kettle cupboard filled stove wife signing seller local bookstore professor kettle sitting kitchen counter professor kettle cupboard proceeded wife routine reduction alg problem solution solved solvable alg problem figure problem reduction strategy professor approached task important problem solving strategy called problem reduction solve problem solve figure professor idea problem reduction plays central role theoretical science classify problems complexity classification chapter strategy actual problem solving practical difficulty applying lies finding problem reduced efforts practical reduction based algorithm efficient solving original problem directly encountered technique earlier section mentioned called synthetic division applying horner polynomial evaluation section fact analytical geometry arbitrary points plane determinant positive left directed line points words reduced geometric relative locations points determinant fact entire idea analytical geometry based reducing geometric problems algebraic vast majority geometric algorithms advantage historic insight rene descartes section examples algorithms based strategy problem reduction computing common multiple recall common multiple positive integers denoted lcm defined smallest integer divisible lcm common multiple important notions elementary arithmetic algebra middle school method computing prime factorizations compute product common prime factors prime factors prime factors lcm computational procedure algorithm drawbacks middle school algorithm computing greatest common divisor discussed section inefficient requires consecutive primes efficient algorithm computing common multiple devised problem reduction efficient algorithm euclid algorithm finding greatest common divisor product common prime factors formula relating lcm gcd difficult product lcm gcd includes factor simply equal product observation leads formula lcm gcd computed efficiently euclid algorithm counting paths graph problem counting paths vertices graph difficult prove mathematical induction paths length ith vertex graph undirected directed equals element adjacency matrix graph problem counting graph paths solved algorithm computing power adjacency matrix exponentiation algorithms discussed computing powers numbers applicable matrices specific graph figure adjacency matrix square numbers paths length vertices graph figure graph adjacency matrix square elements numbers paths lengths paths length vertex path length reduction optimization problems deals solving optimization problems problem asks maximum function maximization problem asks function minimum called minimization problem minimum function algorithm function maximization advantage lies simple formula min max words minimize function maximize negative minimal function property illustrated function real variable figure formula max min valid shows maximization problem reduced equivalent minimization problem relationship minimization maximization problems general holds functions defined domain figure relationship minimization maximization problems min max apply functions variables subject additional constraints important class problems introduced section topic function optimization pointing standard calculus procedure finding extremum points function fact based problem reduction suggests finding function derivative solving equation function critical points words optimization problem reduced problem solving equation principal finding extremum points calling calculus procedure algorithm defined fact general method solving equations secret calculus textbooks problems carefully selected critical points difficulty makes lives students instructors easier process unintentionally create wrong impression students minds linear programming problems optimal decision making reduced instance linear programming problem optimizing linear function variables subject constraints linear equations linear inequalities university endowment invest sum split types investments stocks bonds cash endowment managers annual stock bond cash investments stocks risky bonds endowment rules require invested stocks moneys invested bonds addition total invested stocks bonds invested cash managers invest money maximize create mathematical model problem amounts millions dollars invested stocks bonds cash variables pose optimization problem maximize subject small simple problem optimal decision making reduced instance general linear programming problem maximize minimize cnxn subject ainxn group constraints called nonnegativity constraints strictly speaking unnecessary special cases general constraints ainxn convenient separately linear programming proved flexible model wide variety important applications airline crew scheduling transportation communication network planning oil exploration refining industrial production optimization fact linear programming considered important achievements history applied mathematics classic algorithm problem called simplex method section discovered mathematician george dantzig dan worst case efficiency algorithm exponential performs typical inputs recent algorithm narendra karmarkar kar proven polynomial worstcase efficiency performed competitively simplex method empirical tests important stress simplex method karmarkar algorithm successfully linear programming problems limit variables integer values variables linear programming problem required integers linear programming problem integer linear programming problem special cases assignment problem problems discussed sections integer linear programming problems difficult polynomial algorithm solving arbitrary instance general integer linear programming problem chapter algorithm possibly approaches bound technique discussed section typically solving integer linear programming problems knapsack problem reduced linear programming problem recall section knapsack problem posed knapsack capacity items weights values valuable subset items fits knapsack continuous fractional version problem fraction item knapsack variable representing fraction item knapsack inequality total weight selected items expressed sum total sum continuous version knapsack problem posed linear programming problem maximize subject apply general method solving linear programming problems problem solved simple special algorithm introduced section reduction knapsack problem instance linear programming problem prove correctness algorithm discrete version knapsack problem allowed item integer linear programming problem version maximize subject seemingly minor modification makes drastic difference plexity similar problems constrained discrete values potential ranges fact version eas ier subset continuous version fractional item version fact complicated tinuous counterpart reader interested specific algorithms solving problem wealth literature subject monographs mar kel reduction graph problems pointed section problems solved reduction standard graph problems true variety puzzles games applications vertices graph typically represent states problem edges permitted transi tions states graph vertices represents initial state represents goal state problem vertices kind graph called state space graph transfor mation reduces problem path initial state vertex goal state vertex pwgc pwc pwg pgc pwg pwc pwgc figure state space graph peasant wolf goat cabbage puzzle revisit classic river crossing puzzle included exercises section peasant finds river bank wolf goat cabbage river boat room peasant item wolf goat cabbage absence wolf eat goat eat cabbage peasant solve problem prove solution state space graph problem figure vertices labeled states represent stand peasant wolf goat cabbage bars denote river convenience edges indicating boat occupants crossing terms graph interested finding path initial state vertex labeled pwgc final state vertex labeled pwgc easy distinct simple paths initialstate vertex final state vertex applying breadth formal proof paths smallest edges puzzle solutions requiring river crossings minimum crossings needed success solving simple puzzle lead generating investigating state space graphs straightforward task appreciation consult books artificial intelligence science state space graphs principal subject deal important special case state space graphs sections exercises prove equality lcm gcd underlies algorithm computing lcm euclid algorithm log algorithm computing gcd efficiency algorithm computing lcm numbers construct min binary tree key equal keys children algorithm constructing max defined section construct min prove paths length ith vertex graph undirected directed equals element adjacency matrix graph design algorithm efficiency cubic checking graph vertices length algorithm problem starting arbi trary vertex traverse graph depth forest vertex edge leading grand parent graph triangle graph triangle subgraph algorithm points coordinate plane design algorithm points triangle vertices points design algorithm problem algorithm problem finding positive integer pair integers sum product large design efficient algorithm problem efficiency class assignment problem introduced section stated people assigned execute jobs person job person assigned job assigned person cost accrue ith person assigned job quantity pair problem assign people jobs minimize total cost assignment express assignment problem linear programming problem solve instance linear programming problem section maximize subject graph coloring problem stated vertex coloring prob lem assign smallest colors vertices graph adjacent vertices color edge coloring problem assign smallest colors edges graph edges endpoint color plain edge coloring problem reduced vertex coloring problem dimensional office location problem points cartesian plane location average manhattan dis office minimizes tance office points problem efficiently solved problem reduction technique provided office located input points jealous husbands married couples river boat hold people complicate matters husbands jealous crossing procedure wife bank river woman husband wife husband people bank river constraints solve problem solve problem classical version problem solution river crossings dominoes small rectangular tiles dots called spots pips embossed halves tiles standard domino set tiles unordered pair integers general domino set domino tiles unordered pair integers determine values constructs ring tiles domino set summary transform conquer fourth general algorithm design problem solving strategy discussed fact group techniques based idea transformation problem easier solve principal varieties transform conquer strategy instance simplification representation problem reduction instance simplification transforming instance problem instance problem special property makes problem easier solve presorting gaussian elimination rotations avl trees good examples strategy representation implies changing representation problem instance representation instance examples discussed chapter representation set tree heaps heapsort horner polynomial evaluation binary exponentiation algorithms problem reduction calls transforming problem solved algorithm examples applying idea algorithmic problem solving section reductions linear programming reductions graph problems important examples illustrate transform conquer important data structures algorithms heaps heapsort avl trees gaussian elimination horner essentially binary tree keys node satisfying parental dominance requirement defined binary trees heaps implemented arrays heaps important efficient implementation priority queues underlie heapsort theoretically important sorting algorithm based arranging elements array successively removing largest element remaining algorithm running log worst case average case addition avl trees binary trees balanced extent binary tree maintained transformations types called rotations basic operations avl trees log eliminates bad worst case efficiency classic binary trees achieve perfect tree allowing node ordered keys children idea generalized yield important trees discussed gaussian elimination algorithm solving systems linear equations principal algorithm linear algebra solves transforming equivalent upper triangular coefficient matrix easy solve substitutions gaussian elimination requires multiplications horner optimal algorithm polynomial evaluation coefficient preprocessing requires multiplications additions evaluate degree polynomial horner byproducts synthetic division algorithm binary exponentiation algorithms computing introduced section exploit binary representation exponent process directions left linear programming concerns optimizing linear function variables subject constraints linear equations linear inequalities efficient algorithms capable solving large instances problem thousands variables constraints provided variables required integers called integer linear programming constitute difficult class problems
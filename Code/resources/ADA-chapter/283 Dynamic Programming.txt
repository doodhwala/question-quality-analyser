idea ghost spoken charles dickens dynamic programming algorithm design technique inter esting history invented prominent mathematician richard bellman general method optimizing multistage decision pro cesses word programming technique stands planning refer programming proving important tool applied mathematics dynamic programming tually considered science circles general algorithm design technique special types optimization problems view tech nique dynamic programming technique solving problems overlapping subproblems typically subproblems arise recurrence relating problem solution solutions smaller subproblems solving overlapping subproblems dynamic programming suggests solving smaller subproblems recording results table solution original problem obtained technique illustrated revisiting fibonacci numbers dis cussed section read section discussion beautiful topic feel temptation read succumb fibonacci numbers elements sequence defined simple recurrence initial conditions recurrence directly compute nth fibonacci recompute values function times figure problem computing expressed terms smaller overlapping subproblems computing simply elements dimensional array consecutive values starting view initial conditions equation producing elements element array single loop pseudocode simple algorithm section fact extra array accomplish task recording values elements fibonacci sequence problem exercises phenomenon unusual counter examples chapter straightforward application dynamic programming interpreted special variety space dynamic programming algorithm fined extra space algorithms compute nth fibonacci computing preceding elements sequence section typical algorithm based classic dynamic programming approach solve smaller subproblems problem variation dynamic programming approach seeks solving unnecessary subproblems technique illustrated section exploits called memory functions considered variation dynamic programming classical version dynamic programming variation crucial designing algorithm remains deriving recurrence relating solution problem solutions smaller subproblems availability equation computing nth fibonacci exceptions majority dynamic programming applications deal optimiza tion problems mention general principle underlines applications richard bellman called principle optimality terms original formulation optimal solution instance optimization problem composed optimal solutions subin stances principle optimality holds rare fails finding longest simple path graph applicability problem checked principal difficulty developing dynamic ming algorithm sections exercises chapter standard examples dynamic programming algorithms section fact invented independently discovery dynamic programming viewed examples technique applications numerous applications range optimal breaking text lines baa image resizing avi variety applications sophisticated engineering problems ber basic examples goal section dynamic programming typical examples coin row problem row coins values positive integers necessarily distinct goal maximum money subject constraint coins adjacent initial row picked maximum picked row coins derive recurrence partition allowed coin selections groups coin largest group equal nth coin maximum coins maximum group equal definition recurrence subject obvious initial conditions max compute filling row table left manner similar nth fibonacci algorithm fib section algorithm coinrow applies formula maximum money picked coin row picking adjacent coins input array positive integers indicating coin values output maximum money picked max application algorithm coin row denominations shown figure yields maximum pointing index max index max index max index max index max figure solving coin row problem dynamic programming coin row fact solved problem coins row maximum coins maximum total computations possibilities produced maxima formula application formula sum means coin optimal solution moving computing maximum produced sum means coin optimal solution finally maximum computing produced implying coin optimal solution coin optimal solution repeating computations backtracing information terms larger recorded extra array values computed coinrow largest money picked coins composing optimal set takes space superior alternatives straightforward topdown application recurrence solving problem exhaustive problem section exercises making problem general instance problem minimum coins denominations coin denominations united states countries simple efficient algorithm discussed chapter dynamic programming algorithm general case assuming availability unlimited quantities coins denominations minimum coins values convenient define obtained adding coin denomination denominations select minimizing constant smallest recurrence min ndj compute filling row table left manner similar coin row problem computing table entry requires finding minimum numbers algorithm changemaking applies dynamic programming minimum coins denominations input positive integer array increasing positive integers indicating coin denominations output minimum coins temp min temp application algorithm denominations shown figure yields coins space efficiencies algorithm min figure application algorithm mincoinchange coin denominations coins optimal solution backtrace computa tions denominations produced minima formula instance considered application formula minimum produced minimum produced coin denomination minimum coin set coin collecting problem coins cells board coin cell robot located upper left cell board coins bring cell robot cell current location robot visits cell coin picks coin design algorithm maximum coins robot path largest coins robot bring cell ith row column board cell adjacent cell adjacent cell left largest numbers coins brought cells adjacent cells row adjacent cells left cells column cells assume equal nonexistent neighbors largest coins robot bring cell maximum numbers coin cell words formula max cij coin cell cij formulas table values row column typical dynamic programming algorithms involving dimensional tables algorithm robotcoincollection applies dynamic programming compute largest coins robot board starting moving upper left corner input matrix elements equal cells coin output largest coins robot bring cell max algorithm illustrated figure coin setup figure computing formula cell table takes constant efficiency algorithm space efficiency tracing computations backward makes optimal path optimal path cell adjacent cell optimal path cell adjacent cell left cell direction yields optimal paths instance figure shown figure ties optimal path obtained figure coins dynamic programming algorithm results paths coins maximum coins exercises dynamic programming common conquer principal difference solve instance coin row problem efficiency solving coin row problem straight forward application recurrence exponential efficiency solving coin row problem exhaustive exponential apply dynamic programming algorithm solutions making problem denominations modify dynamic programming algorithm coin collecting problem cells board inaccessible robot apply algorithm board inaccessible cells shown optimal paths board rod cutting problem design dynamic programming algorithm fol lowing problem maximum total sale price obtained cutting rod units integer length pieces sale price piece units space efficiencies algorithm shortest path counting chess rook horizontally vertically square row column chessboard shortest paths rook corner chessboard diagonally corner length path measured squares passes squares solve problem dynamic programming algorithm elementary combinatorics minimum sum descent positive integers arranged equilateral triangle numbers base shown figure problem smallest sum descent triangle apex base sequence adjacent numbers shown figure circles design dynamic programming algorithm problem efficiency binomial coefficient design efficient algorithm computing bino mial coefficient multiplications space efficiencies algorithm longest path dag design efficient algorithm finding length longest path dag problem important prototype dynamic programming applications determines minimal needed completing project comprising precedence constrained tasks coin row problem discussed section problem finding longest path dag maximum square submatrix boolean matrix largest square submatrix elements zeros design dynamic programming algorithm efficiency algorithm finding largest free square area screen selecting construction site world series odds teams playing series games teams wins games assume probability winning game equal probability losing game ties probability winning series games win series games win series set recurrence relation dynamic programming algorithm probability team winning game series proba bility winning game write pseudocode dynamic programming algorithm solving problem determine space efficiencies knapsack problem memory functions section designing dynamic programming algorithm knapsack problem items weights values knapsack capacity valuable subset items knapsack problem introduced section discussed solving exhaustive assume weights knapsack capacity positive integers item values integers design dynamic programming algorithm derive recurrence relation expresses solution instance knapsack problem terms solutions smaller subinstances instance defined items weights values knapsack capacity optimal solution instance valuable subset items knapsack capacity subsets items knapsack capacity categories ith item subsets ith item optimal subset definition subsets ith item optimal subset item optimal subset items fits knapsack capacity optimal subset optimal solution feasible subsets items maximum values ith item knapsack optimal subset selected items optimal subset selected items observations lead recurrence max convenient define initial conditions goal maximal subset items knapsack capacity optimal subset figure illustrates values involved equations compute entry ith row column compute maximum entry previous row column sum entry previous row columns left table filled row column goal figure table solving knapsack problem dynamic programming capacity figure solving instance knapsack problem dynamic programming algorithm instance data item weight capacity dynamic programming table filled applying formulas shown figure maximal composition optimal subset backtracing computations entry table item included optimal solution optimal subset filling remaining units knapsack capacity item optimal subset item optimal selection leaves element remaining composition similarly item final optimal solution item efficiency space efficiency algorithm needed composition optimal solution asked prove assertions exercises memory functions discussed beginning chapter illustrated subsequent sections dynamic programming deals problems solutions recurrence relation overlapping subproblems direct approach finding solution recurrence leads algorithm solves common subproblems inefficient typically exponential worse classic dynamic programming approach works fills table solutions smaller subproblems solved unsatisfying aspect approach solutions smaller subproblems solution problem drawback approach natural combine strengths approaches goal method solves subproblems method exists based memory functions method solves problem manner addition maintains table kind dynamic programming algorithm initially table entries initialized special null symbol calculated method checks entry table entry null simply retrieved table computed recursive result recorded table algorithm implements idea knapsack problem initializing table recursive function called items knapsack capacity algorithm mfknapsack implements memory function method knapsack problem input nonnegative integer indicating items considered nonnegative integer indicating knapsack capacity output optimal feasible subset items global variables input arrays eights alues table entries initialized row column initialized weights mfknapsack max mfknapsack values mfknapsack weights apply memory function method instance considered table figure results nontrivial values row column computed capacity figure solving instance knapsack problem memory function algorithm nontrivial entry retrieved recomputed larger instances proportion entries significantly larger general constant factor gain memory function method knapsack problem efficiency class algorithm significant improvement expected dynamic programming algorithms computation takes constant mind memory function algorithm space efficient space efficient version algorithm exercises apply dynamic programming algorithm instance knapsack problem item weight capacity optimal subsets instance general table generated dynamic ming algorithm optimal subset knapsack problem instance write pseudocode dynamic programming algorithm knapsack problem write pseudocode algorithm finds composition optimal subset table generated dynamic programming algorithm knapsack problem dynamic programming algorithm knapsack prob lem prove efficiency space efficiency needed composition optimal subset filled dynamic programming table true false sequence values row dynamic programming table knapsack problem nondecreasing true false sequence values column dynamic ming table knapsack problem nondecreasing design dynamic programming algorithm version knapsack problem unlimited quantities copies item kinds efficiency algorithm apply memory function method instance knapsack problem entries dynamic programming table computed memory function method retrieved recomputation prove efficiency class memory function algorithm knap problem algorithm problem memory function approach unattractive problem computing binomial coefficient formula write research applications dynamic programming finding longest common subsequence sequences optimal string editing minimal triangulation polygon optimal binary trees binary tree important data structures science principal applications implement dictionary set elements operations searching insertion deletion probabilities figure binary trees keys searching elements set accumulated data searches natural pose optimal binary tree average comparisons smallest simplicity limit discussion minimizing average comparisons successful method extended unsuccessful searches keys searched probabilities figure depicts binary trees keys average comparisons successful trees fact optimal binary tree optimal tiny optimal tree generating binary trees keys general algorithm exhaustive approach unrealistic total binary trees keys equal nth catalan grows infinity fast problem section exercises distinct keys ordered smallest largest probabilities searching smallest average comparisons successful binary tree tij keys integer indices classic dynamic programming approach values smaller instances problem interested derive recurrence underlying dynamic programming algorithm ways choose root keys binary tree figure root key left subtree tik keys optimally arranged subtree tkj optimal bst figure binary tree bst root optimal binary subtrees tik tkj keys optimally arranged taking advantage principle optimality tree levels starting make comparison numbers equal keys levels recurrence relation obtained min tik ikj tkj min tik tkj ikj min ikj recurrence min ikj assume formula interpreted comparisons tree formula implies node binary tree goal figure table dynamic programming algorithm constructing optimal binary tree dimensional table figure shows values needed comput ing formula row columns left column rows row arrows pairs sums computed smallest recorded suggests filling table diagonals starting zeros main diagonal probabilities moving upper corner algorithm sketched computes average comparisons successful searches optimal binary tree optimal tree maintain dimensional table minimum achieved table shape table figure filled manner starting entries table filled entries indices roots optimal subtrees makes reconstruct optimal tree entire set illustrate algorithm applying key set beginning section key probability initial tables main table root table compute min binary trees keys root optimal tree index average comparisons successful tree finish computations exercises final tables main table root table average key comparisons optimal tree equal root optimal tree key left subtree keys subtree key specific structure subtrees roots consulting root table root optimal tree left child root onenode tree root node optimal tree key figure presents optimal tree entirety figure optimal binary tree pseudocode dynamic programming algorithm optimalbst finds optimal binary tree dynamic programming input array probabilities sorted keys output average comparisons successful searches optimal bst table subtrees roots optimal bst diagonal minval kmin sum minval sum algorithm space efficiency quadratic efficiency version algorithm cubic careful analysis shows entries root table nondecreasing row column limits values range makes running algorithm exercises finish computations started section constructing optimal binary tree efficiency algorithm optimalbst cubic space efficiency algorithm optimalbst quadratic write pseudocode linear algorithm generates optimal binary tree root table devise compute sums dynamic programming algorithm constructing optimal binary tree constant sum true false root optimal binary tree key highest probability construct optimal binary tree set keys equally searched average comparisons successful tree distinct binary trees constructed set orderable keys satisfies recurrence relation solution recurrence catalan numbers verify assertion growth implication exhaustive algorithm constructing optimal binary tree design algorithm finding optimal binary tree generalize optimal binary algorithm taking account unsuc cessful searches write pseudocode memory function optimal binary tree problem limit function finding smallest key comparisons successful matrix chain multiplication problem minimizing total multiplications computing product matrices dimensions assume intermediate products matrices computed brute definition based algorithm matrices multiplications differ factor ways compute product matrices design dynamic programming algorithm finding optimal multiplying matrices warshall floyd algorithms section algorithms warshall algorithm computing transitive closure directed graph floyd algorithm pairs shortest paths problem algorithms based essentially idea exploit relationship problem simpler smaller version warshall floyd published algorithms mention ing dynamic programming algorithms dynamic programming flavor considered applications tech nique warshall algorithm recall adjacency matrix aij directed graph boolean matrix ith row column directed edge ith vertex interested matrix information existence directed paths arbitrary lengths vertices graph matrix called transitive closure digraph determine constant vertex reachable ith vertex application examples spreadsheet cell changed spreadsheet software cells affected spreadsheet modeled digraph vertices represent spreadsheet cells edges cell dependencies transitive closure information software engineering transitive closure investigating data control dependencies inheritance testing oriented software electronic engineering redundancy identification generation digital circuits definition transitive closure directed graph vertices defined boolean matrix tij element ith row column exists nontrivial path directed path positive length ith vertex tij digraph adjacency matrix transitive closure figure generate transitive closure digraph depth breadth performing traversal starting ith figure digraph adjacency matrix transitive closure vertex information vertices reachable columns ith row transitive closure traversal vertex starting yields transitive closure entirety method traverses digraph times algorithm exists called warshall algorithm stephen warshall discovered war convenient assume digraph vertices rows columns adjacency matrix numbered warshall algorithm constructs transitive closure series boolean matrices information directed paths digraph specifically element ith row column matrix equal exists directed path positive length ith vertex intermediate vertex numbered higher series starts intermediate vertices paths adjacency matrix digraph recall adjacency matrix information edge paths intermediate vertices information paths vertex intermediate freedom speak general subsequent matrix series vertex intermediate paths predecessor matrix series reflects paths vertices digraph intermediate digraph transitive closure central algorithm compute elements matrix predecessor series element ith row column matrix equal means exists path ith vertex intermediate vertex numbered higher intermediate vertices numbered higher figure changing zeros warshall algorithm situations path inter mediate vertices kth vertex path intermediate vertices numbered higher equal possibility path kth vertex intermediate vertices loss generality assume occurs case create path property simply eliminating vertices occurrences caveat path rewritten vertices numbered vertices numbered representation means exists path intermediate vertex numbered higher means exists path intermediate vertex numbered higher proved easy converse assertion true formula generating elements matrix elements matrix formula heart warshall algorithm formula implies generating elements matrix elements matrix convenient applying warshall algorithm element rij remains element rij changed element row column element column row illustrated figure application warshall algorithm digraph figure shown figure existence paths intermediate vertices adjacency matrix boxed row column existence paths intermediate vertices numbered higher vertex path boxed row column existence paths intermediate vertices numbered higher paths boxed row column existence paths intermediate vertices numbered higher paths boxed row column existence paths intermediate vertices numbered higher paths figure application warshall algorithm digraph shown bold pseudocode warshall algorithm warshall implements warshall algorithm computing transitive closure input adjacency matrix digraph vertices output transitive closure digraph observations warshall algorithm remarkably succinct efficiency fact sparse graphs represented adjacency lists traversal based algorithm figure digraph weight matrix distance matrix mentioned beginning section asymptotic efficiency warshall algorithm speed implementation warshall algorithm inputs restructuring innermost loop problem section exercises make algorithm run faster matrix rows bit strings bitwise operation modern languages space efficiency warshall algorithm situation similar computing fibonacci dynamic programming algorithms matrices recording intermediate results algorithm fact unnecessary problem section exercises asks avoiding wasteful memory finally underlying idea warshall algorithm applied general problem finding lengths shortest paths weighted graphs floyd algorithm pairs shortest paths problem weighted connected graph undirected directed pairs shortest paths problem asks distances lengths shortest paths vertex vertices variations problem involving shortest paths graphs important applications communications transportation networks operations research studied years recent applications pairs shortest path problem precomputing distances motion planning games convenient lengths shortest paths matrix called distance matrix element dij ith row column matrix length shortest path ith vertex figure generate distance matrix algorithm similar warshall algorithm called floyd algorithm inventor robert floyd applicable undirected directed weighted graphs provided floyd explicitly referenced warshall paper presenting algorithm flo years earlier bernard roy published essentially algorithm proceedings french academy sciences roy negative length distance vertices arbitrarily small repeating times algorithm enhanced lengths shortest paths vertex pairs shortest paths problem section exercises floyd algorithm computes distance matrix weighted graph vertices series matrices lengths shortest paths constraints paths considered matrix specifically element ith row column matrix equal length shortest path paths ith vertex intermediate vertex numbered higher series starts intermediate vertices paths simply weight matrix graph matrix series lengths shortest paths vertices intermediate distance matrix sought warshall algorithm compute elements matrix predecessor series element ith row column matrix means equal length shortest path paths ith vertex intermediate vertices numbered higher intermediate vertices numbered higher partition paths disjoint subsets kth vertex intermediate paths subset intermediate vertices numbered higher shortest definition matrices length shortest path subset graph negative length limit attention paths subset vertex intermediate vertex visiting path length paths vertices numbered vertices numbered words paths path intermediate vertex numbered higher path intermediate vertex numbered higher situation depicted symbolically figure length shortest path paths intermediate vertices numbered higher equal length shortest path paths intermediate figure underlying idea floyd algorithm vertices numbered higher equal length shortest path paths kth vertex equal taking account lengths shortest paths subsets leads recurrence min wij element row column current distance matrix replaced sum elements row column row sum smaller current application floyd algorithm graph figure illustrated figure pseudocode floyd algorithm takes advantage fact matrix sequence written predecessor algorithm floyd implements floyd algorithm pairs shortest paths problem input weight matrix graph negative length output distance matrix shortest paths lengths overwritten min efficiency floyd algorithm cubic efficiency warshall algorithm chapter dijkstra algorithm method finding shortest paths lengths shortest paths intermediate vertices simply weight matrix lengths shortest paths intermediate vertices numbered higher shortest paths lengths shortest paths intermediate vertices numbered higher shortest path lengths shortest paths intermediate vertices numbered higher shortest paths lengths shortest paths intermediate vertices numbered higher shortest path figure application floyd algorithm digraph shown updated elements shown bold exercises apply warshall algorithm transitive closure digraph fined adjacency matrix prove efficiency warshall algorithm cubic efficiency class warshall algorithm inferior traversal based algorithm sparse graphs represented adjacency lists implement warshall algorithm extra memory storing elements algorithm intermediate matrices restructure innermost loop algorithm warshall make run faster inputs rewrite pseudocode warshall algorithm assuming matrix rows represented bit strings bitwise operation formed warshall algorithm determine digraph dag directed acyclic graph good algorithm problem good idea apply warshall algorithm transitive closure undirected graph solve pairs shortest path problem digraph weight matrix prove matrix sequence floyd algorithm written predecessor graph digraph negative weights floyd algorithm yield result enhance floyd algorithm shortest paths lengths jack straws game jack straws plastic wooden straws dumped table players disturbing straws concerned pairs straws connected path touching straws endpoints straws dumped large piece graph paper determine pairs straws connected touching connecting straws connected indirectly connected straws east central regionals acm international collegiate programming contest summary dynamic programming technique solving problems overlapping subproblems typically subproblems arise recurrence relating solution problem solutions smaller subproblems dynamic programming suggests solving smaller subproblem recording results table solution original problem obtained applicability dynamic programming optimization problem requires problem principle optimality optimal solution instances optimal solutions subinstances problems making problem arbitrary coin denominations solved dynamic programming solving knapsack problem dynamic programming algorithm exemplifies application technique difficult problems combinatorial optimization memory function technique seeks combine strengths topdown approaches solving problems overlapping subproblems solving fashion subproblems problem recording solutions table dynamic programming constructing optimal binary tree set keys probabilities searching warshall algorithm finding transitive closure floyd algorithm pairs shortest paths problem based idea interpreted application dynamic programming technique
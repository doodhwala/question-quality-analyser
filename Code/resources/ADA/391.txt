Problem Reduction
We have already encountered the problem-reduction approach in Section 6.6.
There, we discussed getting an algorithm for problem P by reducing it to another
problem Q solvable with a known algorithm. A similar reduction idea can be used
for finding a lower bound. To show that problem P is at least as hard as another
problem Q with a known lower bound, we need to reduce Q to P (not P to Q!).
In other words, we should show that an arbitrary instance of problem Q can be
transformed (in a reasonably efficient fashion) to an instance of problem P , so
any algorithm solving P would solve Q as well. Then a lower bound for Q will be
a lower bound for P . Table 11.1 lists several important problems that are often
used for this purpose.
     TABLE 11.1 Problems often used for establishing lower bounds
              by problem reduction
     Problem                                Lower bound   Tightness
     sorting                                   (n log n)  yes
     searching in a sorted array               (log n)    yes
     element uniqueness problem                (n log n)  yes
     multiplication of n-digit integers        (n)        unknown
     multiplication of n × n matrices          (n2)       unknown
     We will establish the lower bounds for sorting and searching in the next sec-
     tion. The element uniqueness problem asks whether there are duplicates among n
     given numbers. (We encountered this problem in Sections 2.3 and 6.1.) The proof
     of the lower bound for this seemingly simple problem is based on a very sophisti-
     cated mathematical analysis that is well beyond the scope of this book (see, e.g.,
     [Pre85] for a rather elementary exposition). As to the last two algebraic prob-
     lems in Table 11.1, the lower bounds quoted are trivial, but whether they can be
     improved remains unknown.
     As an example of establishing a lower bound by reduction, let us consider
     the Euclidean minimum spanning tree problem: given n points in the Cartesian
     plane, construct a tree of minimum total length whose vertices are the given
     points. As a problem with a known lower bound, we use the element uniqueness
     problem. We can transform any set x1, x2, . . . , xn of n real numbers into a set
     of n points in the Cartesian plane by simply adding 0 as the points' y coordinate:
     (x1, 0), (x2, 0), . . . , (xn, 0). Let T be a minimum spanning tree found for this set of
     points. Since T must contain a shortest edge, checking whether T contains a zero-
     length edge will answer the question about uniqueness of the given numbers. This
     reduction implies that  (n log n) is a lower bound for the Euclidean minimum
     spanning tree problem, too.
     Since the final results about the complexity of many problems are not known,
     the reduction technique is often used to compare the relative complexity of prob-
     lems. For example, the formulas
              x . y = (x + y)2 - (x - y)2      and        x2 = x . x
                                         4
     show that the problems of computing the product of two n-digit integers and
     squaring an n-digit integer belong to the same complexity class, despite the latter
     being seemingly simpler than the former.
     There are several similar results for matrix operations. For example, multi-
     plying two symmetric matrices turns out to be in the same complexity class as
     multiplying two arbitrary square matrices. This result is based on the observation
     that not only is the former problem a special case of the latter one, but also that
we can reduce the problem of multiplying two arbitrary square matrices of order
n, say, A and B, to the problem of multiplying two symmetric matrices
                        X=      0     A        and   Y=    0   BT        ,
                             AT       0                    B       0
where AT and BT are the transpose matrices of A and B (i.e., AT [i, j ] = A[j, i] and
BT [i, j ] = B[j, i]), respectively, and 0 stands for the n × n matrix whose elements
are all zeros. Indeed,
                  XY =       0     A        0  BT    =     AB         0     ,
                            AT     0        B     0        0   AT BT
from which the needed product AB can be easily extracted. (True, we will have
to multiply matrices twice the original size, but this is just a minor technical
complication with no impact on the complexity classes.)
    Though such results are interesting, we will encounter even more important
applications of the reduction approach to comparing problem complexity in Sec-
tion 11.3.
Exercises 11.1
1.  Prove that any algorithm solving the alternating-disk puzzle (Problem 14 in
    Exercises 3.1) must make at least n(n + 1)/2 moves to solve it. Is this lower
    bound tight?
2.  Prove that the classic recursive algorithm for the Tower of Hanoi puzzle
    (Section 2.4) makes the minimum number of disk moves needed to solve the
    problem.
3.  Find a trivial lower-bound class for each of the following problems and indi-
    cate, if you can, whether this bound is tight.
    a.  finding the largest element in an array
    b. checking completeness of a graph represented by its adjacency matrix
    c.  generating all the subsets of an n-element set
    d. determining whether n given real numbers are all distinct
4.  Consider the problem of identifying a lighter fake coin among n identical-
    looking   coins  with    the   help  of    a  balance  scale.     Can   we  use  the  same
    information-theoretic argument as the one in the text for the number of ques-
    tions in the guessing game to conclude that any algorithm for identifying the
    fake will need at least     log2 n   weighings in the worst case?
5.  Prove that any comparison-based algorithm for finding the largest element of
    an n-element set of real numbers must make n - 1 comparisons in the worst
    case.
           6.   Find a tight lower bound for sorting an array by exchanging its adjacent
                elements.
           7.   Give an adversary-argument proof that the time efficiency of any algorithm
                that checks connectivity of a graph with n vertices is in        (n2), provided the
                only operation allowed for an algorithm is to inquire about the presence of
                an edge between two vertices of the graph. Is this lower bound tight?
           8.   What is the minimum number of comparisons needed for a comparison-based
                sorting algorithm to merge any two sorted lists of sizes n and n + 1 elements,
                respectively? Prove the validity of your answer.
           9.   Find the product of matrices A and B through a transformation to a product
                of two symmetric matrices if
                                    A=     1  -1          and  B=  0       1  .
                                           2  3                    -1      2
           10.  a.  Can one use this section's formulas that indicate the complexity equiva-
                    lence of multiplication and squaring of integers to show the complexity
                    equivalence of multiplication and squaring of square matrices?
                b. Show that multiplication of two matrices of order n can be reduced to
                    squaring a matrix of order 2n.
           11.  Find a tight lower-bound class for the problem of finding two closest numbers
                among n real numbers x1, x2, . . . , xn.
           12.  Find a tight lower-bound class for the number placement problem (Problem 9
                in Exercises 6.1).
     
An Outline of the Simplex Method
Our task now is to "translate" the geometric description of the simplex method
into the more algorithmically precise language of algebra. To begin with, before
we can apply the simplex method to a linear programming problem, it has to be
represented in a special form called the standard form. The standard form has the
following requirements:
It must be a maximization problem.
All the constraints (except the nonnegativity constraints) must be in the form
of linear equations with nonnegative right-hand sides.
All the variables must be required to be nonnegative.
Thus, the general linear programming problem in standard form with m con-
straints and n unknowns (n  m) is
maximize    c1x1 + . . . + cnxn
subject to  ai1x1 + . . . + ainxn = bi,    where bi  0 for i = 1, 2, . . . , m  (10.3)
            x1  0, . . . , xn  0.
It can also be written in compact matrix notations:
                         maximize          cx
                         subject to        Ax = b
                                           x  0,
     where
                                    x1                                                b1  
                               x =  x...2  ,  A =  a...11  a1... 2  ...  a1...n  ,  b =  b...2  .
     c = [c1 c2    . . . cn],
                                    xn             am1     am2      ...  amn          bm
     Any linear programming problem can be transformed into an equivalent
     problem in standard form. If an objective function needs to be minimized, it can
     be replaced by the equivalent problem of maximizing the same objective function
     with all its coefficients cj replaced by -cj , j = 1, 2, . . . , n (see Section 6.6 for
     a more general discussion of such transformations). If a constraint is given as an
     inequality, it can be replaced by an equivalent equation by adding a slack variable
     representing the difference between the two sides of the original inequality. For
     example, the two inequalities of problem (10.2) can be transformed, respectively,
     into the following equations:
            x + y + u = 4 where u  0          and  x + 3y + v = 6 where v  0.
     Finally, in most linear programming problems, the variables are required to be
     nonnegative to begin with because they represent some physical quantities. If this
     is not the case in an initial statement of a problem, an unconstrained variable
     xj can be replaced by the difference between two new nonnegative variables:
     xj = xj - xj , xj  0, xj  0.
     Thus, problem (10.2) in standard form is the following linear programming
     problem in four variables:
                               maximize       3x + 5y + 0u + 0v
                               subject to     x+   y+      u        =4                (10.4)
                                              x + 3y +        +     v=6
                                              x, y, u, v  0.
     It is easy to see that if we find an optimal solution (x, y, u, v) to problem (10.4),
     we can obtain an optimal solution to problem (10.2) by simply ignoring its last two
     coordinates.
     The principal advantage of the standard form lies in the simple mechanism
     it provides for identifying extreme points of the feasible region. To do this for
     problem (10.4), for example, we need to set two of the four variables in the con-
     straint equations to zero to get a system of two linear equations in two unknowns
     and solve this system. For the general case of a problem with m equations in n
     unknowns (n  m), n - m variables need to be set to zero to get a system of m
     equations in m unknowns. If the system obtained has a unique solution--as any
     nondegenerate system of linear equations with the number of equations equal to
     the number of unknowns does--we have a basic solution; its coordinates set to
     zero before solving the system are called nonbasic, and its coordinates obtained by
     solving the system are called basic. (This terminology comes from linear algebra.
Specifically, we can rewrite the system of constraint equations of (10.4) as
                     x  1     +y  1   +u       1  +v  0  =  4      .
                        1         3            0      1     6
A basis in the two-dimensional vector space is composed of any two vectors that
are not proportional to each other; once a basis is chosen, any vector can be
uniquely expressed as a sum of multiples of the basis vectors. Basic and nonba-
sic variables indicate which of the given vectors are, respectively, included and
excluded in a particular basis choice.)
If all the coordinates of a basic solution are nonnegative, the basic solution is
called a basic feasible solution. For example, if we set to zero variables x and y
and solve the resulting system for u and v, we obtain the basic feasible solution
(0, 0, 4, 6); if we set to zero variables x and u and solve the resulting system for y
and v, we obtain the basic solution (0, 4, 0, -6), which is not feasible. The impor-
tance of basic feasible solutions lies in the one-to-one correspondence between
them and the extreme points of the feasible region. For example, (0, 0, 4, 6) is an
extreme point of the feasible region of problem (10.4) (with the point (0, 0) in Fig-
ure 10.1 being its projection on the x, y plane). Incidentally, (0, 0, 4, 6) is a natural
starting point for the simplex method's application to this problem.
As mentioned above, the simplex method progresses through a series of
adjacent extreme points (basic feasible solutions) with increasing values of the
objective function. Each such point can be represented by a simplex tableau, a
table storing the information about the basic feasible solution corresponding to the
extreme point. For example, the simplex tableau for (0, 0, 4, 6) of problem (10.4)
is presented below:
                           x      y       u       v
u                          1      1       1       0      4
v                          1      3       0       1      6                    (10.5)
                           ­3     ­5      0       0      0
In general, a simplex tableau for a linear programming problem in standard form
with n unknowns and m linear equality constraints (n  m) has m + 1 rows and
n + 1 columns. Each of the first m rows of the table contains the coefficients of
a corresponding constraint equation, with the last column's entry containing the
equation's right-hand side. The columns, except the last one, are labeled by the
names of the variables. The rows are labeled by the basic variables of the basic
feasible solution the tableau represents; the values of the basic variables of this
     solution are in the last column. Also note that the columns labeled by the basic
     variables form the m × m identity matrix.
     The last row of a simplex tableau is called the objective row. It is initialized
     by the coefficients of the objective function with their signs reversed (in the first
     n columns) and the value of the objective function at the initial point (in the last
     column). On subsequent iterations, the objective row is transformed the same
     way as all the other rows. The objective row is used by the simplex method to
     check whether the current tableau represents an optimal solution: it does if all
     the entries in the objective row--except, possibly, the one in the last column--are
     nonnegative. If this is not the case, any of the negative entries indicates a nonbasic
     variable that can become basic in the next tableau.
     For example, according to this criterion, the basic feasible solution (0, 0, 4, 6)
     represented by tableau (10.5) is not optimal. The negative value in the x-column
     signals the fact that we can increase the value of the objective function z = 3x +
     5y + 0u + 0v by increasing the value of the x-coordinate in the current basic
     feasible solution (0, 0, 4, 6). Indeed, since the coefficient for x in the objective
     function is positive, the larger the x value, the larger the value of this function. Of
     course, we will need to "compensate" an increase in x by adjusting the values of
     the basic variables u and v so that the new point is still feasible. For this to be the
     case, both conditions
                            x+u=4                where u  0
                            x+v=6                where v  0
     must be satisfied, which means that
                            x  min{4, 6} = 4.
     Note that if we increase the value of x from 0 to 4, the largest amount possible,
     we will find ourselves at the point (4, 0, 0, 2), an adjacent to (0, 0, 4, 6) extreme
     point of the feasible region, with z = 12.
     Similarly, the negative value in the y-column of the objective row signals the
     fact that we can also increase the value of the objective function by increasing
     the value of the y-coordinate in the initial basic feasible solution (0, 0, 4, 6). This
     requires
                            y+u=4                where u  0
                            3y + v = 6           where v  0,
     which means that
                            y             min{   4  ,  6}  =  2.
                                                 1     3
     If we increase the value of y from 0 to 2, the largest amount possible, we will find
     ourselves at the point (0, 2, 2, 0), another adjacent to (0, 0, 4, 6) extreme point,
     with z = 10.
     If there are several negative entries in the objective row, a commonly used
     rule is to select the most negative one, i.e., the negative number with the largest
absolute value. This rule is motivated by the observation that such a choice yields
the largest increase in the objective function's value per unit of change in a vari-
able's value. (In our example, an increase in the x-value from 0 to 1 at (0, 0, 4, 6)
changes the value of z = 3x + 5y + 0u + 0v from 0 to 3, while an increase in the
y-value from 0 to 1 at (0, 0, 4, 6) changes z from 0 to 5.) Note, however, that the
feasibility constraints impose different limits on how much each of the variables
may increase. In our example, in particular, the choice of the y-variable over the
x-variable leads to a smaller increase in the value of the objective function. Still,
we will employ this commonly used rule and select variable y as we continue with
our example. A new basic variable is called the entering variable, while its column
is referred to as the pivot column; we mark the pivot column by  .
Now we will explain how to choose a departing variable, i.e., a basic variable
to become nonbasic in the next tableau. (The total number of basic variables in any
basic solution must be equal to m, the number of the equality constraints.) As we
saw above, to get to an adjacent extreme point with a larger value of the objective
function, we need to increase the entering variable by the largest amount possible
to make one of the old basic variables zero while preserving the nonnegativity
of all the others. We can translate this observation into the following rule for
choosing a departing variable in a simplex tableau: for each positive entry in the
pivot column, compute the  -ratio by dividing the row's last entry by the entry in
the pivot column. For the example of tableau (10.5), these  -ratios are
                      u  =  4  =  4,       v  =  6  =  2.
                            1                    3
The row with the smallest  -ratio determines the departing variable, i.e., the
variable to become nonbasic. Ties may be broken arbitrarily. For our example, it is
variable v. We mark the row of the departing variable, called the pivot row, by -
and denote it ro--w-. Note that if there are no positive entries in the pivot column,
no -ratio can be computed, which indicates that the problem is unbounded and
the algorithm stops.
Finally, the following steps need to be taken to transform a current tableau
into the next one. (This transformation, called pivoting, is similar to the princi-
pal step of the Gauss-Jordan elimination algorithm for solving systems of linear
equations--see Problem 8 in Exercises 6.2.) First, divide all the entries of the pivot
row by the pivot, its entry in the pivot column, to obtain ro--w-new. For tableau (10.5),
we obtain
                      ro--w-new:  1     1  0     1  2.
                                  3              3
Then, replace each of the other rows, including the objective row, by the difference
                            row - c . ro--w-new,
where c is the row's entry in the pivot column. For tableau (10.5), this yields
                            row 1 - 1 . ro--w-new:     2      0  1      -  1    2,
                                                       3                   3
                 row 3 - (-5) . ro--w-new:             -4     0  0         5    10.
                                                       3                   3
     Thus,  the  simplex method transforms tableau         (10.5)   into   the  following  tableau:
                                 x  y               u      v
                 u               2  0               1  ­   1        2
                                 3                         3
                 y               1  1               0      1        2                      (10.6)
                                 3                         3
                            ­    4  0               0      5        10
                                 3                         3
     Tableau (10.6) represents the basic feasible solution (0, 2, 2, 0) with an increased
     value of the objective function, which is equal to 10. It is not optimal, however
     (why?).
     The next iteration--do it yourself as a good exercise!--yields tableau (10.7):
                                 x  y               u      v
                 x               1  0               3  ­   1        3
                                                    2      2
                 y               0  1  ­            1      1        1                      (10.7)
                                                    2      2
                                 0  0               2      1        14
     This tableau represents the basic feasible solution (3, 1, 0, 0). It is optimal because
     all the entries in the objective row of tableau (10.7) are nonnegative. The maximal
     value of the objective function is equal to 14, the last entry in the objective row.
     Let us summarize the steps of the simplex method.
     Summary of the simplex method
     Step 0      Initialization     Present a given linear programming problem in stan-
                 dard form and set up an initial tableau with nonnegative entries in the
                 rightmost column and m other columns composing the m × m identity
                 matrix. (Entries in the objective row are to be disregarded in verifying
                 these requirements.) These m columns define the basic variables of the
                 initial basic feasible solution, used as the labels of the tableau's rows.
     Step 1 Optimality test         If all the entries in the objective row (except, possibly,
                 the one in the rightmost column, which represents the value of the
        objective function) are nonnegative--stop: the tableau represents an
        optimal solution whose basic variables' values are in the rightmost
        column and the remaining, nonbasic variables' values are zeros.
Step 2  Finding the entering variable   Select a negative entry from among the
        first n elements of the objective row. (A commonly used rule is to select
        the negative entry with the largest absolute value, with ties broken
        arbitrarily.) Mark its column to indicate the entering variable and the
        pivot column.
Step 3  Finding the departing variable  For each positive entry in the pivot
        column, calculate the  -ratio by dividing that row's entry in the right-
        most column by its entry in the pivot column. (If all the entries in the
        pivot column are negative or zero, the problem is unbounded--stop.)
        Find the row with the smallest -ratio (ties may be broken arbitrarily),
        and mark this row to indicate the departing variable and the pivot row.
Step 4  Forming the next tableau       Divide all the entries in the pivot row by
        its entry in the pivot column. Subtract from each of the other rows,
        including the objective row, the new pivot row multiplied by the entry
        in the pivot column of the row in question. (This will make all the
        entries in the pivot column 0's except for 1 in the pivot row.) Replace
        the label of the pivot row by the variable's name of the pivot column
        and go back to Step 1.

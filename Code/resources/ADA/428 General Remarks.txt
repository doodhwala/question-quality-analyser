From a more general perspective, most backtracking algorithms fit the follow-
     ing description. An output of a backtracking algorithm can be thought of as an
     n-tuple (x1, x2, . . . , xn) where each coordinate xi is an element of some finite lin-
early ordered set Si. For example, for the n-queens problem, each Si is the set
of integers (column numbers) 1 through n. The tuple may need to satisfy some
additional constraints (e.g., the nonattacking requirements in the n-queens prob-
lem). Depending on the problem, all solution tuples can be of the same length
(the n-queens and the Hamiltonian circuit problem) and of different lengths (the
subset-sum problem). A backtracking algorithm generates, explicitly or implic-
itly, a state-space tree; its nodes represent partially constructed tuples with the
first i coordinates defined by the earlier actions of the algorithm. If such a tuple
(x1, x2, . . . , xi) is not a solution, the algorithm finds the next element in Si+1 that
is consistent with the values of (x1, x2, . . . , xi) and the problem's constraints, and
adds it to the tuple as its (i + 1)st coordinate. If such an element does not exist,
the algorithm backtracks to consider the next value of xi, and so on.
To start a backtracking algorithm, the following pseudocode can be called for
i = 0 ; X[1..0] represents the empty tuple.
ALGORITHM  Backtrack(X[1..i ] )
//Gives a template of a generic backtracking algorithm
//Input: X[1..i] specifies first i promising components of a solution
//Output: All the tuples representing the problem's solutions
if X[1..i] is a solution write X[1..i]
else  //see Problem 9 in this section's exercises
      for each element x  Si+1 consistent with X[1..i] and the constraints do
      X[i + 1]  x
      Backtrack(X[1..i + 1])
Our success in solving small instances of three difficult problems earlier in
this section should not lead you to the false conclusion that backtracking is a
very efficient technique. In the worst case, it may have to generate all possible
candidates in an exponentially (or faster) growing state space of the problem at
hand. The hope, of course, is that a backtracking algorithm will be able to prune
enough branches of its state-space tree before running out of time or memory or
both. The success of this strategy is known to vary widely, not only from problem
to problem but also from one instance to another of the same problem.
There are several tricks that might help reduce the size of a state-space tree.
One is to exploit the symmetry often present in combinatorial problems. For
example, the board of the n-queens problem has several symmetries so that some
solutions can be obtained from others by reflection or rotation. This implies, in
particular, that we need not consider placements of the first queen in the last  n/2
columns, because any solution with the first queen in square (1, i),   n/2        i  n,
can be obtained by reflection (which?) from a solution with the first queen in
square (1, n - i + 1). This observation cuts the size of the tree by about half.
Another trick is to preassign values to one or more components of a solution,
as we did in the Hamiltonian circuit example. Data presorting in the subset-sum
     example demonstrates potential benefits of yet another opportunity: rearrange
     data of an instance given.
         It would be highly desirable to be able to estimate the size of the state-space
     tree of a backtracking algorithm. As a rule, this is too difficult to do analytically,
     however. Knuth [Knu75] suggested generating a random path from the root to
     a leaf and using the information about the number of choices available during
     the path generation for estimating the size of the tree. Specifically, let c1 be the
     number of values of the first component x1 that are consistent with the problem's
     constraints. We randomly select one of these values (with equal probability 1/c1)
     to move to one of the root's c1 children. Repeating this operation for c2 possible
     values for x2 that are consistent with x1 and the other constraints, we move to one
     of the c2 children of that node. We continue this process until a leaf is reached
     after randomly selecting values for x1, x2, . . . , xn. By assuming that the nodes on
     level i have ci children on average, we estimate the number of nodes in the tree as
                                 1 + c1 + c1c2 + . . . + c1c2 . . . cn.
     Generating several such estimates and computing their average yields a useful
     estimation of the actual size of the tree, although the standard deviation of this
     random variable can be large.
         In conclusion, three things on behalf of backtracking need to be said. First, it
     is typically applied to difficult combinatorial problems for which no efficient algo-
     rithms for finding exact solutions possibly exist. Second, unlike the exhaustive-
     search approach, which is doomed to be extremely slow for all instances of a
     problem, backtracking at least holds a hope for solving some instances of nontriv-
     ial sizes in an acceptable amount of time. This is especially true for optimization
     problems, for which the idea of backtracking can be further enhanced by evaluat-
     ing the quality of partially constructed solutions. How this can be done is explained
     in the next section. Third, even if backtracking does not eliminate any elements
     of a problem's state space and ends up generating all its elements, it provides a
     specific technique for doing so, which can be of value in its own right.
     Exercises 12.1
     1.  a.  Continue the backtracking search for a solution to the four-queens prob-
             lem, which was started in this section, to find the second solution to the
             problem.
         b.  Explain how the board's symmetry can be used to find the second solution
             to the four-queens problem.
     2.  a.  Which is the last solution to the five-queens problem found by the back-
             tracking algorithm?
         b.  Use the board's symmetry to find at least four other solutions to the
             problem.
3.   a.  Implement the backtracking algorithm for the n-queens problem in the lan-
         guage of your choice. Run your program for a sample of n values to get the
         numbers of nodes in the algorithm's state-space trees. Compare these num-
         bers with the numbers of candidate solutions generated by the exhaustive-
         search algorithm for this problem (see Problem 9 in Exercises 3.4).
     b.  For each value of n for which you run your program in part (a), estimate
         the size of the state-space tree by the method described in Section 12.1 and
         compare the estimate with the actual number of nodes you obtained.
4.   Design a linear-time algorithm that finds a solution to the n-queens problem
     for any n  4.
5.   Apply backtracking to the problem of finding a Hamiltonian circuit in the
     following graph.
                                 a                       b
                       c                        d           e
                                 f                       g
6.   Apply backtracking to solve the 3-coloring problem for the graph in Fig-
     ure 12.3a.
7.   Generate all permutations of {1, 2, 3, 4} by backtracking.
8.   a.  Apply backtracking to solve the following instance of the subset sum
         problem: A = {1, 3, 4, 5} and d = 11.
     b.  Will the backtracking algorithm work correctly if we use just one of the
         two inequalities to terminate a node as nonpromising?
9.   The general template for backtracking algorithms, which is given in the sec-
     tion, works correctly only if no solution is a prefix to another solution to the
     problem. Change the template's pseudocode to work correctly without this
     restriction.
10.  Write a program implementing a backtracking algorithm for
     a.  the Hamiltonian circuit problem.
     b. the m-coloring problem.
11.  Puzzle pegs    This puzzle-like game is played on a board with 15 small holes
     arranged in an equilateral triangle. In an initial position, all but one of the
     holes are occupied by pegs, as in the example shown below. A legal move is
     a jump of a peg over its immediate neighbor into an empty square opposite;
     the jump removes the jumped-over neighbor from the board.
           Design and implement a backtracking algorithm for solving the following
           versions of this puzzle.
           a.  Starting with a given location of the empty hole, find a shortest sequence
               of moves that eliminates 14 pegs with no limitations on the final position
               of the remaining peg.
           b.  Starting with a given location of the empty hole, find a shortest sequence
               of moves that eliminates 14 pegs with the remaining peg at the empty hole
               of the initial board.
     
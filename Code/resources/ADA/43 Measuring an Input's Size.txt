Let's start with the obvious observation that almost all algorithms run longer on
    larger inputs. For example, it takes longer to sort larger arrays, multiply larger
    matrices, and so on. Therefore, it is logical to investigate an algorithm's efficiency
    as a function of some parameter n indicating the algorithm's input size.1 In most
    cases, selecting such a parameter is quite straightforward. For example, it will be
    the size of the list for problems of sorting, searching, finding the list's smallest
    element, and most other problems dealing with lists. For the problem of evaluating
    a polynomial p(x) = anxn + . . . + a0 of degree n, it will be the polynomial's degree
    or the number of its coefficients, which is larger by 1 than its degree. You'll see from
    the discussion that such a minor difference is inconsequential for the efficiency
    analysis.
    There are situations, of course, where the choice of a parameter indicating
    an input size does matter. One such example is computing the product of two
    n × n matrices. There are two natural measures of size for this problem. The first
    and more frequently used is the matrix order n. But the other natural contender
    is the total number of elements N in the matrices being multiplied. (The latter
    is also more general since it is applicable to matrices that are not necessarily
    square.) Since there is a simple formula relating these two measures, we can easily
    switch from one to the other, but the answer about an algorithm's efficiency will
    be qualitatively different depending on which of these two measures we use (see
    Problem 2 in this section's exercises).
    The choice of an appropriate size metric can be influenced by operations of
    the algorithm in question. For example, how should we measure an input's size
    for a spell-checking algorithm? If the algorithm examines individual characters of
    its input, we should measure the size by the number of characters; if it works by
    processing words, we should count their number in the input.
    We should make a special note about measuring input size for algorithms
    solving problems such as checking primality of a positive integer n. Here, the input
    is just one number, and it is this number's magnitude that determines the input
1.  Some algorithms require more than one parameter to indicate the size of their inputs (e.g., the number
    of vertices and the number of edges for algorithms on graphs represented by their adjacency lists).
        size. In such situations, it is preferable to measure size by the number b of bits in
        the n's binary representation:
                                        b=      log2 n  + 1.                      (2.1)
        This metric usually gives a better idea about the efficiency of algorithms in ques-
        tion.

As we pointed out in Section 1.3, many problems can be solved by a reduction
     to one of the standard graph problems. This is true, in particular, for a variety of
     puzzles and games. In these applications, vertices of a graph typically represent
     possible states of the problem in question, and edges indicate permitted transi-
     tions among such states. One of the graph's vertices represents an initial state and
     another represents a goal state of the problem. (There might be several vertices
     of the latter kind.) Such a graph is called a state-space graph. Thus, the transfor-
     mation just described reduces the problem to the question about a path from the
     initial-state vertex to a goal-state vertex.
                          Pwgc | |        Pg        wc | | Pg
                                          P
                          Pwc | | g       Pw        c | | Pwg
                                          Pc   Pg
                          Pgc | | w                 w | | Pgc
                                          Pc   Pg
                          Pwg | | c       Pw        g | | Pwc
                                          P
                          Pg | | wc       Pg        | | Pwgc
FIGURE 6.18  State-space  graph for  the  peasant,  wolf, goat,  and  cabbage  puzzle.
EXAMPLE      Let us revisit the classic river-crossing puzzle that was included in
the exercises for Section 1.2. A peasant finds himself on a river bank with a wolf,
a goat, and a head of cabbage. He needs to transport all three to the other side
of the river in his boat. However, the boat has room only for the peasant himself
and one other item (either the wolf, the goat, or the cabbage). In his absence, the
wolf would eat the goat, and the goat would eat the cabbage. Find a way for the
peasant to solve his problem or prove that it has no solution.
The state-space graph for this problem is given in Figure 6.18. Its vertices are
labeled to indicate the states they represent: P, w, g, c stand for the peasant, the
wolf, the goat, and the cabbage, respectively; the two bars | | denote the river;
for convenience, we also label the edges by indicating the boat's occupants for
each crossing. In terms of this graph, we are interested in finding a path from the
initial-state vertex labeled Pwgc| | to the final-state vertex labeled | |Pwgc.
It is easy to see that there exist two distinct simple paths from the initial-
state vertex to the final state vertex (what are they?). If we find them by applying
breadth-first search, we get a formal proof that these paths have the smallest
number of edges possible. Hence, this puzzle has two solutions requiring seven
river crossings, which is the minimum number of crossings needed.
Our success in solving this simple puzzle should not lead you to believe that
generating and investigating state-space graphs is always a straightforward task.
To get a better appreciation of them, consult books on artificial intelligence (AI),
the branch of computer science in which state-space graphs are a principal subject.
     In this book, we deal with an important special case of state-space graphs in
     Sections 12.1 and 12.2.
     Exercises 6.6
     1.  a.  Prove the equality
                                   lcm(m, n) =  m.n
                                                gcd(m, n)
             that underlies the algorithm for computing lcm(m, n).
         b.  Euclid's algorithm is known to be in O(log n). If it is the algorithm that is
             used for computing gcd(m, n), what is the efficiency of the algorithm for
             computing lcm(m, n)?
     2.  You are given a list of numbers for which you need to construct a min-heap.
         (A min-heap is a complete binary tree in which every key is less than or equal
         to the keys in its children.) How would you use an algorithm for constructing
         a max-heap (a heap as defined in Section 6.4) to construct a min-heap?
     3.  Prove that the number of different paths of length k > 0 from the ith vertex to
         the j th vertex in a graph (undirected or directed) equals the (i, j )th element
         of Ak where A is the adjacency matrix of the graph.
     4.  a.  Design an algorithm with a time efficiency better than cubic for checking
             whether a graph with n vertices contains a cycle of length 3 [Man89].
         b.  Consider the following algorithm for the same problem. Starting at an arbi-
             trary vertex, traverse the graph by depth-first search and check whether its
             depth-first search forest has a vertex with a back edge leading to its grand-
             parent. If it does, the graph contains a triangle; if it does not, the graph
             does not contain a triangle as its subgraph. Is this algorithm correct?
     5.  Given n > 3 points P1 = (x1, y1), . . . , Pn = (xn, yn) in the coordinate plane,
         design an algorithm to check whether all the points lie within a triangle with
         its vertices at three of the points given. (You can either design an algorithm
         from scratch or reduce the problem to another one with a known algorithm.)
     6.  Consider the problem of finding, for a given positive integer n, the pair of
         integers whose sum is n and whose product is as large as possible. Design an
         efficient algorithm for this problem and indicate its efficiency class.
     7.  The assignment problem introduced in Section 3.4 can be stated as follows:
         There are n people who need to be assigned to execute n jobs, one person
         per job. (That is, each person is assigned to exactly one job and each job is
         assigned to exactly one person.) The cost that would accrue if the ith person is
         assigned to the j th job is a known quantity C[i, j ] for each pair i, j = 1, . . . , n.
         The problem is to assign the people to the jobs to minimize the total cost of
     the assignment. Express the assignment problem as a 0-1 linear programming
     problem.
8.   Solve the instance of the linear programming problem given in Section 6.6:
                              maximize    0.10x + 0.07y + 0.03z
                              subject to  x + y + z = 100
                                          x    1  y
                                               3
                                          z  0.25(x + y)
                                          x  0,      y  0,  z  0.
9.   The graph-coloring problem is usually stated as the vertex-coloring prob-
     lem: Assign the smallest number of colors to vertices of a given graph so
     that no two adjacent vertices are the same color. Consider the edge-coloring
     problem: Assign the smallest number of colors possible to edges of a given
     graph so that no two edges with the same endpoint are the same color. Ex-
     plain how the edge-coloring problem can be reduced to a vertex-coloring
     problem.
10.  Consider the two-dimensional post office location problem: given n points
     (x1, y1), . . . , (xn, yn) in the Cartesian plane, find a location (x, y) for a post
                              1  ni=1(|xi - x| + |yi - y|), the average Manhattan dis-
     office  that  minimizes
                              n
     tance from the post office to these points. Explain how this problem can be
     efficiently solved by the problem reduction technique, provided the post office
     does not have to be located at one of the input points.
11.  Jealous husbands   There are n  2 married couples who need to cross a
     river. They have a boat that can hold no more than two people at a time.
     To complicate matters, all the husbands are jealous and will not agree on any
     crossing procedure that would put a wife on the same bank of the river with
     another woman's husband without the wife's husband being there too, even if
     there are other people on the same bank. Can they cross the river under such
     constraints?
     a.  Solve the problem for n = 2.
     b. Solve the problem for n = 3, which is the classical version of this problem.
     c.  Does the problem have a solution for n  4? If it does, indicate how many
         river crossings it will take; if it does not, explain why.
12.  Double-n dominoes        Dominoes are small rectangular tiles with dots called
     spots or pips embossed at both halves of the tiles. A standard "double-six"
     domino set has 28 tiles: one for each unordered pair of integers from (0, 0)
     to (6, 6). In general, a "double-n" domino set would consist of domino tiles
     for each unordered pair of integers from (0, 0) to (n, n). Determine all values
     of n for which one constructs a ring made up of all the tiles in a double-n
     domino set.
     SUMMARY
     Transform-and-conquer is the fourth general algorithm design (and problem-
     solving) strategy discussed in the book. It is, in fact, a group of techniques
     based on the idea of transformation to a problem that is easier to solve.
     There are three principal varieties of the transform-and-conquer strategy:
     instance simplification, representation change, and problem reduction.
     Instance simplification is transforming an instance of a problem to an instance
     of the same problem with some special property that makes the problem
     easier to solve. List presorting, Gaussian elimination, and rotations in AVL
     trees are good examples of this strategy.
     Representation change implies changing one representation of a problem's
     instance to another representation of the same instance. Examples discussed
     in this chapter include representation of a set by a 2-3 tree, heaps and heapsort,
     Horner's rule for polynomial evaluation, and two binary exponentiation
     algorithms.
     Problem reduction calls for transforming a given problem to another problem
     that can be solved by a known algorithm. Among examples of applying this
     idea to algorithmic problem solving (see Section 6.6), reductions to linear
     programming and reductions to graph problems are especially important.
     Some examples used to illustrate transform-and-conquer happen to be very
     important data structures and algorithms. They are: heaps and heapsort, AVL
     and 2-3 trees, Gaussian elimination, and Horner's rule.
     A heap is an essentially complete binary tree with keys (one per node)
     satisfying the parental dominance requirement. Though defined as binary
     trees, heaps are normally implemented as arrays. Heaps are most important
     for the efficient implementation of priority queues; they also underlie
     heapsort.
     Heapsort is a theoretically important sorting algorithm based on arranging
     elements of an array in a heap and then successively removing the largest
     element from a remaining heap. The algorithm's running time is in             (n log n)
     both in the worst case and in the average case; in addition, it is in-place.
     AVL trees are binary search trees that are always balanced to the extent
     possible for a binary tree. The balance is maintained by transformations of
     four types called rotations. All basic operations on AVL trees are in O(log n);
     it eliminates the bad worst-case efficiency of classic binary search trees.
     2-3 trees achieve a perfect balance in a search tree by allowing a node to
     contain up to two ordered keys and have up to three children. This idea can
     be generalized to yield very important B-trees, discussed later in the book.
Gaussian elimination--an algorithm for solving systems of linear equations--
is a principal algorithm in linear algebra. It solves a system by transforming it
to an equivalent system with an upper-triangular coefficient matrix, which is
easy  to  solve  by  back  substitutions.  Gaussian  elimination  requires  about    1  n3
multiplications.                                                                     3
Horner's rule is an optimal algorithm for polynomial evaluation without
coefficient preprocessing. It requires only n multiplications and n additions
to evaluate an n-degree polynomial at a given point. Horner's rule also has a
few useful byproducts, such as the synthetic division algorithm.
Two binary exponentiation algorithms for computing an are introduced in
Section 6.5. Both of them exploit the binary representation of the exponent
n, but they process it in the opposite directions: left to right and right to left.
Linear programming concerns optimizing a linear function of several vari-
ables subject to constraints in the form of linear equations and linear inequal-
ities. There are efficient algorithms capable of solving very large instances
of this problem with many thousands of variables and constraints, provided
the variables are not required to be integers. The latter, called integer linear
programming, constitute a much more difficult class of problems.


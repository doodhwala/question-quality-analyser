We will be able to apply the branch-and-bound technique to instances of the
     traveling salesman problem if we come up with a reasonable lower bound on tour
     lengths. One very simple lower bound can be obtained by finding the smallest
     element in the intercity distance matrix D and multiplying it by the number of
     cities n. But there is a less obvious and more informative lower bound for instances
     with symmetric matrix D, which does not require a lot of work to compute. It is
     not difficult to show (Problem 8 in this section's exercises) that we can compute a
     lower bound on the length l of any tour as follows. For each city i, 1  i  n, find
     the sum si of the distances from city i to the two nearest cities; compute the sum
     s of these n numbers, divide the result by 2, and, if all the distances are integers,
     round up the result to the nearest integer:
                                       lb =       s/2 .                           (12.2)
     For example, for the instance in Figure 12.9a, formula (12.2) yields
     lb =         [(1 + 3) + (3 + 6) + (1 + 2) + (3 + 4) + (2 + 3)]/2      = 14.
     Moreover, for any subset of tours that must include particular edges of a given
     graph, we can modify lower bound (12.2) accordingly. For example, for all the
     Hamiltonian circuits of the graph in Figure 12.9a that must include edge (a, d),
     we get the following lower bound by summing up the lengths of the two shortest
     edges incident with each of the vertices, with the required inclusion of edges (a, d)
     and (d, a):
                  [(1 + 5) + (3 + 6) + (1 + 2) + (3 + 5) + (2 + 3)]/2      = 16.
     We now apply the branch-and-bound algorithm, with the bounding function
     given by formula (12.2), to find the shortest Hamiltonian circuit for the graph in
   a        3          b                                                                 0
                                                                                         a
                                                                                     lb  =  14
         5       6
8  1                      7         9
                                                         1                       2              3           4
            4                                            a, b                  a, c             a, d        a, e
   c                   d                             lb = 14                                    lb = 16     lb = 19
                                                                                 X              X           X
                                                                          b is not
      2             3                                                                           lb >= l     lb > l
                                                                          before c
            e                                                                                   of node 11  of node 11
                                       5                     6                   7
            (a)                        a, b, c       a, b, d              a, b, e
                                       lb = 16       lb = 16              lb = 19
                                                                               X
                                                                          lb > l
                                                                    of node 11
                          8                     9    10             11
                       a, b, c, d,     a, b, c, e,   a, b, d, c,    a, b, d, e,
                       (e, a)             (d, a)     (e, a)         (c, a)
                       l = 24             l = 19     l = 24         l = 16
                       first tour      better tour   inferior tour  optimal tour
                                                                          (b)
                 FIGURE 12.9           (a) Weighted graph. (b) State-space tree of the branch-and-bound algorithm
                                       to find a shortest Hamiltonian circuit in this graph. The list of vertices in
                                       a node specifies a beginning part of the Hamiltonian circuits represented
                                       by the node.
                 Figure 12.9a. To reduce the amount of potential work, we take advantage of two
                 observations made in Section 3.4. First, without loss of generality, we can consider
                 only tours that start at a. Second, because our graph is undirected, we can generate
                 only tours in which b is visited before c. In addition, after visiting n - 1 = 4 cities,
                 a tour has no choice but to visit the remaining unvisited city and return to the
                 starting one. The state-space tree tracing the algorithm's application is given in
                 Figure 12.9b.
                       The comments we made at the end of the preceding section about the strengths
                 and weaknesses of backtracking are applicable to branch-and-bound as well. To
                 reiterate the main point: these state-space tree techniques enable us to solve
                 many large instances of difficult combinatorial problems. As a rule, however, it is
                 virtually impossible to predict which instances will be solvable in a realistic amount
                 of time and which will not.
                       Incorporation of additional information, such as a symmetry of a game's
                 board, can widen the range of solvable instances. Along this line, a branch-and-
                 bound algorithm can be sometimes accelerated by a knowledge of the objective
     function's value of some nontrivial feasible solution. The information might be
     obtainable--say, by exploiting specifics of the data or even, for some problems,
     generated randomly--before we start developing a state-space tree. Then we can
     use such a solution immediately as the best one seen so far rather than waiting for
     the branch-and-bound processing to lead us to the first feasible solution.
         In contrast to backtracking, solving a problem by branch-and-bound has both
     the challenge and opportunity of choosing the order of node generation and find-
     ing a good bounding function. Though the best-first rule we used above is a sensible
     approach, it may or may not lead to a solution faster than other strategies. (Arti-
     ficial intelligence researchers are particularly interested in different strategies for
     developing state-space trees.)
         Finding a good bounding function is usually not a simple task. On the one
     hand, we want this function to be easy to compute. On the other hand, it cannot
     be too simplistic--otherwise, it would fail in its principal task to prune as many
     branches of a state-space tree as soon as possible. Striking a proper balance be-
     tween these two competing requirements may require intensive experimentation
     with a wide variety of instances of the problem in question.
     Exercises 12.2
     1.  What data structure would you use to keep track of live nodes in a best-first
         branch-and-bound algorithm?
     2.  Solve the same instance of the assignment problem as the one solved in
         the section by the best-first branch-and-bound algorithm with the bounding
         function based on matrix columns rather than rows.
     3.  a.  Give an example of the best-case input for the branch-and-bound algo-
             rithm for the assignment problem.
         b. In the best case, how many nodes will be in the state-space tree of the
             branch-and-bound algorithm for the assignment problem?
     4.  Write a program for solving the assignment problem by the branch-and-bound
         algorithm. Experiment with your program to determine the average size of the
         cost matrices for which the problem is solved in a given amount of time, say,
         1 minute on your computer.
     5.  Solve the following instance of the knapsack problem by the branch-and-
         bound algorithm:
                           item      weight          value
                           1          10             $100
                           2          7              $63           W = 16
                           3          8              $56
                           4          4              $12
      6.   a.  Suggest a more sophisticated bounding function for solving the knapsack
               problem than the one used in the section.
           b. Use your bounding function in the branch-and-bound algorithm applied
               to the instance of Problem 5.
      7.   Write a program to solve the knapsack problem with the branch-and-bound
           algorithm.
      8.   a.  Prove the validity of the lower bound given by formula (12.2) for instances
               of the traveling salesman problem with symmetric matrices of integer
               intercity distances.
           b. How would you modify lower bound (12.2) for nonsymmetric distance
               matrices?
      9.   Apply the branch-and-bound algorithm to solve the traveling salesman prob-
           lem for the following graph:
                                            a                   2     b
                                         5     8                   7     3
                                            c                         d
                                                                1
           (We solved this problem by exhaustive search in Section 3.4.)
      10.  As a research project, write a report on how state-space trees are used for
           programming such games as chess, checkers, and tic-tac-toe. The two principal
           algorithms you should read about are the minimax algorithm and alpha-beta
           pruning.

Backtracking
Throughout the book (see in particular Sections 3.4 and 11.3), we have encoun-
           tered problems that require finding an element with a special property in a domain
           that grows exponentially fast (or faster) with the size of the problem's input: a
           Hamiltonian circuit among all permutations of a graph's vertices, the most valu-
           able subset of items for an instance of the knapsack problem, and the like. We
           addressed in Section 11.3 the reasons for believing that many such problems might
           not be solvable in polynomial time. Also recall that we discussed in Section 3.4
           how such problems can be solved, at least in principle, by exhaustive search. The
           exhaustive-search technique suggests generating all candidate solutions and then
           identifying the one (or the ones) with a desired property.
           Backtracking is a more intelligent variation of this approach. The principal
           idea is to construct solutions one component at a time and evaluate such partially
           constructed candidates as follows. If a partially constructed solution can be de-
           veloped further without violating the problem's constraints, it is done by taking
           the first remaining legitimate option for the next component. If there is no legiti-
           mate option for the next component, no alternatives for any remaining component
           need to be considered. In this case, the algorithm backtracks to replace the last
           component of the partially constructed solution with its next option.
           It is convenient to implement this kind of processing by constructing a tree
           of choices being made, called the state-space tree. Its root represents an initial
           state before the search for a solution begins. The nodes of the first level in the
           tree represent the choices made for the first component of a solution, the nodes
           of the second level represent the choices for the second component, and so
           on. A node in a state-space tree is said to be promising if it corresponds to a
           partially constructed solution that may still lead to a complete solution; otherwise,
it is called nonpromising. Leaves represent either nonpromising dead ends or
complete solutions found by the algorithm. In the majority of cases, a state-
space tree for a backtracking algorithm is constructed in the manner of depth-
first search. If the current node is promising, its child is generated by adding the
first remaining legitimate option for the next component of a solution, and the
processing moves to this child. If the current node turns out to be nonpromising,
the algorithm backtracks to the node's parent to consider the next possible option
for its last component; if there is no such option, it backtracks one more level up
the tree, and so on. Finally, if the algorithm reaches a complete solution to the
problem, it either stops (if just one solution is required) or continues searching
for other possible solutions.

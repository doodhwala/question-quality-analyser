We start with permutations. For simplicity, we assume that the underlying set
          whose elements need to be permuted is simply the set of integers from 1 to n;
          more generally, they can be interpreted as indices of elements in an n-element set
          {a1, . . . , an}. What would the decrease-by-one technique suggest for the problem
          of generating all n! permutations of {1, . . . , n}? The smaller-by-one problem is to
          generate all (n - 1)! permutations. Assuming that the smaller problem is solved,
          we can get a solution to the larger one by inserting n in each of the n possible
          positions among elements of every permutation of n - 1 elements. All the permu-
          tations obtained in this fashion will be distinct (why?), and their total number will
          be n(n - 1)! = n!. Hence, we will obtain all the permutations of {1, . . . , n}.
          We can insert n in the previously generated permutations either left to right
          or right to left. It turns out that it is beneficial to start with inserting n into
          12 . . . (n - 1) by moving right to left and then switch direction every time a new
          permutation of {1, . . . , n - 1} needs to be processed. An example of applying this
          approach bottom up for n = 3 is given in Figure 4.9.
          The advantage of this order of generating permutations stems from the fact
          that it satisfies the minimal-change requirement: each permutation can be ob-
          tained from its immediate predecessor by exchanging just two elements in it. (For
          the method being discussed, these two elements are always adjacent to each other.
                          start                                1
                          insert 2 into 1 right to left        12  21
                          insert 3 into 12 right to left  123      132  312
                          insert 3 into 21 left to right  321      231  213
          FIGURE 4.9  Generating permutations bottom      up.
Check this for the permutations generated in Figure 4.9.) The minimal-change re-
quirement is beneficial both for the algorithm's speed and for applications using
the permutations. For example, in Section 3.4, we needed permutations of cities
to solve the traveling salesman problem by exhaustive search. If such permuta-
tions are generated by a minimal-change algorithm, we can compute the length of
a new tour from the length of its predecessor in constant rather than linear time
(how?).
    It is possible to get the same ordering of permutations of n elements without
explicitly generating permutations for smaller values of n. It can be done by
associating a direction with each element k in a permutation. We indicate such
a direction by a small arrow written above the element in question, e.g.,
                                   
                                   3 2 4 1.
The element k is said to be mobile in such an arrow-marked permutation if its
arrow points to a smaller number adjacent to it. For example, for the permutation
3 2 4 1, 3 and 4 are mobile while 2 and 1 are not. Using the notion of a mobile
element, we can give the following description of the Johnson-Trotter algorithm
for generating permutations.
ALGORITHM       JohnsonTrotter(n)
    //Implements Johnson-Trotter algorithm for generating permutations
    //Input: A positive integer n
    //Output: A list of all permutations of {1, . . . , n}
                                                       
    initialize the first permutation with 1 2 . . . n
    while the last permutation has a mobile element do
         find its largest mobile element k
         swap k with the adjacent element k's arrow points to
         reverse the direction of all the elements that are larger than k
         add the new permutation to the list
    Here is an  application of this algorithm for n = 3,      with the  largest  mobile
element shown   in bold:
                                                              
                123       132      312      321          231  2 1 3.
    This algorithm is one of the most efficient for generating permutations; it can
be implemented to run in time proportional to the number of permutations, i.e.,
in  (n!). Of course, it is horribly slow for all but very small values of n; however,
this is not the algorithm's "fault" but rather the fault of the problem: it simply asks
to generate too many items.
    One can argue that the permutation ordering generated by the Johnson-
Trotter algorithm is not quite natural; for example, the natural place for permu-
tation n(n - 1) . . . 1 seems to be the last one on the list. This would be the case
if permutations were listed in increasing order--also called the lexicographic or-
     der--which is the order in which they would be listed in a dictionary if the numbers
     were interpreted as letters of an alphabet. For example, for n = 3,
                           123  132  213  231              312  321.
     So how can we generate the permutation following a1a2 . . . an-1an in lexi-
     cographic order? If an-1 < an, which is the case for exactly one half of all the
     permutations, we can simply transpose these last two elements. For example, 123
     is followed by 132. If an-1 > an, we find the permutation's longest decreasing suffix
     ai+1 > ai+2 > . . . > an (but ai < ai+1); increase ai by exchanging it with the smallest
     element of the suffix that is greater than ai; and reverse the new suffix to put it in
     increasing order. For example, 362541 is followed by 364125. Here is pseudocode
     of this simple algorithm whose origins go as far back as 14th-century India.
     ALGORITHM  LexicographicPermute(n)
     //Generates permutations in lexicographic order
     //Input: A positive integer n
     //Output: A list of all permutations of {1, . . . , n} in lexicographic order
     initialize the first permutation with 12 . . . n
     while last permutation has two consecutive elements in increasing order                       do
     let i be its largest index such that ai < ai+1             //ai+1 > ai+2 > . . . > an
     find the largest index j such that ai < aj                 //j  i + 1 since ai < ai+1
     swap ai with aj       //ai+1ai+2 . . . an will remain in decreasing order
     reverse the order of the elements from ai+1 to an inclusive
     add the new permutation to the list

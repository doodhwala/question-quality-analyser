The sorting problem is to rearrange the items of a given list in nondecreasing
order. Of course, for this problem to be meaningful, the nature of the list items
must allow such an ordering. (Mathematicians would say that there must exist
a relation of total ordering.) As a practical matter, we usually need to sort lists
of numbers, characters from an alphabet, character strings, and, most important,
records similar to those maintained by schools about their students, libraries about
their holdings, and companies about their employees. In the case of records, we
need to choose a piece of information to guide sorting. For example, we can choose
to sort student records in alphabetical order of names or by student number or by
student grade-point average. Such a specially chosen piece of information is called
a key. Computer scientists often talk about sorting a list of keys even when the list's
items are not records but, say, just integers.
Why would we want a sorted list? To begin with, a sorted list can be a required
output of a task such as ranking Internet search results or ranking students by their
GPA scores. Further, sorting makes many questions about the list easier to answer.
The most important of them is searching: it is why dictionaries, telephone books,
class lists, and so on are sorted. You will see other examples of the usefulness of
list presorting in Section 6.1. In a similar vein, sorting is used as an auxiliary step
in several important algorithms in other areas, e.g., geometric algorithms and data
compression. The greedy approach--an important algorithm design technique
discussed later in the book--requires a sorted input.
By now, computer scientists have discovered dozens of different sorting algo-
rithms. In fact, inventing a new sorting algorithm has been likened to designing
the proverbial mousetrap. And I am happy to report that the hunt for a better
sorting mousetrap continues. This perseverance is admirable in view of the fol-
lowing facts. On the one hand, there are a few good sorting algorithms that sort
an arbitrary array of size n using about n log2 n comparisons. On the other hand,
no algorithm that sorts by key comparisons (as opposed to, say, comparing small
pieces of keys) can do substantially better than that.
There is a reason for this embarrassment of algorithmic riches in the land
of sorting. Although some algorithms are indeed better than others, there is no
algorithm that would be the best solution in all situations. Some of the algorithms
are simple but relatively slow, while others are faster but more complex; some
work better on randomly ordered inputs, while others do better on almost-sorted
lists; some are suitable only for lists residing in the fast memory, while others can
be adapted for sorting large files stored on a disk; and so on.
Two properties of sorting algorithms deserve special mention. A sorting algo-
rithm is called stable if it preserves the relative order of any two equal elements in
its input. In other words, if an input list contains two equal elements in positions
i and j  where i < j, then in the sorted list they have to be in positions i  and j ,
    respectively, such that i  < j . This property can be desirable if, for example, we
    have a list of students sorted alphabetically and we want to sort it according to
    student GPA: a stable algorithm will yield a list in which students with the same
    GPA will still be sorted alphabetically. Generally speaking, algorithms that can
    exchange keys located far apart are not stable, but they usually work faster; you
    will see how this general comment applies to important sorting algorithms later
    in the book.
    The second notable feature of a sorting algorithm is the amount of extra
    memory the algorithm requires. An algorithm is said to be in-place if it does
    not require extra memory, except, possibly, for a few memory units. There are
    important sorting algorithms that are in-place and those that are not.

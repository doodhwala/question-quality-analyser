A tree (more accurately, a free tree) is a connected acyclic graph (Figure 1.10a).
    A graph that has no cycles but is not necessarily connected is called a forest: each
    of its connected components is a tree (Figure 1.10b).
2.  A subgraph of a given graph G =     V, E  is a graph G =     V ,E  such that V   V and E   E.
                  a           b                 a                  b                    h
                  c           d                 c                  d          e         i
                  f           g                 f                  g                    j
                       (a)                                            (b)
    FIGURE 1.10   (a)  Tree.  (b) Forest.
               i                   d
                                                                                     a
               c                   a         e                             b         d     e
                       b
                                                                      c       g            f
               h       g                     f                h            i
                              (a)                                             (b)
    FIGURE 1.11   (a)  Free   tree. (b) Its  transformation  into  a  rooted  tree.
    Trees have several important properties other graphs do not have. In par-
    ticular, the number of edges in a tree is always one less than the number of its
    vertices:
                                             |E| = |V | - 1.
    As the graph in Figure 1.9 demonstrates, this property is necessary but not suffi-
    cient for a graph to be a tree. However, for connected graphs it is sufficient and
    hence provides a convenient way of checking whether a connected graph has a
    cycle.
    Rooted Trees       Another very important property of trees is the fact that for every
    two vertices in a tree, there always exists exactly one simple path from one of these
    vertices to the other. This property makes it possible to select an arbitrary vertex
    in a free tree and consider it as the root of the so-called rooted tree. A rooted tree
    is usually depicted by placing its root on the top (level 0 of the tree), the vertices
    adjacent to the root below it (level 1), the vertices two edges apart from the root
    still below (level 2), and so on. Figure 1.11 presents such a transformation from a
    free tree to a rooted tree.
Rooted trees play a very important role in computer science, a much more
important one than free trees do; in fact, for the sake of brevity, they are often
referred to as simply "trees." An obvious application of trees is for describing
hierarchies, from file directories to organizational charts of enterprises. There are
many less obvious applications, such as implementing dictionaries (see below),
efficient access to very large data sets (Section 7.4), and data encoding (Section
9.4). As we discuss in Chapter 2, trees also are helpful in analysis of recursive
algorithms. To finish this far-from-complete list of tree applications, we should
mention the so-called state-space trees that underline two important algorithm
design techniques: backtracking and branch-and-bound (Sections 12.1 and 12.2).
For any vertex v in a tree T , all the vertices on the simple path from the root
to that vertex are called ancestors of v. The vertex itself is usually considered its
own ancestor; the set of ancestors that excludes the vertex itself is referred to as
the set of proper ancestors. If (u, v) is the last edge of the simple path from the
root to vertex v (and u = v), u is said to be the parent of v and v is called a child
of u; vertices that have the same parent are said to be siblings. A vertex with no
children is called a leaf ; a vertex with at least one child is called parental. All the
vertices for which a vertex v is an ancestor are said to be descendants of v; the
proper descendants exclude the vertex v itself. All the descendants of a vertex v
with all the edges connecting them form the subtree of T rooted at that vertex.
Thus, for the tree in Figure 1.11b, the root of the tree is a; vertices d, g, f, h, and i
are leaves, and vertices a, b, e, and c are parental; the parent of b is a; the children
of b are c and g; the siblings of b are d and e; and the vertices of the subtree rooted
at b are {b, c, g, h, i}.
The depth of a vertex v is the length of the simple path from the root to v. The
height of a tree is the length of the longest simple path from the root to a leaf. For
example, the depth of vertex c of the tree in Figure 1.11b is 2, and the height of
the tree is 3. Thus, if we count tree levels top down starting with 0 for the root's
level, the depth of a vertex is simply its level in the tree, and the tree's height is the
maximum level of its vertices. (You should be alert to the fact that some authors
define the height of a tree as the number of levels in it; this makes the height of
a tree larger by 1 than the height defined as the length of the longest simple path
from the root to a leaf.)
Ordered Trees  An ordered tree is a rooted tree in which all the children of each
vertex are ordered. It is convenient to assume that in a tree's diagram, all the
children are ordered left to right.
A binary tree can be defined as an ordered tree in which every vertex has
no more than two children and each child is designated as either a left child or a
right child of its parent; a binary tree may also be empty. An example of a binary
tree is given in Figure 1.12a. The binary tree with its root at the left (right) child
of a vertex in a binary tree is called the left (right) subtree of that vertex. Since
left and right subtrees are binary trees as well, a binary tree can also be defined
recursively. This makes it possible to solve many problems involving binary trees
by recursive algorithms.
                                                                           9
                                                                  5                  12
                                              1                         7        10
                                                               4
                              (a)                                          (b)
    FIGURE 1.12   (a) Binary tree. (b) Binary search tree.
                                                            9
                           5                                                                 12      null
    null    1                       null  7   null                null     10        null
                  null  4     null
    FIGURE  1.13 Standard  implementation of  the binary       search      tree  in  Figure  1.12b.
          In Figure 1.12b, some numbers are assigned to vertices of the binary tree in
    Figure 1.12a. Note that a number assigned to each parental vertex is larger than all
    the numbers in its left subtree and smaller than all the numbers in its right subtree.
    Such trees are called binary search trees. Binary trees and binary search trees have
    a wide variety of applications in computer science; you will encounter some of
    them throughout the book. In particular, binary search trees can be generalized
    to more general types of search trees called multiway search trees, which are
    indispensable for efficient access to very large data sets.
          As you will see later in the book, the efficiency of most important algorithms
    for binary search trees and their extensions depends on the tree's height. There-
    fore, the following inequalities for the height h of a binary tree with n nodes are
    especially important for analysis of such algorithms:
                                    log2 n     h  n - 1.
               A binary tree is usually implemented for computing purposes by a collection
               of nodes corresponding to vertices of the tree. Each node contains some informa-
               tion associated with the vertex (its name or some value assigned to it) and two
               pointers to the nodes representing the left child and right child of the vertex, re-
               spectively. Figure 1.13 illustrates such an implementation for the binary search
               tree in Figure 1.12b.
               A computer representation of an arbitrary ordered tree can be done by simply
               providing a parental vertex with the number of pointers equal to the number of
               its children. This representation may prove to be inconvenient if the number of
               children varies widely among the nodes. We can avoid this inconvenience by using
               nodes with just two pointers, as we did for binary trees. Here, however, the left
               pointer will point to the first child of the vertex, and the right pointer will point
               to its next sibling. Accordingly, this representation is called the first child­next
               sibling representation. Thus, all the siblings of a vertex are linked via the nodes'
               right pointers in a singly linked list, with the first element of the list pointed to
               by the left pointer of their parent. Figure 1.14a illustrates this representation for
               the tree in Figure 1.11b. It is not difficult to see that this representation effectively
               transforms an ordered tree into a binary tree said to be associated with the ordered
               tree. We get this representation by "rotating" the pointers about 45 degrees
               clockwise (see Figure 1.14b).

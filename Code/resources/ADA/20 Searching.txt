The searching problem deals with finding a given value, called a search key, in a
    given set (or a multiset, which permits several elements to have the same value).
    There are plenty of searching algorithms to choose from. They range from the
    straightforward sequential search to a spectacularly efficient but limited binary
    search and algorithms based on representing the underlying set in a different form
    more conducive to searching. The latter algorithms are of particular importance
    for real-world applications because they are indispensable for storing and retriev-
    ing information from large databases.
    For searching, too, there is no single algorithm that fits all situations best.
    Some algorithms work faster than others but require more memory; some are
    very fast but applicable only to sorted arrays; and so on. Unlike with sorting
    algorithms, there is no stability problem, but different issues arise. Specifically,
    in applications where the underlying data may change frequently relative to the
    number of searches, searching has to be considered in conjunction with two other
    operations: an addition to and deletion from the data set of an item. In such
    situations, data structures and algorithms should be chosen to strike a balance
    among the requirements of each operation. Also, organizing very large data sets
    for efficient searching poses special challenges with important implications for
    real-world applications.

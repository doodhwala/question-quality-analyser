Heapsort
Now we can describe heapsort--an interesting sorting algorithm discovered by
                    J. W. J. Williams [Wil64]. This is a two-stage algorithm that works as follows.
                       Stage 1    (heap construction): Construct a heap for a given array.
                       Stage 2    (maximum deletions): Apply the root-deletion operation n - 1 times
                                  to the remaining heap.
                       As a result, the array elements are eliminated in decreasing order. But since
                    under the array implementation of heaps an element being deleted is placed last,
                    the resulting array will be exactly the original array sorted in increasing order.
                    Heapsort is traced on a specific input in Figure 6.14.     (The same input as the one
     Stage   1 (heap           construction)             Stage 2 (maximum        deletions)
        2    9              7  6  5  8                   9     6     8     2     5     7
        2    9              8  6  5  7                   7     6     8     2     5  |  9
        2    9              8  6  5  7                   8     6     7     2     5
        9    2              8  6  5  7                   5     6     7     2  |  8
        9    6              8  2  5  7                   7     6     5     2
                                                         2     6     5  |  7
                                                         6     2     5
                                                         5     2  |  6
                                                         5     2
                                                         2  |  5
                                                         2
     FIGURE 6.14 Sorting the array 2, 9, 7, 6,    5,  8  by heapsort.
     in Figure 6.11 is intentionally used so that you can compare the tree and array
     implementations of the bottom-up heap construction algorithm.)
     Since we already know that the heap construction stage of the algorithm is in
     O(n), we have to investigate just the time efficiency of the second stage. For the
     number of key comparisons, C(n), needed for eliminating the root keys from the
     heaps of diminishing sizes from n to 2, we get the following inequality:
                                                                                          n-1
     C(n)  2 log2(n - 1)          + 2 log2(n - 2)        + . . . + 2 log2 1         2          log2 i
                                                                                          i=1
        n-1
     2       log2(n - 1) = 2(n - 1) log2(n - 1)  2n log2 n.
        i=1
     This means that C(n)  O(n log n) for the second stage of heapsort. For both stages,
     we get O(n) + O(n log n) = O(n log n). A more detailed analysis shows that the
     time efficiency of heapsort is, in fact, in      (n log n) in both the worst and average
     cases. Thus, heapsort's time efficiency falls in the same class as that of mergesort.
     Unlike the latter, heapsort is in-place, i.e., it does not require any extra storage.
     Timing experiments on random files show that heapsort runs more slowly than
     quicksort but can be competitive with mergesort.
Exercises 6.4
1.   a.  Construct a heap for the list 1, 8, 6, 5, 3, 7, 4 by the bottom-up algorithm.
     b.  Construct a heap for the list 1, 8, 6, 5, 3, 7, 4 by successive key insertions
         (top-down algorithm).
     c.  Is it always true that the bottom-up and top-down algorithms yield the
         same heap for the same input?
2.   Outline an algorithm for checking whether an array H [1..n] is a heap and
     determine its time efficiency.
3.   a.  Find the smallest and the largest number of keys that a heap of height h
         can contain.
     b.  Prove that the height of a heap with n nodes is equal to      log2 n .
4.   Prove the following equality used in Section 6.4:
            h-1
                  2(h - i)2i = 2(n - log2(n + 1)),      where n = 2h+1 - 1.
            i=0
5.   a.  Design an efficient algorithm for finding and deleting an element of the
         smallest value in a heap and determine its time efficiency.
     b.  Design an efficient algorithm for finding and deleting an element of a given
         value v in a heap H and determine its time efficiency.
6.   Indicate the time efficiency classes of the three main operations of the priority
     queue implemented as
     a.  an unsorted array.
     b. a sorted array.
     c.  a binary search tree.
     d. an AVL tree.
     e.  a heap.
7.   Sort the following lists by heapsort by using the array representation of heaps.
     a.  1, 2, 3, 4, 5 (in increasing order)
     b. 5, 4, 3, 2, 1 (in increasing order)
     c.  S, O, R, T, I, N, G (in alphabetical order)
8.   Is heapsort a stable sorting algorithm?
9.   What variety of the transform-and-conquer technique does heapsort repre-
     sent?
10.  Which sorting algorithm other than heapsort uses a priority queue?
11.  Implement three advanced sorting algorithms--mergesort, quicksort, and
     heapsort--in the language of your choice and investigate their performance
     on arrays of sizes n = 103, 104, 105, and 106. For each of these sizes consider
               a.  randomly generated files of integers in the range [1..n].
               b. increasing files of integers 1, 2, . . . , n.
               c.  decreasing files of integers n, n - 1, . . . , 1.
          12.  Spaghetti sort  Imagine a handful of uncooked spaghetti, individual rods
               whose lengths represent numbers that need to be sorted.
               a.  Outline a "spaghetti sort"--a sorting algorithm that takes advantage of
                   this unorthodox representation.
               b. What does this example of computer science folklore (see [Dew93]) have
                   to do with the topic of this chapter in general and heapsort in particular?
     
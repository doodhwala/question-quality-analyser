Our last example is the Josephus problem, named for Flavius Josephus, a famous
     Jewish historian who participated in and chronicled the Jewish revolt of 66­70
     c.e. against the Romans. Josephus, as a general, managed to hold the fortress of
     Jotapata for 47 days, but after the fall of the city he took refuge with 40 diehards in
     a nearby cave. There, the rebels voted to perish rather than surrender. Josephus
     proposed that each man in turn should dispatch his neighbor, the order to be
     determined by casting lots. Josephus contrived to draw the last lot, and, as one
     of the two surviving men in the cave, he prevailed upon his intended victim to
     surrender to the Romans.
     So let n people numbered 1 to n stand in a circle. Starting the grim count with
     person number 1, we eliminate every second person until only one survivor is left.
     The problem is to determine the survivor's number J (n). For example (Figure
     4.12), if n is 6, people in positions 2, 4, and 6 will be eliminated on the first pass
     through the circle, and people in initial positions 3 and 1 will be eliminated on the
     second pass, leaving a sole survivor in initial position 5--thus, J (6) = 5. To give
     another example, if n is 7, people in positions 2, 4, 6, and 1 will be eliminated on
     the first pass (it is more convenient to include 1 in the first pass) and people in
     positions 5 and, for convenience, 3 on the second--thus, J (7) = 7.
                          12                             11
             61                21      7                            21
                                   61                                   32
             5                 32
                          41              52                  41
                          (a)                            (b)
FIGURE 4.12  Instances of the Josephus problem for (a) n = 6 and (b) n = 7. Subscript
             numbers indicate the pass on which the person in that position is
             eliminated. The solutions are J (6) = 5 and J (7) = 7, respectively.
It is convenient to consider the cases of even and odd n's separately. If n is
even, i.e., n = 2k, the first pass through the circle yields an instance of exactly the
same problem but half its initial size. The only difference is in position numbering;
for example, a person in initial position 3 will be in position 2 for the second pass,
a person in initial position 5 will be in position 3, and so on (check Figure 4.12a). It
is easy to see that to get the initial position of a person, we simply need to multiply
his new position by 2 and subtract 1. This relationship will hold, in particular, for
the survivor, i.e.,
                               J (2k) = 2J (k) - 1.
Let us now consider the case of an odd n (n > 1), i.e., n = 2k + 1. The first pass
eliminates people in all even positions. If we add to this the elimination of the
person in position 1 right after that, we are left with an instance of size k. Here, to
get the initial position that corresponds to the new position numbering, we have
to multiply the new position number by 2 and add 1 (check Figure 4.12b). Thus,
for odd values of n, we get
                               J (2k + 1) = 2J (k) + 1.
Can we get a closed-form solution to the two-case recurrence subject to the
initial condition J (1) = 1? The answer is yes, though getting it requires more
ingenuity than just applying backward substitutions. In fact, one way to find a
solution is to apply forward substitutions to get, say, the first 15 values of J (n),
discern a pattern, and then prove its general validity by mathematical induction.
We leave the execution of this plan to the exercises; alternatively, you can look it
up in [GKP94], whose exposition of the Josephus problem we have been following.
Interestingly, the most elegant form of the closed-form answer involves the binary
representation of size n: J (n) can be obtained by a 1-bit cyclic shift left of n itself!
For example, J (6) = J (1102) = 1012 = 5 and J (7) = J (1112) = 1112 = 7.
     Exercises 4.4
     1.  Cutting a stick A stick n inches long needs to be cut into n 1-inch pieces.
         Outline an algorithm that performs this task with the minimum number of
         cuts if several pieces of the stick can be cut at the same time. Also give a
         formula for the minimum number of cuts.
     2.  Design a decrease-by-half algorithm for computing    log2 n  and determine its
         time efficiency.
     3.  a.  What is the largest number of key comparisons made by binary search in
             searching for a key in the following array?
                         3  14   27  31  39  42  55  70   74  81  85  93  98
         b. List all the keys of this array that will require the largest number of key
             comparisons when searched for by binary search.
         c.  Find the average number of key comparisons made by binary search in a
             successful search in this array. Assume that each key is searched for with
             the same probability.
         d. Find the average number of key comparisons made by binary search in an
             unsuccessful search in this array. Assume that searches for keys in each of
             the 14 intervals formed by the array's elements are equally likely.
     4.  Estimate how many times faster an average successful search will be in a
         sorted array of one million elements if it is done by binary search versus
         sequential search.
     5.  The time efficiency of sequential search does not depend on whether a list is
         implemented as an array or as a linked list. Is it also true for searching a sorted
         list by binary search?
     6.  a.  Design a version of binary search that uses only two-way comparisons such
             as  and =. Implement your algorithm in the language of your choice and
             carefully debug it: such programs are notorious for being prone to bugs.
         b. Analyze the time efficiency of the two-way comparison version designed
             in part a.
     7.  Picture guessing A version of the popular problem-solving task involves pre-
         senting people with an array of 42 pictures--seven rows of six pictures each--
         and asking them to identify the target picture by asking questions that can be
         answered yes or no. Further, people are then required to identify the picture
         with as few questions as possible. Suggest the most efficient algorithm for this
         problem and indicate the largest number of questions that may be necessary.
     8.  Consider ternary search--the following algorithm for searching in a sorted
         array A[0..n - 1]. If n = 1, simply compare the search key K with the single
          element of the array; otherwise, search recursively by comparing K with
          A[ n/3 ], and if K is larger, compare it with A[ 2n/3 ] to determine in which
          third of the array to continue the search.
          a.  What design technique is this algorithm based on?
          b.  Set up a recurrence for the number of key comparisons in the worst case.
              You may assume that n = 3k.
          c.  Solve the recurrence for n = 3k.
          d. Compare this algorithm's efficiency with that of binary search.
     9.   An array A[0..n - 2] contains n - 1 integers from 1 to n in increasing order.
          (Thus one integer in this range is missing.) Design the most efficient algorithm
          you can to find the missing integer and indicate its time efficiency.
     10.  a.  Write pseudocode for the divide-into-three algorithm for the fake-coin
              problem. Make sure that your algorithm handles properly all values of n,
              not only those that are multiples of 3.
          b.  Set up a recurrence relation for the number of weighings in the divide-into-
              three algorithm for the fake-coin problem and solve it for n = 3k.
          c.  For large values of n, about how many times faster is this algorithm than
              the one based on dividing coins into two piles? Your answer should not
              depend on n.
     11.  a.  Apply the Russian peasant algorithm to compute 26 . 47.
          b. From the standpoint of time efficiency, does it matter whether we multiply
              n by m or m by n by the Russian peasant algorithm?
     12.  a.  Write pseudocode for the Russian peasant multiplication algorithm.
          b. What is the time efficiency class of Russian peasant multiplication?
     13.  Find J (40)--the solution to the Josephus problem for n = 40.
     14.  Prove that the solution to the Josephus problem is 1 for every n that is a power
          of 2.
     15.  For the Josephus problem,
          a.  compute J (n) for n = 1, 2, . . . , 15.
          b. discern a pattern in the solutions for the first fifteen values of n and prove
              its general validity.
          c.  prove the validity of getting J (n) by a 1-bit cyclic shift left of the binary
              representation of n.

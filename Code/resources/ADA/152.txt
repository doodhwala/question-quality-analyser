Fake-Coin Problem
Of several versions of the fake-coin identification problem, we consider here
         the one that best illustrates the decrease-by-a-constant-factor strategy. Among n
         identical-looking coins, one is fake. With a balance scale, we can compare any two
         sets of coins. That is, by tipping to the left, to the right, or staying even, the balance
         scale will tell whether the sets weigh the same or which of the sets is heavier than
         the other but not by how much. The problem is to design an efficient algorithm
         for detecting the fake coin. An easier version of the problem--the one we discuss
         here--assumes that the fake coin is known to be, say, lighter than the genuine
         one.1
         The most natural idea for solving this problem is to divide n coins into two
         piles of  n/2   coins each, leaving one extra coin aside if n is odd, and put the two
     1.  A much more challenging version assumes no additional information about the relative weights of the
         fake and genuine coins or even the presence of the fake coin among n given coins. We pursue this more
         difficult version in the exercises for Section 11.2.
piles on the scale. If the piles weigh the same, the coin put aside must be fake;
otherwise, we can proceed in the same manner with the lighter pile, which must
be the one with the fake coin.
We can easily set up a recurrence relation for the number of weighings W (n)
needed by this algorithm in the worst case:
W (n) = W ( n/2 ) + 1                        for n > 1,  W (1) = 0.
This recurrence should look familiar to you. Indeed, it is almost identical to the one
for the worst-case number of comparisons in binary search. (The difference is in
the initial condition.) This similarity is not really surprising, since both algorithms
are based on the same technique of halving an instance size. The solution to the
recurrence for the number of weighings is also very similar to the one we had for
binary search: W (n) =  log2 n .
This stuff should look elementary by now, if not outright boring. But wait: the
interesting point here is the fact that the above algorithm is not the most efficient
solution. It would be more efficient to divide the coins not into two but into three
piles of about n/3 coins each. (Details of a precise formulation are developed
in this section's exercises. Do not miss it! If your instructor forgets, demand the
instructor to assign Problem 10.) After weighing two of the piles, we can reduce
the instance size by a factor of three. Accordingly, we should expect the number
of weighings to be about log3 n, which is smaller than log2 n.

Depth-First Search
Depth-first search starts a graph's traversal at an arbitrary vertex by marking it
          as visited. On each iteration, the algorithm proceeds to an unvisited vertex that
          is adjacent to the one it is currently in. (If there are several such vertices, a tie
          can be resolved arbitrarily. As a practical matter, which of the adjacent unvisited
          candidates is chosen is dictated by the data structure representing the graph. In
          our examples, we always break ties by the alphabetical order of the vertices.) This
          process continues until a dead end--a vertex with no adjacent unvisited vertices--
          is encountered. At a dead end, the algorithm backs up one edge to the vertex
          it came from and tries to continue visiting unvisited vertices from there. The
          algorithm eventually halts after backing up to the starting vertex, with the latter
          being a dead end. By then, all the vertices in the same connected component as the
          starting vertex have been visited. If unvisited vertices still remain, the depth-first
          search must be restarted at any one of them.
          It is convenient to use a stack to trace the operation of depth-first search. We
          push a vertex onto the stack when the vertex is reached for the first time (i.e., the
                                                                  a                      g
g                             h
                                                 e 6, 2           c                      h
   a                    e                        b 5, 3  j10,7
       c             f                    d3, 1  f4, 4   i 9, 8   d  f                   i
                                          c2, 5          h8, 9
   d                    b                 a1, 6          g7,10                           j
                                                                     b
j                             i
                                                                     e
             (a)                                 (b)                 (c)
FIGURE 3.10  Example of a DFS traversal. (a) Graph. (b) Traversal's stack (the first
             subscript number indicates the order in which a vertex is visited, i.e.,
             pushed onto the stack; the second one indicates the order in which it
             becomes a dead-end, i.e., popped off the stack). (c) DFS forest with the
             tree and back edges shown with solid and dashed lines, respectively.
visit of the vertex starts), and we pop a vertex off the stack when it becomes a
dead end (i.e., the visit of the vertex ends).
   It is also very useful to accompany a depth-first search traversal by construct-
ing the so-called depth-first search forest. The starting vertex of the traversal
serves as the root of the first tree in such a forest. Whenever a new unvisited vertex
is reached for the first time, it is attached as a child to the vertex from which it is
being reached. Such an edge is called a tree edge because the set of all such edges
forms a forest. The algorithm may also encounter an edge leading to a previously
visited vertex other than its immediate predecessor (i.e., its parent in the tree).
Such an edge is called a back edge because it connects a vertex to its ancestor,
other than the parent, in the depth-first search forest. Figure 3.10 provides an ex-
ample of a depth-first search traversal, with the traversal stack and corresponding
depth-first search forest shown as well.
   Here is pseudocode of the depth-first search.
ALGORITHM    DFS(G)
   //Implements a depth-first search traversal of a given graph
   //Input: Graph G =   V, E
   //Output: Graph G with its vertices marked with consecutive integers
   //        in the order they are first encountered by the DFS traversal
   mark each vertex in V with 0 as a mark of being "unvisited"
   count  0
   for each vertex v in V do
       if v is marked with 0
             dfs(v)
         dfs(v)
         //visits recursively all the unvisited vertices connected to vertex v
         //by a path and numbers them in the order they are encountered
         //via global variable count
         count  count + 1;         mark v with count
         for each vertex w in V adjacent to v do
         if w is marked with 0
                          dfs(w)
         The brevity of the DFS pseudocode and the ease with which it can be per-
         formed by hand may create a wrong impression about the level of sophistication
         of this algorithm. To appreciate its true power and depth, you should trace the
         algorithm's action by looking not at a graph's diagram but at its adjacency matrix
         or adjacency lists. (Try it for the graph in Figure 3.10 or a smaller example.)
         How efficient is depth-first search? It is not difficult to see that this algorithm
         is, in fact, quite efficient since it takes just the time proportional to the size of the
         data structure used for representing the graph in question. Thus, for the adjacency
         matrix representation, the traversal time is in     (|V |2), and for the adjacency list
         representation, it is in  (|V | + |E|) where |V | and |E| are the number of the
         graph's vertices and edges, respectively.
         A DFS forest, which is obtained as a by-product of a DFS traversal, deserves a
         few comments, too. To begin with, it is not actually a forest. Rather, we can look at
         it as the given graph with its edges classified by the DFS traversal into two disjoint
         classes: tree edges and back edges. (No other types are possible for a DFS forest
         of an undirected graph.) Again, tree edges are edges used by the DFS traversal to
         reach previously unvisited vertices. If we consider only the edges in this class, we
         will indeed get a forest. Back edges connect vertices to previously visited vertices
         other than their immediate predecessors in the traversal. They connect vertices to
         their ancestors in the forest other than their parents.
         A DFS traversal itself and the forest-like representation of the graph it pro-
         vides have proved to be extremely helpful for the development of efficient al-
         gorithms for checking many important properties of graphs.3 Note that the DFS
         yields two orderings of vertices: the order in which the vertices are reached for the
         first time (pushed onto the stack) and the order in which the vertices become dead
         ends (popped off the stack). These orders are qualitatively different, and various
         applications can take advantage of either of them.
         Important elementary applications of DFS include checking connectivity and
         checking acyclicity of a graph. Since dfs halts after visiting all the vertices con-
     3.  The discovery of several such applications was an important breakthrough achieved by the two
         American computer scientists John Hopcroft and Robert Tarjan in the 1970s. For this and other
         contributions, they were given the Turing Award--the most prestigious prize in the computing field
         [Hop87, Tar87].
nected by a path to the starting vertex, checking a graph's connectivity can be
done as follows. Start a DFS traversal at an arbitrary vertex and check, after
the algorithm halts, whether all the vertices of the graph will have been vis-
ited. If they have, the graph is connected; otherwise, it is not connected. More
generally, we can use DFS for identifying connected components of a graph
(how?).
As for checking for a cycle presence in a graph, we can take advantage of the
graph's representation in the form of a DFS forest. If the latter does not have back
edges, the graph is clearly acyclic. If there is a back edge from some vertex u to its
ancestor v (e.g., the back edge from d to a in Figure 3.10c), the graph has a cycle
that comprises the path from v to u via a sequence of tree edges in the DFS forest
followed by the back edge from u to v.
You will find a few other applications of DFS later in the book, although
more sophisticated applications, such as finding articulation points of a graph,
are not included. (A vertex of a connected graph is said to be its articulation
point if its removal with all edges incident to it breaks the graph into disjoint
pieces.)

Most problems discussed in this book can be solved in polynomial time by some
     algorithm. They include computing the product and the greatest common divisor
     of two integers, sorting a list, searching for a key in a list or for a pattern in a text
     string, checking connectivity and acyclicity of a graph, and finding a minimum
     spanning tree and shortest paths in a weighted graph. (You are invited to add
     more examples to this list.) Informally, we can think about problems that can be
     solved in polynomial time as the set that computer science theoreticians call P . A
     more formal definition includes in P only decision problems, which are problems
     with yes/no answers.
     DEFINITION 2      Class  P  is  a  class  of  decision  problems  that  can  be  solved    in
     polynomial time by (deterministic) algorithms. This class of problems is called
     polynomial.
     The restriction of P to decision problems can be justified by the following
     reasons. First, it is sensible to exclude problems not solvable in polynomial time
     because of their exponentially large output. Such problems do arise naturally--
     e.g., generating subsets of a given set or all the permutations of n distinct items--
     but it is apparent from the outset that they cannot be solved in polynomial time.
     Second, many important problems that are not decision problems in their most
     natural formulation can be reduced to a series of decision problems that are easier
     to study. For example, instead of asking about the minimum number of colors
     needed to color the vertices of a graph so that no two adjacent vertices are colored
     the same color, we can ask whether there exists such a coloring of the graph's
     vertices with no more than m colors for m = 1, 2, . . . . (The latter is called the m-
     coloring problem.) The first value of m in this series for which the decision problem
     of m-coloring has a solution solves the optimization version of the graph-coloring
     problem as well.
     It is natural to wonder whether every decision problem can be solved in
     polynomial time. The answer to this question turns out to be no. In fact, some
     decision problems cannot be solved at all by any algorithm. Such problems are
     called undecidable, as opposed to decidable problems that can be solved by an
     algorithm. A famous example of an undecidable problem was given by Alan
    Turing in 1936.1 The problem in question is called the halting problem: given a
    computer program and an input to it, determine whether the program will halt on
    that input or continue working indefinitely on it.
    Here is a surprisingly short proof of this remarkable fact. By way of contra-
    diction, assume that A is an algorithm that solves the halting problem. That is, for
    any program P and input I,
             A(P , I ) =         1,  if program P halts on input I ;
                                 0,  if program P does not halt on input I .
    We can consider program P as an input to itself and use the output of algorithm
    A for pair (P , P ) to construct a program Q as follows:
    Q(P ) =  halts,              if A(P , P ) = 0, i.e., if program P does not halt on input P ;
             does not halt,      if A(P , P ) = 1, i.e., if program P halts on input P .
    Then on substituting Q for P , we obtain
    Q(Q) =   halts,              if A(Q, Q) = 0, i.e., if program Q does not halt on input Q;
             does not halt,      if A(Q, Q) = 1, i.e., if program Q halts on input Q.
    This is a contradiction because neither of the two outcomes for program Q is
    possible, which completes the proof.
    Are there decidable but intractable problems? Yes, there are, but the number
    of known examples is surprisingly small, especially of those that arise naturally
    rather than being constructed for the sake of a theoretical argument.
    There are many important problems, however, for which no polynomial-time
    algorithm has been found, nor has the impossibility of such an algorithm been
    proved. The classic monograph by M. Garey and D. Johnson [Gar79] contains a
    list of several hundred such problems from different areas of computer science,
    mathematics, and operations research. Here is just a small sample of some of the
    best-known problems that fall into this category:
    Hamiltonian         circuit  problem  Determine whether a given graph has a
    Hamiltonian circuit--a path that starts and ends at the same vertex and passes
    through all the other vertices exactly once.
    Traveling salesman problem            Find the shortest tour through n cities with
    known positive integer distances between them (find the shortest Hamiltonian
    circuit in a complete graph with positive integer weights).
1.  This was just one of many breakthrough contributions to theoretical computer science made by the
    English mathematician and computer science pioneer Alan Turing (1912­1954). In recognition of this,
    the ACM--the principal society of computing professionals and researchers--has named after him an
    award given for outstanding contributions to theoretical computer science. A lecture given on such an
    occasion by Richard Karp [Kar86] provides an interesting historical account of the development of
    complexity theory.
     Knapsack problem     Find the most valuable subset of n items of given positive
     integer weights and values that fit into a knapsack of a given positive integer
     capacity.
     Partition problem  Given n positive integers, determine whether it is possi-
     ble to partition them into two disjoint subsets with the same sum.
     Bin-packing problem             Given n items whose sizes are positive rational num-
     bers not larger than 1, put them into the smallest number of bins of size 1.
     Graph-coloring problem          For a given graph, find its chromatic number,
     which is the smallest number of colors that need to be assigned to the graph's
     vertices so that no two adjacent vertices are assigned the same color.
     Integer linear programming problem    Find the maximum (or minimum)
     value of a linear function of several integer-valued variables subject to a finite
     set of constraints in the form of linear equalities and inequalities.
     Some of these problems are decision problems. Those that are not have
     decision-version counterparts (e.g., the m-coloring problem for the graph-coloring
     problem). What all these problems have in common is an exponential (or worse)
     growth of choices, as a function of input size, from which a solution needs to be
     found. Note, however, that some problems that also fall under this umbrella can
     be solved in polynomial time. For example, the Eulerian circuit problem--the
     problem of the existence of a cycle that traverses all the edges of a given graph
     exactly once--can be solved in O(n2) time by checking, in addition to the graph's
     connectivity, whether all the graph's vertices have even degrees. This example is
     particularly striking: it is quite counterintuitive to expect that the problem about
     cycles traversing all the edges exactly once (Eulerian circuits) can be so much
     easier than the seemingly similar problem about cycles visiting all the vertices
     exactly once (Hamiltonian circuits).
     Another common feature of a vast majority of decision problems is the fact
     that although solving such problems can be computationally difficult, checking
     whether a proposed solution actually solves the problem is computationally easy,
     i.e., it can be done in polynomial time. (We can think of such a proposed solution
     as being randomly generated by somebody leaving us with the task of verifying its
     validity.) For example, it is easy to check whether a proposed list of vertices is a
     Hamiltonian circuit for a given graph with n vertices. All we need to check is that
     the list contains n + 1 vertices of the graph in question, that the first n vertices are
     distinct whereas the last one is the same as the first, and that every consecutive
     pair of the list's vertices is connected by an edge. This general observation about
     decision problems has led computer scientists to the notion of a nondeterministic
     algorithm.
     DEFINITION 3  A nondeterministic algorithm is a two-stage procedure that
     takes as its input an instance I of a decision problem and does the following.
     Nondeterministic ("guessing") stage: An arbitrary string S is generated that
     can be thought of as a candidate solution to the given instance I (but may be
     complete gibberish as well).
Deterministic ("verification") stage: A deterministic algorithm takes both I
and S as its input and outputs yes if S represents a solution to instance I. (If S is
not a solution to instance I , the algorithm either returns no or is allowed not to
halt at all.)
We say that a nondeterministic algorithm solves a decision problem if and
only if for every yes instance of the problem it returns yes on some execu-
tion. (In other words, we require a nondeterministic algorithm to be capable
of "guessing" a solution at least once and to be able to verify its validity. And,
of course, we do not want it to ever output a yes answer on an instance for
which the answer should be no.) Finally, a nondeterministic algorithm is said to
be nondeterministic polynomial if the time efficiency of its verification stage is
polynomial.
Now we can define the class of NP problems.
DEFINITION 4     Class NP is the class of decision problems that can be solved by
nondeterministic polynomial algorithms. This class of problems is called nonde-
terministic polynomial.
Most decision problems are in NP. First of all, this class includes all the
problems in P :
                                 P  NP.
This is true because, if a problem is in P , we can use the deterministic polynomial-
time algorithm that solves it in the verification-stage of a nondeterministic algo-
rithm that simply ignores string S generated in its nondeterministic ("guessing")
stage. But NP also contains the Hamiltonian circuit problem, the partition prob-
lem, decision versions of the traveling salesman, the knapsack, graph coloring, and
many hundreds of other difficult combinatorial optimization problems cataloged
in [Gar79]. The halting problem, on the other hand, is among the rare examples
of decision problems that are known not to be in NP.
This leads to the most important open question of theoretical computer sci-
ence: Is P a proper subset of NP, or are these two classes, in fact, the same? We
can put this symbolically as
                                 P =? NP.
Note that P = NP would imply that each of many hundreds of difficult
combinatorial decision problems can be solved by a polynomial-time algorithm,
although computer scientists have failed to find such algorithms despite their per-
sistent efforts over many years. Moreover, many well-known decision problems
are known to be "NP-complete" (see below), which seems to cast more doubts
on the possibility that P = NP.

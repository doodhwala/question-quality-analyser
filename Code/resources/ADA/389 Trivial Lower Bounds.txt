The simplest method of obtaining a lower-bound class is based on counting the
number of items in the problem's input that must be processed and the number of
output items that need to be produced. Since any algorithm must at least "read" all
the items it needs to process and "write" all its outputs, such a count yields a trivial
lower bound. For example, any algorithm for generating all permutations of n
distinct items must be in  (n!) because the size of the output is n!. And this bound
is tight because good algorithms for generating permutations spend a constant
time on each of them except the initial one (see Section 4.3).
As another example, consider the problem of evaluating a polynomial of
degree n
                           p(x) = anxn + an-1xn-1 + . . . + a0
at a given point x, given its coefficients an, an-1, . . . , a0. It is easy to see that all the
coefficients have to be processed by any polynomial-evaluation algorithm. Indeed,
if it were not the case, we could change the value of an unprocessed coefficient,
which would change the value of the polynomial at a nonzero point x. This means
that any such algorithm must be in         (n). This lower bound is tight because both
the right-to-left evaluation algorithm (Problem 2 in Exercises 6.5) and Horner's
rule (Section 6.5) are both linear.
In a similar vein, a trivial lower bound for computing the product of two
n × n matrices is  (n2) because any such algorithm has to process 2n2 elements
in the input matrices and generate n2 elements of the product. It is still unknown,
however, whether this bound is tight.
Trivial lower bounds are often too low to be useful. For example, the trivial
bound for the traveling salesman problem is  (n2), because its input is n(n - 1)/2
intercity distances and its output is a list of n + 1 cities making up an optimal tour.
But this bound is all but useless because there is no known algorithm with the
running time being a polynomial function of any degree.
There is another obstacle to deriving a meaningful lower bound by this
method. It lies in determining which part of an input must be processed by any
algorithm solving the problem in question. For example, searching for an ele-
ment of a given value in a sorted array does not require processing all its elements
(why?). As another example, consider the problem of determining connectivity of
     an undirected graph defined by its adjacency matrix. It is plausible to expect that
     any such algorithm would have to check the existence of each of the n(n - 1)/2
     potential edges, but the proof of this fact is not trivial.

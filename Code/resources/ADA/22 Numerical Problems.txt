Numerical problems, another large special area of applications, are problems
    that involve mathematical objects of continuous nature: solving equations and
    systems of equations, computing definite integrals, evaluating functions, and so on.
    The majority of such mathematical problems can be solved only approximately.
    Another principal difficulty stems from the fact that such problems typically
    require manipulating real numbers, which can be represented in a computer only
    approximately. Moreover, a large number of arithmetic operations performed on
    approximately represented numbers can lead to an accumulation of the round-off
error to a point where it can drastically distort an output produced by a seemingly
sound algorithm.
    Many sophisticated algorithms have been developed over the years in this
area, and they continue to play a critical role in many scientific and engineering
applications. But in the last 30 years or so, the computing industry has shifted
its focus to business applications. These new applications require primarily algo-
rithms for information storage, retrieval, transportation through networks, and
presentation to users. As a result of this revolutionary change, numerical analysis
has lost its formerly dominating position in both industry and computer science
programs. Still, it is important for any computer-literate person to have at least a
rudimentary idea about numerical algorithms. We discuss several classical numer-
ical algorithms in Sections 6.2, 11.4, and 12.4.
Exercises 1.3
1.  Consider the algorithm for the sorting problem that sorts an array by counting,
    for each of its elements, the number of smaller elements and then uses this
    information to put the element in its appropriate position in the sorted array:
    ALGORITHM            ComparisonCountingSort(A[0..n - 1])
        //Sorts an array by comparison counting
        //Input: Array A[0..n - 1] of orderable values
        //Output: Array S[0..n - 1] of A's elements sorted
        //  in nondecreasing order
        for i  0 to n - 1 do
            Count[i]  0
        for i  0 to n - 2 do
            for j  i + 1 to n - 1 do
                  if A[i] < A[j ]
                         Count[j ]  Count[j ] + 1
                  else Count[i]  Count[i] + 1
        for i  0 to n - 1 do
            S[Count[i]]  A[i]
        return S
    a.  Apply this algorithm to sorting the list 60, 35, 81, 98, 14, 47.
    b. Is this algorithm stable?
    c.  Is it in-place?
2.  Name the algorithms for the searching problem that you already know. Give
    a good succinct description of each algorithm in English. If you know no such
    algorithms, use this opportunity to design one.
3.  Design a simple algorithm for the string-matching problem.
    4.  Ko¨ nigsberg bridges  The Ko¨ nigsberg bridge puzzle is universally accepted
        as the problem that gave birth to graph theory. It was solved by the great
        Swiss-born mathematician Leonhard Euler (1707­1783). The problem asked
        whether one could, in a single stroll, cross all seven bridges of the city of
        Ko¨ nigsberg exactly once and return to a starting point. Following is a sketch
        of the river with its two islands and seven bridges:
        a.  State the problem as a graph problem.
        b.  Does this problem have a solution? If you believe it does, draw such a stroll;
            if you believe it does not, explain why and indicate the smallest number of
            new bridges that would be required to make such a stroll possible.
    5.  Icosian Game  A century after Euler's discovery (see Problem 4), another
        famous puzzle--this one invented by the renowned Irish mathematician Sir
        William Hamilton (1805­1865)--was presented to the world under the name
        of the Icosian Game. The game's board was a circular wooden board on which
        the following graph was carved:
        Find a Hamiltonian circuit--a path that visits all the graph's vertices exactly
        once before returning to the starting vertex--for this graph.
    6.  Consider the following problem: Design an algorithm to determine the best
        route for a subway passenger to take from one designated station to another in
        a well-developed subway system similar to those in such cities as Washington,
        D.C., and London, UK.
          a.  The problem's statement is somewhat vague, which is typical of real-life
              problems. In particular, what reasonable criterion can be used for defining
              the "best" route?
          b. How would you model this problem by a graph?
     7.   a.  Rephrase the traveling-salesman problem in combinatorial object terms.
          b. Rephrase the graph-coloring problem in combinatorial object terms.
     8.   Consider the following map:
                                             b
                                       a
                                                   d
                                          c
                                       e
                                                f
          a.  Explain how we can use the graph-coloring problem to color the map so
              that no two neighboring regions are colored the same.
          b. Use your answer to part (a) to color the map with the smallest number of
              colors.
     9.   Design an algorithm for the following problem: Given a set of n points in the
          Cartesian plane, determine whether all of them lie on the same circumference.
     10.  Write a program that reads as its inputs the (x, y) coordinates of the endpoints
          of two line segments P1Q1 and P2Q2 and determines whether the segments
          have a common point.

Another brute-force application to the sorting problem is to compare adjacent
     elements of the list and exchange them if they are out of order. By doing it
     repeatedly, we end up "bubbling up" the largest element to the last position on
     the list. The next pass bubbles up the second largest element, and so on, until
     after n - 1 passes the list is sorted. Pass i (0  i  n - 2) of bubble sort can be
     represented by the following diagram:
                   A0, . . . , Aj ? Aj+1, . . . , An-i-1 | An-i  . . .  An-1
                                                                   in their final positions
     Here is pseudocode of this algorithm.
     ALGORITHM     BubbleSort(A[0..n - 1])
     //Sorts a given array by bubble sort
     //Input: An array A[0..n - 1] of orderable elements
     //Output: Array A[0..n - 1] sorted in nondecreasing order
     for i  0 to n - 2 do
     for j  0 to n - 2 - i do
                   if A[j + 1] < A[j ] swap A[j ] and A[j + 1]
     The action of the algorithm on the list 89, 45, 68, 90, 29, 34, 17 is illustrated
     as an example in Figure 3.2.
     The number of key comparisons for the bubble-sort version given above is
     the same for all arrays of size n; it is obtained by a sum that is almost identical to
     the sum for selection sort:
             89  ?           45           68          90           29          34        17
             45              89  ?        68          90           29          34        17
             45              68           89      ?   90    ?      29          34        17
             45              68           89          29           90      ?   34        17
             45              68           89          29           34          90     ?  17
             45              68           89          29           34          17     |  90
             45  ?           68  ?        89      ?   29              34       17     |  90
             45              68           29          89    ?         34       17     |  90
             45              68           29          34              89   ?   17     |  90
             45              68           29          34              17    |  89        90
                                                     etc.
FIGURE  3.2  First two passes of bubble sort on the list 89, 45, 68, 90, 29, 34, 17. A new
             line is shown after a swap of two elements is done. The elements to the
             right of the vertical bar are in their final positions and are not considered in
             subsequent iterations of the algorithm.
                                 n-2 n-2-i            n-2
                 C(n) =                           1=        [(n - 2 - i) - 0 + 1]
                                 i=0     j =0         i=0
                                 n-2                        (n  -     1)n
                             =        (n  -    1  -  i)  =         2           (n2).
                                 i=0
The number of key swaps, however, depends on the input. In the                               worst  case  of
decreasing arrays, it is the same as the number of key comparisons:
                             Sworst (n)   =   C(n)    =   (n  - 1)n            (n2).
                                                                2
As is often the case with an application of the brute-force strategy, the first
version of an algorithm obtained can often be improved upon with a modest
amount of effort. Specifically, we can improve the crude version of bubble sort
given above by exploiting the following observation: if a pass through the list
makes no exchanges, the list has been sorted and we can stop the algorithm
(Problem 12a in this section's exercises). Though the new version runs faster on
some inputs, it is still in      (n2) in the worst and average cases. In fact, even among
elementary sorting methods, bubble sort is an inferior choice, and if it were not for
its catchy name, you would probably have never heard of it. However, the general
lesson you just learned is important and worth repeating:
A first application of the brute-force approach often results in an algorithm
that can be improved with a modest amount of effort.
     Exercises 3.1
     1.  a.  Give an example of an algorithm that should not be considered an appli-
             cation of the brute-force approach.
         b.  Give an example of a problem that cannot be solved by a brute-force
             algorithm.
     2.  a.  What is the time efficiency of the brute-force algorithm for computing
             an as a function of n? As a function of the number of bits in the binary
             representation of n?
         b.  If you are to compute an mod m where a > 1 and n is a large positive integer,
             how would you circumvent the problem of a very large magnitude of an?
     3.  For each of the algorithms in Problems 4, 5, and 6 of Exercises 2.3, tell whether
         or not the algorithm is based on the brute-force approach.
     4.  a.  Design a brute-force algorithm for computing the value of a polynomial
                            p(x) = anxn + an-1xn-1 + . . . + a1x + a0
             at a given point x0 and determine its worst-case efficiency class.
                                                  (n2), design a linear algorithm for this
         b.  If the algorithm you designed is in
             problem.
         c.  Is it possible to design an algorithm with a better-than-linear efficiency for
             this problem?
     5.  A network topology specifies how computers, printers, and other devices
         are connected over a network. The figure below illustrates three common
         topologies of networks: the ring, the star, and the fully connected mesh.
             ring                                 star  fully connected mesh
         You are given a boolean matrix A[0..n - 1, 0..n - 1], where n > 3, which is
         supposed to be the adjacency matrix of a graph modeling a network with one
         of these topologies. Your task is to determine which of these three topologies,
         if any, the matrix represents. Design a brute-force algorithm for this task and
         indicate its time efficiency class.
     6.  Tetromino tilings  Tetrominoes are tiles made of four 1 × 1 squares. There
         are five types of tetrominoes shown below:
straight tetromino     square tetromino  L-tetromino       T-tetromino  Z-tetromino
     Is it possible to tile--i.e., cover exactly without overlaps--an 8 × 8 chessboard
     with
           a. straight tetrominoes?      b. square tetrominoes?
           c. L-tetrominoes?             d. T-tetrominoes?
           e. Z-tetrominoes?
7.   A stack of fake coins     There are n stacks of n identical-looking coins. All of
     the coins in one of these stacks are counterfeit, while all the coins in the other
     stacks are genuine. Every genuine coin weighs 10 grams; every fake weighs
     11 grams. You have an analytical scale that can determine the exact weight of
     any number of coins.
     a.  Devise a brute-force algorithm to identify the stack with the fake coins and
         determine its worst-case efficiency class.
     b. What is the minimum number of weighings needed to identify the stack
         with the fake coins?
8. Sort the list E, X, A, M, P , L, E in alphabetical order by selection sort.
9.   Is selection sort stable? (The definition of a stable sorting algorithm was given
     in Section 1.3.)
10.  Is it possible to implement selection sort for linked lists with the same       (n2)
     efficiency as the array version?
11. Sort the list E, X, A, M, P , L, E in alphabetical order by bubble sort.
12.  a.  Prove that if bubble sort makes no exchanges on its pass through a list, the
         list is sorted and the algorithm can be stopped.
     b.  Write pseudocode of the method that incorporates this improvement.
     c.  Prove that the worst-case efficiency of the improved version is quadratic.
13. Is bubble sort stable?
14.  Alternating disks  You have a row of 2n disks of two colors, n dark and n light.
     They alternate: dark, light, dark, light, and so on. You want to get all the dark
     disks to the right-hand end, and all the light disks to the left-hand end. The
     only moves you are allowed to make are those that interchange the positions
     of two neighboring disks.
     Design an algorithm for solving this puzzle and determine the number of
     moves it takes. [Gar99]
     
Lower-Bound Arguments
We can look at the efficiency of an algorithm two ways. We can establish its asymp-
           totic efficiency class (say, for the worst case) and see where this class stands with
           respect to the hierarchy of efficiency classes outlined in Section 2.2. For exam-
           ple, selection sort, whose efficiency is quadratic, is a reasonably fast algorithm,
           whereas the algorithm for the Tower of Hanoi problem is very slow because its ef-
           ficiency is exponential. We can argue, however, that this comparison is akin to the
           proverbial comparison of apples to oranges because these two algorithms solve
           different problems. The alternative and possibly "fairer" approach is to ask how
           efficient a particular algorithm is with respect to other algorithms for the same
           problem. Seen in this light, selection sort has to be considered slow because there
           are O(n log n) sorting algorithms; the Tower of Hanoi algorithm, on the other
           hand, turns out to be the fastest possible for the problem it solves.
           When we want to ascertain the efficiency of an algorithm with respect to other
           algorithms for the same problem, it is desirable to know the best possible efficiency
           any algorithm solving the problem may have. Knowing such a lower bound can
           tell us how much improvement we can hope to achieve in our quest for a better
           algorithm for the problem in question. If such a bound is tight, i.e., we already
           know an algorithm in the same efficiency class as the lower bound, we can hope
           for a constant-factor improvement at best. If there is a gap between the efficiency
           of the fastest algorithm and the best lower bound known, the door for possible
           improvement remains open: either a faster algorithm matching the lower bound
           could exist or a better lower bound could be proved.
In this section, we present several methods for establishing lower bounds and
illustrate them with specific examples. As we did in analyzing the efficiency of
specific algorithms in the preceding chapters, we should distinguish between a
lower-bound class and a minimum number of times a particular operation needs
to be executed. As a rule, the second problem is more difficult than the first.
For example, we can immediately conclude that any algorithm for finding the
median of n numbers must be in       (n) (why?), but it is not simple at all to prove
that any comparison-based algorithm for this problem must do at least 3(n - 1)/2
comparisons in the worst case (for odd n).

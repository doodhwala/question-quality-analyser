Most sorting algorithms are comparison based, i.e., they work by comparing
elements in a list to be sorted. By studying properties of decision trees for such
algorithms, we can derive important lower bounds on their time efficiencies.
We can interpret an outcome of a sorting algorithm as finding a permutation of
the element indices of an input list that puts the list's elements in ascending order.
Consider, as an example, a three-element list a, b, c of orderable items such as
real numbers or strings. For the outcome a < c < b obtained by sorting this list
(see Figure 11.2), the permutation in question is 1, 3, 2. In general, the number of
possible outcomes for sorting an arbitrary n-element list is equal to n!.
                                                          abc
                                       yes                a <b                    no
                         abc                                                                     abc
                yes      a <c          no                                         yes         b <c         no
          abc                              cba                              bac                                cba
     yes  b <c       no                b <a      no                yes      a <c        no            yes   b <a
a <b<c          a  <c<b                         c <a<b       b <a<c                  b <c<a         c <b<a
                   FIGURE 11.2      Decision tree for the tree-element selection sort. A triple above a
                                    node indicates the state of the array being sorted. Note two redundant
                                    comparisons b < a with a single possible outcome because of the results
                                    of some previously made comparisons.
                         Inequality (11.1) implies that the height of a binary decision tree for any
                   comparison-based sorting algorithm and hence the worst-case number of com-
                   parisons made by such an algorithm cannot be less than                     log2 n! :
                                                       Cworst (n)        log2 n! .                                  (11.2)
                   Using Stirling's formula for n!, we get
                     log2 n!     log2      2 n(n/e)n   =     log2     -     log2     +  log2  n  +  log2 2   n log2 n.
                                                          n        n     n        e     2             2
                   In other words, about n log2 n comparisons are necessary in the worst case to sort
                   an arbitrary n-element list by any comparison-based sorting algorithm. Note that
                   mergesort makes about this number of comparisons in its worst case and hence is
                   asymptotically optimal. This also implies that the asymptotic lower bound n log2 n
                   is tight and therefore cannot be substantially improved. We should point out,
                   however, that the lower bound of             log2 n!     can be improved for some values of
                   n. For example,     log2 12!  = 29, but it has been proved that 30 comparisons are
                   necessary (and sufficient) to sort an array of 12 elements in the worst case.
                         We can also use decision trees for analyzing the average-case efficiencies of
                   comparison-based sorting algorithms. We can compute the average number of
                   comparisons for a particular algorithm as the average depth of its decision tree's
                   leaves, i.e., as the average path length from the root to the leaves. For example, for
                                                 abc
                         yes                     a <b                    no
             abc                                                                  bac
        yes  b <c        no                                                 yes   a <c           no
a <b<c                       acb                             b     <  a  <c                          bca
                   yes   a <c           no                                              yes       b <c    no
             a  <c<b                    c <a<b                                    b <c<a                  c <b<a
                FIGURE 11.3       Decision tree for the three-element insertion sort.
                the three-element insertion sort whose decision tree is given in Figure 11.3, this
                number   is  (2   +  3  +  3  +  2  +  3  +  3)/6  =  2  2  .
                                                                         3
                   Under the standard assumption that all n! outcomes of sorting are equally
                likely, the following lower bound on the average number of comparisons Cavg
                made by any comparison-based algorithm in sorting an n-element list has been
                proved:
                                                             Cavg(n)  log2 n!.                                (11.3)
                As we saw earlier, this lower bound is about n log2 n. You might be surprised that
                the lower bounds for the average and worst cases are almost identical. Remember,
                however, that these bounds are obtained by maximizing the number of compar-
                isons made in the average and worst cases, respectively. For a particular sorting
                algorithm, the average-case efficiency can, of course, be significantly better than
                their worst-case efficiency.

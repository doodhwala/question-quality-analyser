In the previous section, we considered the greedy algorithm that "grows" a mini-
     mum spanning tree through a greedy inclusion of the nearest vertex to the vertices
     already in the tree. Remarkably, there is another greedy algorithm for the mini-
     mum spanning tree problem that also always yields an optimal solution. It is named
     Kruskal's algorithm after Joseph Kruskal, who discovered this algorithm when
     he was a second-year graduate student [Kru56]. Kruskal's algorithm looks at a
     minimum spanning tree of a weighted connected graph G =     V, E  as an acyclic
     subgraph with |V | - 1 edges for which the sum of the edge weights is the smallest.
     (It is not difficult to prove that such a subgraph must be a tree.) Consequently,
     the algorithm constructs a minimum spanning tree as an expanding sequence of
     subgraphs that are always acyclic but are not necessarily connected on the inter-
     mediate stages of the algorithm.
     The algorithm begins by sorting the graph's edges in nondecreasing order of
     their weights. Then, starting with the empty subgraph, it scans this sorted list,
     adding the next edge on the list to the current subgraph if such an inclusion does
     not create a cycle and simply skipping the edge otherwise.
     ALGORITHM   Kruskal(G)
     //Kruskal's algorithm for constructing a minimum spanning tree
     //Input: A weighted connected graph G =  V, E
     //Output: ET , the set of edges composing a minimum spanning tree of G
     sort E in nondecreasing order of the edge weights w(ei1)  . . .  w(ei|E|)
     ET  ;       ecounter  0           //initialize the set of tree edges and its size
     k0                                //initialize the number of processed edges
     while ecounter < |V | - 1 do
     kk+1
     if ET  {eik} is acyclic
                 ET  ET  {eik};        ecounter  ecounter + 1
     return ET
     The correctness of Kruskal's algorithm can be proved by repeating the essen-
     tial steps of the proof of Prim's algorithm given in the previous section. The fact
     that ET is actually a tree in Prim's algorithm but generally just an acyclic subgraph
     in Kruskal's algorithm turns out to be an obstacle that can be overcome.
     Figure 9.5 demonstrates the application of Kruskal's algorithm to the same
     graph we used for illustrating Prim's algorithm in Section 9.1. As you trace the
     algorithm's operations, note the disconnectedness of some of the intermediate
     subgraphs.
     Applying Prim's and Kruskal's algorithms to the same small graph by hand
     may create the impression that the latter is simpler than the former. This impres-
     sion is wrong because, on each of its iterations, Kruskal's algorithm has to check
     whether the addition of the next edge to the edges already selected would create a
                                3             4           4       6
                            a          5            f         5         d
                                                       2
                                       6         e            8
Tree edges          Sorted list of edges                                         Illustration
            bc  ef  ab  bf  cf     af     df  ae          cd  de                    1
            1   2   3   4   4      5      5      6        6   8
                                                                              b              c
                                                                           3     4        4     6
                                                                     a        5     f        5     d
                                                                                       2
                                                                              6     e        8
bc          bc  ef  ab  bf  cf     af     df  ae          cd  de                    1
1           1   2   3   4   4      5      5      6        6   8
                                                                              b              c
                                                                           3     4        4     6
                                                                     a        5     f        5     d
                                                                                       2
                                                                              6     e        8
ef          bc  ef  ab  bf  cf     af     df  ae          cd  de                    1
2           1   2   3   4   4      5      5      6        6   8
                                                                              b              c
                                                                           3     4        4     6
                                                                     a        5     f        5     d
                                                                                       2
                                                                              6     e        8
ab          bc  ef  ab  bf  cf     af     df  ae          cd  de                    1
3           1   2   3   4   4      5      5      6        6   8
                                                                              b              c
                                                                           3     4        4     6
                                                                     a        5     f        5     d
                                                                                       2
                                                                              6     e        8
bf          bc  ef  ab  bf  cf     af     df  ae          cd  de                    1
4           1   2   3   4   4      5      5      6        6   8
                                                                              b              c
                                                                           3     4        4     6
                                                                     a        5     f        5     d
                                                                                       2
                                                                              6     e        8
df
5
FIGURE 9.5  Application of Kruskal's   algorithm. Selected edges                 are shown in   bold.
                       v                     v
        u
                                                                    u
                 (a)                            (b)
FIGURE  9.6  New edge  connecting two  vertices may (a) or may not  (b)  create  a  cycle.
cycle. It is not difficult to see that a new cycle is created if and only if the new edge
connects two vertices already connected by a path, i.e., if and only if the two ver-
tices belong to the same connected component (Figure 9.6). Note also that each
connected component of a subgraph generated by Kruskal's algorithm is a tree
because it has no cycles.
In view of these observations, it is convenient to use a slightly different
interpretation of Kruskal's algorithm. We can consider the algorithm's operations
as a progression through a series of forests containing all the vertices of a given
graph and some of its edges. The initial forest consists of |V | trivial trees, each
comprising a single vertex of the graph. The final forest consists of a single tree,
which is a minimum spanning tree of the graph. On each iteration, the algorithm
takes the next edge (u, v) from the sorted list of the graph's edges, finds the trees
containing the vertices u and v, and, if these trees are not the same, unites them
in a larger tree by adding the edge (u, v).
Fortunately, there are efficient algorithms for doing so, including the crucial
check for whether two vertices belong to the same tree. They are called union-
find algorithms. We discuss them in the following subsection. With an efficient
union-find algorithm, the running time of Kruskal's algorithm will be dominated
by the time needed for sorting the edge weights of a given graph. Hence, with an
efficient sorting algorithm, the time efficiency of Kruskal's algorithm will be in
O(|E| log |E|).

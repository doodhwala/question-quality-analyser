Basic Efficiency Classes
Even though the efficiency analysis framework puts together all the functions
    whose orders of growth differ by a constant multiple, there are still infinitely many
    such classes. (For example, the exponential functions an have different orders of
    growth for different values of base a.) Therefore, it may come as a surprise that
    the time efficiencies of a large number of algorithms fall into only a few classes.
    These classes are listed in Table 2.2 in increasing order of their orders of growth,
    along with their names and a few comments.
         You could raise a concern that classifying algorithms by their asymptotic effi-
    ciency would be of little practical use since the values of multiplicative constants
    are usually left unspecified. This leaves open the possibility of an algorithm in a
    worse efficiency class running faster than an algorithm in a better efficiency class
    for inputs of realistic sizes. For example, if the running time of one algorithm is n3
    while the running time of the other is 106n2, the cubic algorithm will outperform
    the quadratic algorithm unless n exceeds 106. A few such anomalies are indeed
    known. Fortunately, multiplicative constants usually do not differ that drastically.
    As a rule, you should expect an algorithm from a better asymptotic efficiency class
    to outperform an algorithm from a worse class even for moderately sized inputs.
    This observation is especially true for an algorithm with a better than exponential
    running time versus an exponential (or worse) algorithm.
    Exercises 2.2
    1.   Use the most appropriate notation among O,                , and    to indicate the time
         efficiency class of sequential search (see Section 2.1)
         a.  in the worst case.
         b. in the best case.
         c.  in the average case.
    2.   Use the informal definitions of O,        , and  to determine whether the follow-
         ing assertions are true or false.
    TABLE 2.2    Basic asymptotic efficiency classes
    Class        Name                 Comments
    1            constant             Short of best-case efficiencies, very few reasonable
                                      examples can be given since an algorithm's running
                                      time typically goes to infinity when its input size grows
                                      infinitely large.
    log n        logarithmic          Typically, a result of cutting a problem's size by a
                                      constant factor on each iteration of the algorithm (see
                                      Section 4.4). Note that a logarithmic algorithm cannot
                                      take into account all its input or even a fixed fraction
                                      of it: any algorithm that does so will have at least linear
                                      running time.
    n            linear               Algorithms that scan a list of size n (e.g., sequential
                                      search) belong to this class.
    n log n      linearithmic         Many divide-and-conquer algorithms (see Chapter 5),
                                      including mergesort and quicksort in the average case,
                                      fall into this category.
    n2           quadratic            Typically, characterizes efficiency of algorithms with
                                      two embedded loops (see the next section). Elemen-
                                      tary sorting algorithms and certain operations on n × n
                                      matrices are standard examples.
    n3           cubic                Typically, characterizes efficiency of algorithms with
                                      three embedded loops (see the next section). Several
                                      nontrivial algorithms from linear algebra fall into this
                                      class.
    2n           exponential          Typical for algorithms that generate all subsets of an
                                      n-element set. Often, the term "exponential" is used
                                      in a broader sense to include this and larger orders of
                                      growth as well.
    n!           factorial            Typical for algorithms that generate all permutations
                                      of an n-element set.
        a. n(n + 1)/2  O(n3)             b.   n(n + 1)/2  O(n2)
        c. n(n + 1)/2          (n3)      d.   n(n + 1)/2        (n)
3.  For each of the following functions, indicate the class               (g(n)) the function
    belongs to. (Use the simplest g(n) possible in your answers.) Prove your
    assertions.
        a.  (n2 + 1)10                                   b.  10n2 + 7n + 3
        c.   2n  lg(n  +  2)2  +  (n  +  2)2  lg  n      d.  2n+1 + 3n-1
                                                  2
        e.   log2 n
    4.   a.  Table 2.1 contains values of several functions that often arise in the analysis
             of algorithms. These values certainly suggest that the functions
                            log n,      n,  n log2 n,        n2,  n3,  2n,  n!
             are listed in increasing order of their order of growth. Do these values
             prove this fact with mathematical certainty?
         b.  Prove that the functions are indeed listed in increasing order of their order
             of growth.
    5.   List the following functions according to their order of growth from the lowest
         to the highest:
             (n - 2)!,    5 lg(n + 100)10,  22n,       0.001n4 + 3n3 + 1,   ln2 n,  3 n,  3n.
    6.   a.  Prove that every polynomial of degree k, p(n) = aknk + ak-1nk-1 + . . . + a0
             with ak > 0, belongs to        (nk).
         b.  Prove that exponential functions an have different orders of growth for
             different values of base a > 0.
    7.   Prove the following assertions by using the definitions of the notations in-
         volved, or disprove them by giving a specific counterexample.
         a.  If t (n)  O(g(n)), then g(n)          (t (n)).
         b.  (g(n)) =       (g(n)), where  > 0.
         c.  (g(n)) = O(g(n))           (g(n)).
         d. For any two nonnegative functions t (n) and g(n) defined on the set of
             nonnegative integers, either t (n)  O(g(n)), or t (n)          (g(n)), or both.
    8.   Prove the section's theorem for
             a.  notation.          b.      notation.
    9.   We mentioned in this section that one can check whether all elements of an
         array are distinct by a two-part algorithm based on the array's presorting.
         a.  If the presorting is done by an algorithm with a time efficiency in    (n log n),
             what will be a time-efficiency class of the entire algorithm?
         b. If the sorting algorithm used for presorting needs an extra array of size n,
             what will be the space-efficiency class of the entire algorithm?
    10.  The range of a finite nonempty set of n real numbers S is defined as the differ-
         ence between the largest and smallest elements of S. For each representation
         of S given below, describe in English an algorithm to compute the range. Indi-
         cate the time efficiency classes of these algorithms using the most appropriate
         notation (O,     , or  ).
         a.  An unsorted array
         b. A sorted array
         c.  A sorted singly linked list
         d. A binary search tree
     11.  Lighter or heavier?    You have n > 2 identical-looking coins and a two-pan
          balance scale with no weights. One of the coins is a fake, but you do not know
          whether it is lighter or heavier than the genuine coins, which all weigh the
          same. Design a  (1) algorithm to determine whether the fake coin is lighter
          or heavier than the others.
     12.  Door in a wall  You are facing a wall that stretches infinitely in both direc-
          tions. There is a door in the wall, but you know neither how far away nor in
          which direction. You can see the door only when you are right next to it. De-
          sign an algorithm that enables you to reach the door by walking at most O(n)
          steps where n is the (unknown to you) number of steps between your initial
          position and the door. [Par95]

Interpolation Search
As the next example of a variable-size-decrease algorithm, we consider an algo-
rithm for searching in a sorted array called interpolation search. Unlike binary
search, which always compares a search key with the middle value of a given sorted
array (and hence reduces the problem's instance size by half), interpolation search
takes into account the value of the search key in order to find the array's element
to be compared with the search key. In a sense, the algorithm mimics the way we
                  value
                  A[r ]
                  v
                  A[l ]
                           l     x            r                  index
     FIGURE 4.14  Index computation in interpolation search.
     search for a name in a telephone book: if we are searching for someone named
     Brown, we open the book not in the middle but very close to the beginning, unlike
     our action when searching for someone named, say, Smith.
     More precisely, on the iteration dealing with the array's portion between the
     leftmost element A[l] and the rightmost element A[r], the algorithm assumes
     that the array values increase linearly, i.e., along the straight line through the
     points (l, A[l]) and (r, A[r]). (The accuracy of this assumption can influence the
     algorithm's efficiency but not its correctness.) Accordingly, the search key's value
     v is compared with the element whose index is computed as (the round-off of)
     the x coordinate of the point on the straight line through the points (l, A[l]) and
     (r, A[r]) whose y coordinate is equal to the search value v (Figure 4.14).
     Writing down a standard equation for the straight line passing through the
     points (l, A[l]) and (r, A[r]), substituting v for y, and solving it for x leads to the
     following formula:
                           x=l+  (v - A[l])(r - l)            .                  (4.6)
                                 A[r] - A[l]
     The logic behind this approach is quite straightforward. We know that the
     array values are increasing (more accurately, not decreasing) from A[l] to A[r],
     but we do not know how they do it. Had these values increased linearly, which is
     the simplest manner possible, the index computed by formula (4.4) would be the
     expected location of the array's element with the value equal to v. Of course, if v
     is not between A[l] and A[r], formula (4.4) need not be applied (why?).
     After comparing v with A[x], the algorithm either stops (if they are equal)
     or proceeds by searching in the same manner among the elements indexed either
between l and x - 1 or between x + 1 and r, depending on whether A[x] is smaller
or larger than v. Thus, the size of the problem's instance is reduced, but we cannot
tell a priori by how much.
The analysis of the algorithm's efficiency shows that interpolation search uses
fewer than log2 log2 n + 1 key comparisons on the average when searching in a list
of n random keys. This function grows so slowly that the number of comparisons
is a very small constant for all practically feasible inputs (see Problem 6 in this
section's exercises). But in the worst case, interpolation search is only linear, which
must be considered a bad performance (why?).
Assessing the worthiness of interpolation search versus that of binary search,
Robert Sedgewick wrote in the second edition of his Algorithms that binary search
is probably better for smaller files but interpolation search is worth considering
for large files and for applications where comparisons are particularly expensive
or access costs are very high. Note that in Section 12.4 we discuss a continuous
counterpart of interpolation search, which can be seen as one more example of a
variable-size-decrease algorithm.

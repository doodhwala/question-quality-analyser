As we discussed at the beginning of this chapter and illustrated in subsequent
     sections, dynamic programming deals with problems whose solutions satisfy a
     recurrence relation with overlapping subproblems. The direct top-down approach
     to finding a solution to such a recurrence leads to an algorithm that solves common
     subproblems more than once and hence is very inefficient (typically, exponential
or worse). The classic dynamic programming approach, on the other hand, works
bottom up: it fills a table with solutions to all smaller subproblems, but each of
them is solved only once. An unsatisfying aspect of this approach is that solutions
to some of these smaller subproblems are often not necessary for getting a solution
to the problem given. Since this drawback is not present in the top-down approach,
it is natural to try to combine the strengths of the top-down and bottom-up
approaches. The goal is to get a method that solves only subproblems that are
necessary and does so only once. Such a method exists; it is based on using memory
functions.
This method solves a given problem in the top-down manner but, in addition,
maintains a table of the kind that would have been used by a bottom-up dynamic
programming algorithm. Initially, all the table's entries are initialized with a spe-
cial "null" symbol to indicate that they have not yet been calculated. Thereafter,
whenever a new value needs to be calculated, the method checks the correspond-
ing entry in the table first: if this entry is not "null," it is simply retrieved from the
table; otherwise, it is computed by the recursive call whose result is then recorded
in the table.
The following algorithm implements this idea for the knapsack problem. After
initializing the table, the recursive function needs to be called with i = n (the
number of items) and j = W (the knapsack capacity).
ALGORITHM           MFKnapsack(i, j )
//Implements the memory function method for the knapsack problem
//Input: A nonnegative integer i indicating the number of the first
//             items being considered and a nonnegative integer j indicating
//             the knapsack capacity
//Output: The value of an optimal feasible subset of the first i items
//Note: Uses as global variables input arrays W eights[1..n], V alues[1..n],
//and table F [0..n, 0..W ] whose entries are initialized with -1's except for
//row 0 and column 0 initialized with 0's
if F [i, j ] < 0
    if j < Weights[i]
               value  MFKnapsack(i - 1, j )
    else
               value  max(MFKnapsack(i - 1, j ),
                       Values[i] + MFKnapsack(i - 1, j - Weights[i]))
    F [i, j ]  value
return F [i, j ]
EXAMPLE 2      Let us apply the memory function method to the instance consid-
ered in Example 1. The table in Figure 8.6 gives the results. Only 11 out of 20
nontrivial values (i.e., not those in row 0 or in column 0) have been computed.
                                                      capacity j
                                 i      0         1   2      3    4         5
                                 0      0         0   0      0    0         0
             w1 = 2, v1 = 12     1      0         0   12     12   12        12
             w2 = 1, v2 = 10     2      0         --  12     22   --        22
             w3 = 3, v3 = 20     3      0         --  --     22   --        32
             w4 = 2, v4 = 15     4      0         --  --     --   --        37
     FIGURE 8.6 Example of solving  an  instance of   the knapsack problem  by the  memory
             function algorithm.
     Just one nontrivial entry, V (1, 2), is retrieved rather than being recomputed. For
     larger instances, the proportion of such entries can be significantly larger.
         In general, we cannot expect more than a constant-factor gain in using the
     memory function method for the knapsack problem, because its time efficiency
     class is the same as that of the bottom-up algorithm (why?). A more significant
     improvement can be expected for dynamic programming algorithms in which a
     computation of one value takes more than constant time. You should also keep in
     mind that a memory function algorithm may be less space-efficient than a space-
     efficient version of a bottom-up algorithm.
     Exercises 8.2
     1.  a.  Apply the bottom-up dynamic programming algorithm to the following
             instance of the knapsack problem:
                          item          weight        value
                              1         3             $25
                              2         2             $20
                              3         1             $15    capacity W = 6.
                              4         4             $40
                              5         5             $50
         b.  How many different optimal subsets does the instance of part (a) have?
         c.  In general, how can we use the table generated by the dynamic program-
             ming algorithm to tell whether there is more than one optimal subset for
             the knapsack problem's instance?
     2.  a.  Write pseudocode of the bottom-up dynamic programming algorithm for
             the knapsack problem.
         b.  Write pseudocode of the algorithm that finds the composition of an optimal
             subset from the table generated by the bottom-up dynamic programming
             algorithm for the knapsack problem.
     3.  For the bottom-up dynamic programming algorithm for the knapsack prob-
         lem, prove that
         a.  its time efficiency is  (nW ).
         b. its space efficiency is  (nW ).
         c.  the time needed to find the composition of an optimal subset from a filled
             dynamic programming table is O(n).
     4.  a.  True or false: A sequence of values in a row of the dynamic programming
             table for the knapsack problem is always nondecreasing?
         b. True or false: A sequence of values in a column of the dynamic program-
             ming table for the knapsack problem is always nondecreasing?
     5.  Design a dynamic programming algorithm for the version of the knapsack
         problem in which there are unlimited quantities of copies for each of the n
         item kinds given. Indicate the time efficiency of the algorithm.
     6.  Apply the memory function method to the instance of the knapsack problem
         given in Problem 1. Indicate the entries of the dynamic programming table
         that are (i) never computed by the memory function method, (ii) retrieved
         without a recomputation.
     7.  Prove that the efficiency class of the memory function algorithm for the knap-
         sack problem is the same as that of the bottom-up algorithm (see Problem 3).
     8.  Explain why the memory function approach is unattractive for the problem of
         computing a binomial coefficient by the formula C(n, k) = C(n - 1, k - 1) +
         C(n - 1, k).
     9.  Write a research report on one of the following well-known applications of
         dynamic programming:
         a.  finding the longest common subsequence in two sequences
         b. optimal string editing
         c.  minimal triangulation of a polygon

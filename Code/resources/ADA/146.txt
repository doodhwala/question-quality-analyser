Generating Subsets
Recall that in Section 3.4 we examined the knapsack problem, which asks to find
     the most valuable subset of items that fits a knapsack of a given capacity. The
     exhaustive-search approach to solving this problem discussed there was based on
     generating all subsets of a given set of items. In this section, we discuss algorithms
     for generating all 2n subsets of an abstract set A = {a1, . . . , an}. (Mathematicians
     call the set of all subsets of a set its power set.)
     The decrease-by-one idea is immediately applicable to this problem, too. All
     subsets of A = {a1, . . . , an} can be divided into two groups: those that do not
     contain an and those that do. The former group is nothing but all the subsets of
     {a1, . . . , an-1}, while each and every element of the latter can be obtained by
     adding an to a subset of {a1, . . . , an-1}. Thus, once we have a list of all subsets of
     {a1, . . . , an-1}, we can get all the subsets of {a1, . . . , an} by adding to the list all
     its elements with an put into each of them.           An application of this algorithm to
     generate all subsets of {a1, a2, a3} is illustrated in Figure 4.10.
     Similarly to generating permutations, we do not have to generate power sets of
     smaller sets. A convenient way of solving the problem directly is based on a one-to-
     one correspondence between all 2n subsets of an n element set A = {a1, . . . , an}
n                                       subsets
0        
1               {a1}
2               {a1}    {a2}  {a1, a2}
3               {a1}    {a2}  {a1, a2}  {a3}           {a1, a3}   {a2, a3}      {a1, a2, a3}
FIGURE 4.10 Generating subsets bottom up.
and all 2n bit strings b1, . . . , bn of length n. The easiest way to establish such a
correspondence is to assign to a subset the bit string in which bi = 1 if ai belongs
to the subset and bi = 0 if ai does not belong to it. (We mentioned this idea of bit
vectors in Section 1.4.) For example, the bit string 000 will correspond to the empty
subset of a three-element set, 111 will correspond to the set itself, i.e., {a1, a2, a3},
and 110 will represent {a1, a2}. With this correspondence in place, we can generate
all the bit strings of length n by generating successive binary numbers from 0 to
2n - 1, padded, when necessary, with an appropriate number of leading 0's. For
example, for the case of n = 3, we obtain
   bit strings   000    001   010       011       100        101       110      111
   subsets              {a3}  {a2}      {a2, a3}  {a1}  {a1, a3}      {a1, a2}  {a1, a2, a3}
   Note that although the bit strings are generated by this algorithm in lexico-
graphic order (in the two-symbol alphabet of 0 and 1), the order of the subsets
looks anything but natural. For example, we might want to have the so-called
squashed order, in which any subset involving aj can be listed only after all the
subsets involving a1, . . . , aj-1, as was the case for the list of the three-element set
in Figure 4.10. It is easy to adjust the bit string­based algorithm above to yield a
squashed ordering of the subsets involved (see Problem 6 in this section's exer-
cises).
   A more challenging question is whether there exists a minimal-change algo-
rithm for generating bit strings so that every one of them differs from its immediate
predecessor by only a single bit. (In the language of subsets, we want every subset
to differ from its immediate predecessor by either an addition or a deletion, but
not both, of a single element.) The answer to this question is yes. For example, for
n = 3, we can get
                        000   001  011  010       110   111      101  100.
Such a sequence of bit strings is called the binary reflected Gray code. Frank Gray,
a researcher at AT&T Bell Laboratories, reinvented it in the 1940s to minimize
the effect of errors in transmitting digital signals (see, e.g., [Ros07], pp. 642­
643). Seventy years earlier, the French engineer E´ mile Baudot used such codes
     in telegraphy. Here is pseudocode that generates the binary reflected Gray code
     recursively.
     ALGORITHM         BRGC(n)
         //Generates recursively the binary reflected Gray code of order n
         //Input: A positive integer n
         //Output: A list of all bit strings of length n composing the Gray code
         if n = 1 make list L containing bit strings 0 and 1 in this order
         else generate list L1 of bit strings of size n - 1 by calling BRGC(n - 1)
             copy list L1 to list L2 in reversed order
             add 0 in front of each bit string in list L1
             add 1 in front of each bit string in list L2
             append L2 to L1 to get list L
         return L
         The correctness of the algorithm stems from the fact that it generates 2n bit
     strings and all of them are distinct. Both these assertions are easy to check by
     mathematical induction. Note that the binary reflected Gray code is cyclic: its last
     bit string differs from the first one by a single bit. For a nonrecursive algorithm for
     generating the binary reflected Gray code see Problem 9 in this section's exercises.
     Exercises 4.3
     1.  Is it realistic to implement an algorithm that requires generating all permu-
         tations of a 25-element set on your computer? What about all the subsets of
         such a set?
     2.  Generate all permutations of {1, 2, 3, 4} by
         a.  the bottom-up minimal-change algorithm.
         b. the Johnson-Trotter algorithm.
         c.  the lexicographic-order algorithm.
     3.  Apply LexicographicPermute to multiset {1, 2, 2, 3}. Does it generate correctly
         all the permutations in lexicographic order?
     4.  Consider the following implementation of the algorithm for generating per-
         mutations discovered by B. Heap [Hea63].
         ALGORITHM          HeapPermute(n)
             //Implements Heap's algorithm for generating permutations
             //Input: A positive integer n and a global array A[1..n]
             //Output: All permutations of elements of A
             if n = 1
                   write A
         else
                for i  1 to n do
                HeapPermute(n - 1)
                if n is odd
                      swap A[1] and A[n]
                else swap A[i] and A[n]
     a.  Trace the algorithm by hand for n = 2, 3, and 4.
     b. Prove the correctness of Heap's algorithm.
     c.  What is the time efficiency of HeapPermute?
5.   Generate all the subsets of a four-element set A = {a1, a2, a3, a4} by each of
     the two algorithms outlined in this section.
6.   What simple trick would make the bit string­based algorithm generate subsets
     in squashed order?
7.   Write pseudocode for a recursive algorithm for generating all 2n bit strings of
     length n.
8.   Write a nonrecursive algorithm for generating 2n bit strings of length n that
     implements bit strings as arrays and does not use binary additions.
9.   a.  Generate the binary reflexive Gray code of order 4.
     b.  Trace the following nonrecursive algorithm to generate the binary re-
         flexive Gray code of order 4. Start with the n-bit string of all 0's. For
         i = 1, 2, . . . , 2n-1, generate the ith bit string by flipping bit b in the previ-
         ous bit string, where b is the position of the least significant 1 in the binary
         representation of i.
10.  Design a decrease-and-conquer algorithm for generating all combinations of
     k items chosen from n, i.e., all k-element subsets of a given n-element set. Is
     your algorithm a minimal-change algorithm?
11.  Gray code and the Tower of Hanoi
     a.  Show that the disk moves made in the classic recursive algorithm for the
         Tower of Hanoi puzzle can be used for generating the binary reflected Gray
         code.
     b. Show how the binary reflected Gray code can be used for solving the Tower
         of Hanoi puzzle.
12.  Fair attraction  In olden days, one could encounter the following attraction
     at a fair. A light bulb was connected to several switches in such a way that it
     lighted up only when all the switches were closed. Each switch was controlled
     by a push button; pressing the button toggled the switch, but there was no
     way to know the state of the switch. The object was to turn the light bulb on.
     Design an algorithm to turn on the light bulb with the minimum number of
     button pushes needed in the worst case for n switches.
     
Most algorithms are destined to be ultimately implemented as computer pro-
    grams. Programming an algorithm presents both a peril and an opportunity. The
    peril lies in the possibility of making the transition from an algorithm to a pro-
    gram either incorrectly or very inefficiently. Some influential computer scientists
    strongly believe that unless the correctness of a computer program is proven
    with full mathematical rigor, the program cannot be considered correct. They
    have developed special techniques for doing such proofs (see [Gri81]), but the
    power of these techniques of formal verification is limited so far to very small
    programs.
    As a practical matter, the validity of programs is still established by testing.
    Testing of computer programs is an art rather than a science, but that does not
    mean that there is nothing in it to learn. Look up books devoted to testing
    and debugging; even more important, test and debug your program thoroughly
    whenever you implement an algorithm.
    Also note that throughout the book, we assume that inputs to algorithms
    belong to the specified sets and hence require no verification. When implementing
    algorithms as programs to be used in actual applications, you should provide such
    verifications.
    Of course, implementing an algorithm correctly is necessary but not sufficient:
    you would not like to diminish your algorithm's power by an inefficient implemen-
    tation. Modern compilers do provide a certain safety net in this regard, especially
    when they are used in their code optimization mode. Still, you need to be aware
    of such standard tricks as computing a loop's invariant (an expression that does
    not change its value) outside the loop, collecting common subexpressions, replac-
    ing expensive operations by cheap ones, and so on. (See [Ker99] and [Ben00] for
    a good discussion of code tuning and other issues related to algorithm program-
    ming.) Typically, such improvements can speed up a program only by a constant
    factor, whereas a better algorithm can make a difference in running time by orders
    of magnitude. But once an algorithm is selected, a 10­50% speedup may be worth
    an effort.
1.  I found this call for design simplicity in an essay collection by Jon Bentley [Ben00]; the essays deal
    with a variety of issues in algorithm design and implementation and are justifiably titled Programming
    Pearls. I wholeheartedly recommend the writings of both Jon Bentley and Antoine de Saint-Exupe´ ry.
    A working program provides an additional opportunity in allowing an em-
    pirical analysis of the underlying algorithm. Such an analysis is based on timing
    the program on several inputs and then analyzing the results obtained. We dis-
    cuss the advantages and disadvantages of this approach to analyzing algorithms
    in Section 2.6.
    In conclusion, let us emphasize again the main lesson of the process depicted
    in Figure 1.2:
    As a rule, a good algorithm is a result of repeated effort and rework.
    Even if you have been fortunate enough to get an algorithmic idea that seems
    perfect, you should still try to see whether it can be improved.
    Actually, this is good news since it makes the ultimate result so much more
    enjoyable. (Yes, I did think of naming this book The Joy of Algorithms.) On the
    other hand, how does one know when to stop? In the real world, more often than
    not a project's schedule or the impatience of your boss will stop you. And so it
    should be: perfection is expensive and in fact not always called for. Designing
    an algorithm is an engineering-like activity that calls for compromises among
    competing goals under the constraints of available resources, with the designer's
    time being one of the resources.
    In the academic world, the question leads to an interesting but usually difficult
    investigation of an algorithm's optimality. Actually, this question is not about the
    efficiency of an algorithm but about the complexity of the problem it solves: What
    is the minimum amount of effort any algorithm will need to exert to solve the
    problem? For some problems, the answer to this question is known. For example,
    any algorithm that sorts an array by comparing values of its elements needs about
    n log2 n comparisons for some arrays of size n (see Section 11.2). But for many
    seemingly easy problems such as integer multiplication, computer scientists do
    not yet have a final answer.
    Another important issue of algorithmic problem solving is the question of
    whether or not every problem can be solved by an algorithm. We are not talking
    here about problems that do not have a solution, such as finding real roots of
    a quadratic equation with a negative discriminant. For such cases, an output
    indicating that the problem does not have a solution is all we can and should
    expect from an algorithm. Nor are we talking about ambiguously stated problems.
    Even some unambiguous problems that must have a simple yes or no answer are
    "undecidable," i.e., unsolvable by any algorithm. An important example of such
    a problem appears in Section 11.3. Fortunately, a vast majority of problems in
    practical computing can be solved by an algorithm.
    Before          leaving  this  section,  let  us   be  sure  that  you  do  not  have   the
    misconception--possibly        caused    by   the  somewhat  mechanical     nature  of  the
    diagram of Figure 1.2--that designing an algorithm is a dull activity. There is
    nothing further from the truth: inventing (or discovering?) algorithms is a very
    creative and rewarding process. This book is designed to convince you that this is
    the case.
Exercises 1.2
1.  Old World puzzle            A peasant finds himself on a riverbank with a wolf, a goat,
    and a head of cabbage. He needs to transport all three to the other side of the
    river in his boat. However, the boat has room for only the peasant himself
    and one other item (either the wolf, the goat, or the cabbage). In his absence,
    the wolf would eat the goat, and the goat would eat the cabbage. Solve this
    problem for the peasant or prove it has no solution. (Note: The peasant is a
    vegetarian but does not like cabbage and hence can eat neither the goat nor
    the cabbage to help him solve the problem. And it goes without saying that
    the wolf is a protected species.)
2.  New World puzzle            There are four people who want to cross a rickety bridge;
    they all begin on the same side. You have 17 minutes to get them all across
    to the other side. It is night, and they have one flashlight. A maximum of two
    people can cross the bridge at one time. Any party that crosses, either one or
    two people, must have the flashlight with them. The flashlight must be walked
    back and forth; it cannot be thrown, for example. Person 1 takes 1 minute
    to cross the bridge, person 2 takes 2 minutes, person 3 takes 5 minutes, and
    person 4 takes 10 minutes. A pair must walk together at the rate of the slower
    person's pace. (Note: According to a rumor on the Internet, interviewers at a
    well-known software company located near Seattle have given this problem
    to interviewees.)
3.  Which of the following formulas can be considered an algorithm for comput-
    ing the area of a triangle whose side lengths are given positive numbers a, b,
    and c?
    a.  S=       p(p - a)(p - b)(p - c), where p = (a + b + c)/2
    b.  S=    1  bc  sin  A,  where     A  is  the  angle  between  sides  b  and  c
              2
    c.  S  =  1  aha  ,  where  ha  is  the    height  to  base  a
              2
4.  Write pseudocode for an algorithm for finding real roots of equation ax2 +
    bx + c = 0 for arbitrary real coefficients a, b, and c. (You may assume the
    availability of the square root function sqrt (x).)
5.  Describe the standard algorithm for finding the binary representation of a
    positive decimal integer
    a.  in English.
    b. in pseudocode.
6.  Describe the algorithm used by your favorite ATM machine in dispensing
    cash. (You may give your description in either English or pseudocode, which-
    ever you find more convenient.)
7.  a.  Can the problem of computing the number                     be solved exactly?
    b. How many instances does this problem have?
    c.  Look up an algorithm for this problem on the Internet.
         8.   Give an example of a problem other than computing the greatest common
              divisor for which you know more than one algorithm. Which of them is
              simpler? Which is more efficient?
         9.   Consider the following algorithm for finding the distance between the two
              closest elements in an array of numbers.
              ALGORITHM          MinDistance(A[0..n - 1])
              //Input: Array A[0..n - 1] of numbers
              //Output: Minimum distance between two of its elements
              dmin  
                       for i  0 to n - 1 do
                          for j  0 to n - 1 do
                                 if i = j and |A[i] - A[j ]| < dmin
                                 dmin  |A[i] - A[j ]|
              return dmin
              Make as many improvements as you can in this algorithmic solution to the
              problem. If you need to, you may change the algorithm altogether; if not,
              improve the implementation given.
         10.  One of the most influential books on problem solving, titled How To Solve
              It [Pol57], was written by the Hungarian-American mathematician George
              Po´ lya (1887­1985). Po´ lya summarized his ideas in a four-point summary. Find
              this summary on the Internet or, better yet, in his book, and compare it with
              the plan outlined in Section 1.2. What do they have in common? How are they
              different?
    
Using the formal definitions of the asymptotic notations, we can prove their
general properties (see Problem 7 in this section's exercises for a few simple
examples). The following property, in particular, is useful in analyzing algorithms
that comprise two consecutively executed parts.
    THEOREM         If t1(n)  O(g1(n)) and t2(n)  O(g2(n)), then
                          t1(n) + t2(n)  O(max{g1(n), g2(n)}).
    (The analogous assertions are true for the             and   notations as well.)
    PROOF     The proof extends to orders of growth the following simple fact about
    four arbitrary real numbers a1, b1, a2, b2: if a1  b1 and a2  b2, then a1 + a2 
    2 max{b1, b2}.
    Since t1(n)  O(g1(n)), there exist some positive constant c1 and some non-
    negative integer n1 such that
                          t1(n)  c1g1(n)            for all n  n1.
    Similarly, since t2(n)  O(g2(n)),
                          t2(n)  c2g2(n)            for all n  n2.
    Let us denote c3 = max{c1, c2} and consider n  max{n1, n2} so that we can use
    both inequalities. Adding them yields the following:
                    t1(n) + t2(n)  c1g1(n) + c2g2(n)
                                    c3g1(n) + c3g2(n) = c3[g1(n) + g2(n)]
                                    c32 max{g1(n), g2(n)}.
    Hence, t1(n) + t2(n)  O(max{g1(n), g2(n)}), with the constants c and n0 required
    by the O definition being 2c3 = 2 max{c1, c2} and max{n1, n2}, respectively.
    So what does this property imply for an algorithm that comprises two consec-
    utively executed parts? It implies that the algorithm's overall efficiency is deter-
    mined by the part with a higher order of growth, i.e., its least efficient part:
                 t1(n)  O(g1(n))           t1(n) + t2(n)  O(max{g1(n), g2(n)}).
                 t2(n)  O(g2(n))
    For example, we can check whether an array has equal elements by the following
    two-part algorithm: first, sort the array by applying some known sorting algorithm;
    second, scan the sorted array to check its consecutive elements for equality. If, for
    example,  a  sorting  algorithm  used  in  the  first  part  makes  no  more  than  1  n(n  -  1)
                                                                                        2
    comparisons (and hence is in O(n2)) while the second part makes no more than
    n - 1 comparisons (and hence is in O(n)), the efficiency of the entire algorithm
    will be in O(max{n2, n}) = O(n2).

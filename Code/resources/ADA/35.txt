Sets and Dictionaries
The notion of a set plays a central role in mathematics. A set can be described as
               an unordered collection (possibly empty) of distinct items called elements of the
      a  null                                                                              a
      b        null  d                        e       null                           b
      c        null  g      null      null    f       null                   c             d
null  h        null  i      null                            h                     g                e
                                                                         i                    f
                     (a)                                                          (b)
               FIGURE 1.14  (a) First child­next sibling representation  of  the  tree in  Figure  1.11b.  (b)  Its
                            binary tree representation.
    set. A specific set is defined either by an explicit listing of its elements (e.g., S = {2,
    3, 5, 7}) or by specifying a property that all the set's elements and only they must
    satisfy (e.g., S = {n: n is a prime number smaller than 10}). The most important set
    operations are: checking membership of a given item in a given set; finding the
    union of two sets, which comprises all the elements in either or both of them; and
    finding the intersection of two sets, which comprises all the common elements in
    the sets.
    Sets can be implemented in computer applications in two ways. The first
    considers only sets that are subsets of some large set U, called the universal
    set. If set U has n elements, then any subset S of U can be represented by a bit
    string of size n, called a bit vector, in which the ith element is 1 if and only if
    the ith element of U is included in set S. Thus, to continue with our example, if
    U = {1, 2, 3, 4, 5, 6, 7, 8, 9}, then S = {2, 3, 5, 7} is represented by the bit string
    011010100. This way of representing sets makes it possible to implement the
    standard set operations very fast, but at the expense of potentially using a large
    amount of storage.
    The second and more common way to represent a set for computing purposes
    is to use the list structure to indicate the set's elements. Of course, this option, too,
    is feasible only for finite sets; fortunately, unlike mathematics, this is the kind of
    sets most computer applications need. Note, however, the two principal points of
    distinction between sets and lists. First, a set cannot contain identical elements;
    a list can. This requirement for uniqueness is sometimes circumvented by the
    introduction of a multiset, or bag, an unordered collection of items that are not
    necessarily distinct. Second, a set is an unordered collection of items; therefore,
    changing the order of its elements does not change the set. A list, defined as an
    ordered collection of items, is exactly the opposite. This is an important theoretical
    distinction, but fortunately it is not important for many applications. It is also
    worth mentioning that if a set is represented by a list, depending on the application
    at hand, it might be worth maintaining the list in a sorted order.
    In computing, the operations we need to perform for a set or a multiset most
    often are searching for a given item, adding a new item, and deleting an item
    from the collection. A data structure that implements these three operations is
    called the dictionary. Note the relationship between this data structure and the
    problem of searching mentioned in Section 1.3; obviously, we are dealing here
    with searching in a dynamic context. Consequently, an efficient implementation
    of a dictionary has to strike a compromise between the efficiency of searching and
    the efficiencies of the other two operations. There are quite a few ways a dictionary
    can be implemented. They range from an unsophisticated use of arrays (sorted or
    not) to much more sophisticated techniques such as hashing and balanced search
    trees, which we discuss later in the book.
    A number of applications in computing require a dynamic partition of some
    n-element set into a collection of disjoint subsets. After being initialized as a
    collection of n one-element subsets, the collection is subjected to a sequence
    of intermixed union and search operations. This problem is called the set union
    problem. We discuss efficient algorithmic solutions to this problem in Section 9.2,
    in conjunction with one of its important applications.
    You may have noticed that in our review of basic data structures we almost al-
ways mentioned specific operations that are typically performed for the structure
in question. This intimate relationship between the data and operations has been
recognized by computer scientists for a long time. It has led them in particular
to the idea of an abstract data type (ADT): a set of abstract objects represent-
ing data items with a collection of operations that can be performed on them. As
illustrations of this notion, reread, say, our definitions of the priority queue and
dictionary. Although abstract data types could be implemented in older procedu-
ral languages such as Pascal (see, e.g., [Aho83]), it is much more convenient to
do this in object-oriented languages such as C++ and Java, which support abstract
data types by means of classes.
Exercises 1.4
1.  Describe how one can implement each of the following operations on an array
    so that the time it takes does not depend on the array's size n.
    a.  Delete the ith element of an array (1  i  n).
    b. Delete the ith element of a sorted array (the remaining array has to stay
        sorted, of course).
2.  If you have to solve the searching problem for a list of n numbers, how can you
    take advantage of the fact that the list is known to be sorted? Give separate
    answers for
    a.  lists represented as arrays.
    b. lists represented as linked lists.
3.  a.  Show the stack after each operation of the following sequence that starts
        with the empty stack:
                 push(a), push(b), pop, push(c), push(d), pop
    b.  Show the queue after each operation of the following sequence that starts
        with the empty queue:
        enqueue(a), enqueue(b), dequeue, enqueue(c), enqueue(d), dequeue
4.  a.  Let A be the adjacency matrix of an undirected graph. Explain what prop-
        erty of the matrix indicates that
        i. the graph is complete.
        ii. the graph has a loop, i.e., an edge connecting a vertex to itself.
        iii. the graph has an isolated vertex, i.e., a vertex with no edges incident
        to it.
    b. Answer the same questions for the adjacency list representation.
5.  Give a detailed description of an algorithm for transforming a free tree into
    a tree rooted at a given vertex of the free tree.
    6.   Prove the inequalities that bracket the height of a binary tree with n vertices:
                                    log2 n   h  n - 1.
    7.   Indicate how the ADT priority queue can be implemented as
         a.  an (unsorted) array.
         b. a sorted array.
         c.  a binary search tree.
    8.   How would you implement a dictionary of a reasonably small size n if you
         knew that all its elements are distinct (e.g., names of the 50 states of the United
         States)? Specify an implementation of each dictionary operation.
    9.   For each of the following applications, indicate the most appropriate data
         structure:
         a.  answering telephone calls in the order of their known priorities
         b. sending backlog orders to customers in the order they have been received
         c.  implementing a calculator for computing simple arithmetical expressions
    10.  Anagram checking    Design an algorithm for checking whether two given
         words are anagrams, i.e., whether one word can be obtained by permuting
         the letters of the other. For example, the words tea and eat are anagrams.
    SUMMARY
         An algorithm is a sequence of nonambiguous instructions for solving a
         problem in a finite amount of time. An input to an algorithm specifies an
         instance of the problem the algorithm solves.
         Algorithms can be specified in a natural language or pseudocode; they can
         also be implemented as computer programs.
         Among several ways to classify algorithms, the two principal alternatives are:
         .   to group algorithms according to types of problems they solve
         .   to group algorithms according to underlying design techniques they are
             based upon
         The important problem types are sorting, searching, string processing, graph
         problems, combinatorial problems, geometric problems, and numerical
         problems.
         Algorithm design techniques (or "strategies" or "paradigms") are general
         approaches to solving problems algorithmically, applicable to a variety of
         problems from different areas of computing.
Although designing an algorithm is undoubtedly a creative activity, one can
identify a sequence of interrelated actions involved in such a process. They
are summarized in Figure 1.2.
A good algorithm is usually the result of repeated efforts and rework.
The same problem can often be solved by several algorithms. For example,
three algorithms were given for computing the greatest common divisor of
two integers: Euclid's algorithm, the consecutive integer checking algorithm,
and the middle-school method enhanced by the sieve of Eratosthenes for
generating a list of primes.
Algorithms operate on data. This makes the issue of data structuring critical
for efficient algorithmic problem solving. The most important elementary data
structures are the array and the linked list. They are used for representing
more abstract data structures such as the list, the stack, the queue, the graph
(via its adjacency matrix or adjacency lists), the binary tree, and the set.
An abstract collection of objects with several operations that can be per-
formed on them is called an abstract data type (ADT). The list, the stack, the
queue, the priority queue, and the dictionary are important examples of ab-
stract data types. Modern object-oriented languages support implementation
of ADTs by means of classes.


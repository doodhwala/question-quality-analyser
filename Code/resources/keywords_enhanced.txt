attaching
tournament
expanding
tetrominoes
jugs
unstable
maze
levin
knights
soldiers
shellsort
glasses
survivor
cramer
wife
reverse
quarter
rumors
ecounter
cook
courses
prefers
roommates
topologies
tetromino
gadget
battleship
alphametic
bridges
transformed
consistent
arguments
underflow
prerequisites
excellent
spider
squashed
heappermute
switches
pancakes
gloves
celebrity
experimenter
seed
priorities
representatives
assigning
basis
slope
terminate
cycling
ahu
preflow
persons
gender
proposals
college
candidates
activity
route
aspects
rework
conjunction
nigsberg
stroll
pennies
irrevocable
cheapest
czech
earliest
vessels
messages
gnew
subgraphs
eik
roads
decoding
deck
cards
spades
transforming
dominated
digraphs
forwardelimination
endowment
undecidable
impossibility
decidable
breakthrough
iteratively
boys
prerequisite
button
halving
ready
firm
opponents
metrics
tigers
nails
tours
cryptarithm
dudeney
restarted
accompany
orderings
measures
twofold
socks
grain
inspecting
monks
homogeneous
inhomogeneous
unix
contained
increased
inaccurate
cwbsorst
chromatic
lowercase
npc
quarrel
shore
drink
kor
victory
popping
beneficial
johnsontrotter
lexicographicpermute
brgc
flipping
attraction
outright
addends
jewish
romans
surrender
pictures
lomutopartition
linearly
interactive
flipper
villages
understanding
familiar
internet
procedures
recipe
nowadays
designer
opportunity
defining
rumor
subway
header
counterexample
optimizes
assumes
infinitely
informally
nonzero
thousands
bank
drawbacks
boat
correspondence
differs
feasibility
workers
awarded
hits
translate
progresses
outflow
degradation
reinitialize
terminates
families
girls
unmatched
alternately
augmentations
contrary
hospitals
learned
circumference
detecting
pint
jobs
doubling
linearithmic
gave
happy
meant
agreed
unambiguous
favorite
lockers
procedural
destined
capability
fish
strive
dialects
inconvenient
compromise
perfection
peril
creative
summarized
attracted
mousetrap
strike
illustrations
rephrase
undoubtedly
customers
distinction
intersection
vectors
fruitful
bills
betterforwardelimination
pivotrow
determinants
heapify
fft
quotient
managers
pwc
jealous
husbands
husband
technology
discriminant
challenges
models
transpose
winner
approximating
difficulties
knowing
outputs
shrink
challenging
shell
reversing
reversed
instructor
unprocessed
unsatisfactory
counted
arguably
clocking
copc
caution
cancelled
fourfold
missed
invention
offered
grains
cmm
cmn
caveats
repetitions
measurements
novices
tells
succinctness
riddle
graphcomplete
frying
stairs
stair
tstart
tfinish
register
ticks
misleading
evidence
titled
eventually
multiset
representations
operates
giving
overcome
destination
technical
obstacles
discoveries
reasonable
imposed
derived
dominoes
uniquely
dramatic
dinner
manhattan
appearance
scheduling
david
recognized
universally
ancient
arithmetical
perspective
closely
proofs
schedule
inventing
absence
flashlight
events
industry
anagrams
subconsciously
cashiers
locale
nickel
penny
dimes
opening
paragraph
panding
globally
refrain
philosophical
hero
appealing
jumps
perpendicular
advances
matroid
archeology
biology
sociology
vojte
jarni
journal
inductive
coincides
traversed
negating
pursued
waiting
compatible
duration
averaging
vessel
spreading
sender
addressee
cups
disconnectedness
progression
unites
unionfind
mapped
updates
merits
demerits
conduct
densities
steiner
packet
routing
multitudes
speech
document
formatting
tainment
pathfinding
impaired
popularity
edsger
mechanics
penultimate
deletemin
dags
ascii
samuel
morse
dashes
infrequent
associate
dad
decoded
toy
achieves
compressed
versatility
lempel
ziv
robust
compressions
abacabad
decode
transmission
deuces
threes
nines
draws
shuffled
forces
implications
minor
impact
exhibit
pay
secret
tsort
stress
jordan
stages
violated
initializes
fractional
notable
adjust
fair
stick
days
carefully
names
social
ancestors
descendants
illustrating
intervals
emphasis
vary
bars
amortized
measurement
clarity
stirling
amortize
consecutively
certainty
predict
poor
sword
crowbar
edward
lytton
leila
byrne
billiards
overlooked
unjustifiable
yardstick
afresh
unburdened
selectionsort
bubbling
sworst
crude
heard
topology
printers
supposed
tilings
counterfeit
interchange
porblem
incorporated
bruteforcestringmatch
headquarters
gadgets
repaired
gandhi
constitutes
substrings
cabaaxbya
diversion
zigzagging
boards
occupies
destroyer
submarine
cruiser
carrier
shooting
shot
displayed
proximity
airplanes
offices
samples
traffic
controller
postal
hierarchical
bruteforceclosestpair
starters
speeding
prominence
mars
rovers
accessibility
satellite
geographic
outliers
diameter
enthusiasm
barricading
sleeping
lively
fenceposts
erected
tamer
plywood
snap
snapped
addressed
frontal
dismayed
bruteforceclosestpoints
seminal
correcting
positioned
cream
hurls
layman
rowan
brighten
shoes
thief
steal
loot
remote
socalled
nphard
opting
unavoidable
tuples
assignments
egerva
hour
hours
puzzlist
henry
solver
cryptarithms
backing
dashed
classified
prestigious
brave
cautious
concentric
dotted
summarizes
supporting
sime
denis
poisson
jug
emptying
subpar
includes
irrational
life
famous
modified
augmented
family
yielding
paired
presence
fourth
senseless
views
inescapable
instruments
sounding
necessitates
dustbin
celebrated
flying
discusses
intuition
directing
imposes
apples
oranges
fairer
intercity
plausible
deducing
uncertainty
realized
hostile
cheating
honest
malevolence
honesty
outputting
quotes
distinguished
configuration
tightness
extracted
inquire
lence
equivalence
informationtheoretic
redundant
acb
bca
terminal
reflecting
knockout
rounds
schemes
aro
invited
outset
indefinitely
garey
outstanding
lecture
historical
umbrella
striking
counterintuitive
gibberish
polynomialtime
cataloged
computable
bewildering
neverthe
leonid
conjunctive
negations
manindra
agrawal
neeraj
kayal
nitin
saxena
indian
kanpur
announced
factoring
transitivity
interviews
uncertain
dilemma
contended
gaining
fortune
legal
positioning
clay
cmi
cambridge
massachusetts
divisors
verifies
uppercase
expects
camelot
quarrels
guests
quarreling
clarification
nomena
everyday
approximated
overwhelming
mantissa
slows
phenomena
occurred
magnification
lowaccuracy
propagation
standpoints
propagate
highly
undesirable
instability
taught
difficultto
tolerance
menace
analyst
preface
denominator
calculating
kahan
overview
piqued
exclusively
esin
xdx
subintervals
guessed
inaccuracies
roundoff
dealt
plutarch
sertorius
horses
burly
hercules
tugged
weasel
plucked
hair
roars
laughter
cobham
brewer
fable
incremental
insertionsort
germane
albeit
rigorous
coupled
petitors
ferrying
detachment
rowboat
soldier
soda
insertsort
interleaving
sublists
stepping
differences
aforementioned
acronym
meaningless
drawn
visually
outgoing
cpm
methodologies
linkers
mutually
restarting
permuted
associating
horribly
fault
examined
frank
laboratories
reinvented
transmitting
baudot
telegraphy
reflexive
flexive
controlled
pushes
binarysearch
faces
tweaked
cayvegs
canvog
analogue
bisection
forgets
demand
nonorthodox
russe
parentheses
memorize
peasants
accord
visitors
nineteenth
flavius
historian
participated
chronicled
revolt
managed
fortress
jotapata
refuge
diehards
nearby
rebels
perish
dispatch
casting
contrived
surviving
prevailed
victim
grim
sole
gkp
interestingly
inches
notorious
prone
handles
overkill
rearrangement
shrinking
produces
poorly
brown
passing
practically
assessing
worthiness
wrote
edition
variablesize
randomness
hidden
gameplay
impartial
prototypical
deviation
recreational
authored
gaspar
aristocrat
hint
discarding
harvard
bouton
berlekamp
conway
guy
moldy
stacked
flip
biggest
miscellany
laa
sedgewick
business
exposition
intended
scientific
options
authors
ularly
comparisoncountingsort
distinguishes
tools
constitute
unsorted
reductions
elegant
perfectly
experiments
expansions
disposal
verifications
compilers
robotics
passenger
station
washington
london
preliminary
balls
subsection
providing
subjected
intermixed
decreases
possession
bachet
introduces
rediscovered
parenthesized
generalization
falls
skipping
classification
airline
crew
dots
consciously
movie
prescription
nonadjacent
electrical
connections
contradiction
dura
revisited
pints
message
sponding
creation
animations
recognition
pioneer
commences
unspecified
spelled
adjustments
telegraph
effectiveness
fly
combinations
steady
accretion
alexander
graham
hilly
foggy
hill
iterativeimprovement
colleges
moret
shapiro
heuristic
kantorovich
koopmans
apparently
royal
swedish
honor
father
instructive
quadrant
honors
president
citation
logistics
restated
south
qualifications
infeasible
attain
inspects
amn
minimized
unconstrained
nondegenerate
terminology
projection
adjusting
preserving
disregarded
notes
remarks
opens
bland
subscripted
phase
nutshell
intensive
worked
polished
evolved
packages
friendly
desktop
facility
khachian
kha
interior
pipeline
redirected
equivalently
separated
flowaugmenting
simpleminded
irrespective
replicate
chv
cleverly
demonstrating
shortestaugmentingpath
backwards
erase
relates
induced
accomplishes
utilized
preflows
reestablished
dinitz
karzanov
malhotra
kamar
maheshwari
goldberg
dining
interaction
meets
contingent
maximumcardinality
compensated
nonexistence
berge
zigs
zags
motivates
maximumbipartitematching
status
asserts
committees
skipped
response
rejects
underlined
refused
neutral
favors
bias
roles
participant
admissions
medical
residency
training
gusfield
irwing
gus
admission
residents
applicant
pairings
maximumflow
shortestaugmenting
nelement
mathematicians
rounded
ascertaining
intrinsic
appears
drastically
easiest
early
features
avoided
harel
sophistication
floor
programmed
aircraft
lesson
driven
tsp
acceptable
renowned
irish
nonnumerical
positively
fifo
backtracking
listing
glass
resolving
similarity
corresponds
target
built
boundaries
detection
incorporates
degenerates
intelligence
underlies
accrue
spots
kol
colorable
physicist
canonical
hierarchy
maps
intriguing
calculators
fight
verified
introducing
qualitatively
sequentialsearch
reveals
succeeds
embark
sleep
probable
statistical
predecessors
tackle
forget
circumvent
database
manager
realize
evil
marks
efficiently
proportional
gleaming
jeweler
velvet
berlinski
delightful
pointedly
spirit
fairness
compelling
bluntly
skills
inherently
living
preparation
aid
subjects
chemistry
linguistics
music
understood
formalize
comprehend
erybody
enduring
deliberate
tailored
wording
agreement
ubiquitous
nonambiguity
dramatically
alexandria
impressed
nostalgia
middleschool
qualify
unambiguously
teacher
nitpicking
ambiguity
rectify
greece
continuation
helping
daily
routines
ubiquity
fascinating
engines
khorezmi
khwarizmi
official
patent
patentable
country
driving
cooking
unequal
diophantine
hallway
fundamentals
reiterating
constructive
disciplines
readily
exciting
skimp
resembling
collaboration
burks
goldstine
essence
captured
concurrently
foreseeable
qualified
specification
imperative
extracting
unacceptably
contents
distill
utmost
guidance
caught
studies
categorize
intimately
proclaimed
wir
crucially
ambi
guity
skill
mixture
usage
dialect
declarations
indentation
dominant
flowchart
fed
converted
conclusively
beauty
beholder
undeniable
aes
judicious
unnatural
redesign
pilot
transition
incorrectly
inefficiently
debugging
safety
tricks
invariant
subexpressions
tuning
speedup
essay
essays
justifiably
pearls
wholeheartedly
writings
conclusion
emphasize
enjoyable
naming
joy
impatience
compromises
competing
ambiguously
unsolvable
misconception
mechanical
dull
truth
rewarding
riverbank
vegetarian
protected
species
rickety
party
crosses
walked
thrown
interviewers
seattle
interviewees
dispensing
mindistance
lya
reinforce
schools
holdings
companies
employees
grade
likened
admirable
embarrassment
riches
adapted
permits
plenty
spectacularly
conducive
databases
decades
intensified
oldest
economists
vlsi
fabrication
crystallography
genetic
scheduled
graphcoloring
unimaginable
disproved
greeks
triangles
unmarked
ruler
compass
intense
disappeared
resurrected
rulers
compasses
bytes
graphics
tomography
explanatory
focus
users
revolutionary
dominating
literate
rudimentary
swiss
islands
carved
vague
regions
months
accessed
textual
appending
reconnecting
flexibility
visualized
lifo
teller
dynamically
totally
universe
arcs
enters
disallows
compiled
adopted
expandable
interstate
highway
ticular
hierarchies
directories
organizational
charts
enterprises
excludes
inconvenience
effectively
membership
circumvented
intimate
reread
older
pascal
isolated
bracket
backlog
permuting
nonambiguous
adts
helpful
individual
discrete
schulz
cartoonist
creator
peanuts
amenable
conquering
elegance
concludes
radical
extensively
presortelementuniqueness
tscan
radix
accommodate
presortmode
tsearch
cumbersome
giants
chinese
europeans
augments
distorted
appends
unquestionably
reviewed
preventing
commercial
proposition
tackles
inverses
reciprocals
overcoming
analogy
xnn
axj
basically
unchanged
noncorner
border
expended
degeneracy
tolerates
restructured
restore
admissible
adelson
velsky
landis
rotate
grandchild
relationships
abbreviation
reorganized
weird
balances
prevented
promoted
disordered
operating
management
nonincreasing
correspondingly
heapifies
headed
heapification
heapbottomup
sift
readers
sifted
swapped
heapified
sifting
williams
intentionally
handful
uncooked
rods
unorthodox
folklore
fourier
treatments
unpleasant
tworow
evaluates
realization
fades
processes
bixi
leftrightbinaryexponentiation
leftto
rightleftbinaryexponentiation
reliance
bruteforcepolynomialevaluation
tient
stove
seller
bookstore
sitting
kitchen
proceeded
approached
rene
descartes
divisible
factorizations
derivative
instructors
unintentionally
minds
risky
moneys
dollars
exploration
refining
industrial
production
competitively
pgc
occupants
initialstate
appreciation
grand
married
couples
matters
rectangular
pips
embossed
arranging
doubts
inherent
arrived
academic
meaningful
vein
proverbial
proliferation
retrieval
describing
potentially
expressions
sharp
valued
conversely
ascending
tipping
staying
hardware
shrunk
purely
justified
normal
quoted
annual
worstcase
soviet
sensitivity
undefined
claims
lord
kelvin
rounding
triple
apparent
category
ignores
cast
incomparably
squared
discipline
toronto
prediction
concentrates
calculations
origins
bog
nonlinear
bugs
debug
convince
motivating
perseverance
interrelated
tailor
phrase
occasionally
outer
moderately
sortable
restricted
exhibits
topologically
completion
inclusive
mile
calling
lighted
toggled
specifics
western
lots
properly
expanded
swapping
severely
permitted
circled
appeared
claude
dud
eats
slower
continues
powerful
designated
referred
meagre
scarcely
thoughts
albert
einstein
heritage
separation
intellectual
constituent
narrower
quantitative
considerations
borrowed
simplifying
foolproof
relentless
technological
innovations
cache
diminished
inconsequential
contender
influenced
millisecond
extraneous
contributing
kernighan
pike
reliability
neatly
profound
significance
growing
slowest
instantaneously
astronomically
estimated
planet
earth
tremendous
react
eightfold
refuses
cooperate
neat
bounding
reasonableness
derivations
unequivocally
overly
pessimistic
readable
nontechnical
recapitulation
glove
drawer
yellow
green
disappearance
buying
legend
northwestern
wheat
comfortable
limn
preclude
anomalies
broader
aknk
facing
stretches
enables
maxelement
cai
uniqueelements
prematurely
predictable
matrixmultiplication
multiplies
designation
governed
machinations
caa
irregular
insur
mountable
halved
pertinent
bunched
mystery
enigma
grew
parlance
cellular
automata
tutorial
succeeded
emerging
disappointed
exerting
accumulates
realistically
generalizing
workhorse
mythical
slide
pegs
forbidden
agrees
stumble
smoothness
broad
refined
douard
lucas
mystical
brahma
prohibition
grill
executes
leonardo
population
predicting
prices
commodities
discernible
describes
generic
antiquity
pleasing
architects
sculptors
rapidly
warranted
embarking
rewriting
ahead
anticipated
manipulates
dedicated
newborn
fertile
climbing
climb
staircase
climbed
primitive
allocated
dissecting
dissect
analyzed
mathematically
imentation
mindful
accounted
ensure
fragment
currenttimemillis
remedy
sharing
cpu
defeats
environment
bottleneck
deliberation
profiling
environments
benchmark
decisions
trivially
adhere
nonrandom
atypical
cisions
shortage
averages
medians
generator
devil
recommendations
numerically
graphically
tabulated
careless
reacts
concave
aggregate
scatterplots
differentiate
axis
plotted
resemble
predictions
extrapolation
unleashing
experimental
independence
plots
sortanalysis
milliseconds
watershed
happened
ronald
baecker
assistance
sherman
bae
convincing
demonstration
perennial
lends
sticks
rearranged
animated
supported
algovizproject
heavily
topics
expectations
uncover
contact
mcilroy
decisively
involvement
passive
exposure
successes
perception
fulfilled
contributes
grounded
notions
rational
manipulate
statements
completed
popular
placement
extensive
parents
millions
intuitively
connection
sites
nonnumeric
requirements
knowledge
vehicle
traditional
future
slashes
reaching
specialized
criterion
motivated
extensions
compensate
competitive
shortcoming
corollary
devised
achievements
narendra
tests
walking
consequential
spectrum
slash
refers
complement
survey
tiling
greek
roman
educational
deserves
speeds
dozens
conjecture
neighboring
dictated
precedes
brevity
alternate
marking
hopcroft
clever
encryption
inspection
tarjan
intellect
mission
village
manhat
backs
devoted
monograph
deeper
peared
shared
exercised
promotion
dish
briefly
newer
unimaginably
satisfactory
proverb
classifying
pinpoint
incorrect
eye
ultimately
cheap
advantages
disadvantages
boss
goals
exert
company
limitless
specially
handling
monographs
deb
accumulation
distort
leonhard
forbid
accommo
rotating
universal
answering
anagram
lives
scope
rapid
magnitudes
manipulating
born
transforms
verifying
traced
evaluated
primality
university
concerns
showed
occasion
qualitative
aim
achievement
averagecase
carl
friedrich
glaring
moot
modulo
principally
utilize
splay
golden
impressive
buy
traf
occupy
centuries
imaginable
convert
wanted
historic
underlie
extent
preserves
contradictory
mimics
multitude
maintaining
deep
india
olden
reiterate
adjustment
convenience
partic
usefulness
detailed
candidate
maintained
costs
performs
begins
adds
impose
spectacular
discard
reward
centrates
utively
pital
disprove
ranging
vorite
catalog
content
easily
title
kle
routine
ranges
capable
repeatedly
william
places
road
incorporate
toggle
omit
tune
gri
aha
nonnumer
noticed
calculator
writing
incidentally
substituting
intersect
calculation
quo
boring
quote
washing
mixed
effective
characteristics
modeling
impression
puzzles
moderate
north
sev
primarily
sized
compiler
wil
drastic
kel
effect
ultimate
efforts
sage
dictate
impres
cra
quirements
voted
input enhancement
huffman code
disk accesses
current matching
upper hull
problem reduction
external nodes
digit multiplications
linear probing
backward edges
nondeterministic algorithm
current tree
subset representative
pattern length
vertices tree
convex hulls
convex set
selection sort
network figure
ranking matrix
combining solutions
composite trapezoidal
distribution values
trading space
huffman codes
alphabet symbols
huffman algorithm
huffman encoding
hamming distance
depth traversal
dfs bfs
basic solution
simplex tableau
edge capacities
capacity constraints
key node
minimal algorithm
pile nim
conquer approach
theoretical minimum
exchanging pivot
pivot selection
coordinates points
voronoi diagram
complexity theory
additions subtractions
shifts pattern
suffix size
called hash
hashing called
study algorithms
sieve eratosthenes
pair vertices
choice feasible
huffman trees
greedy manner
acyclic subgraph
vertex selected
vertex smallest
bridge crossing
representative updated
fringe vertex
codeword symbol
bits symbol
symbol frequency
length codeword
problem reduced
equality constraints
entering variable
bipartite graphs
cost matrix
euclidean distance
brute strategy
coins stacks
distinct points
figure convex
rubber band
breadth traversal
breadth forest
vertex labels
heaps heapsort
array representation
synthetic division
lcm gcd
real world
merging algorithm
symmetric matrices
intractable problems
verification stage
nondeterministic polynomial
higher precision
floating arithmetic
smaller problem
decrease half
design decrease
power set
digraph directed
permutations lexicographic
light bulb
array half
partitioning element
algorithm quickselect
instance game
chips pile
pile chips
chips losing
spoiled square
construction algorithm
arrays sorted
equal pivot
merging sorted
assume points
set functions
efficiency hashing
identical searching
keys node
length pattern
greedy approach
greedy technique
edges labeled
path edges
matched pairs
initial tableau
rightmost column
sink source
flows network
backward edge
edges unlabeled
capacity cut
capacities edges
maximum network
vertex sets
edge matching
matching set
ann jim
preference lists
bob lea
lea tom
proposes woman
proposed lea
men matched
recurrence running
size combining
recurrence additions
array copied
recurrence cworst
growth solutions
version mergesort
board missing
problem quicksort
input elements
array quicksort
algorithm quicksort
quicksort input
sophisticated method
selecting pivot
subarray elements
subarray partitioned
subarray bounds
comparisons partition
cbest log
increasing arrays
subarrays elements
leftmost rightmost
small subarrays
science engineering
quicksort sort
nuts bolts
section conquer
applied binary
tree special
applying conquer
algorithm height
tree algorithms
replacing subtrees
node extended
nodes internal
classic traversals
subtrees considered
nodes root
multiplying integers
modern cryptography
numbers digits
computing products
alogb clogb
digit additions
multipli cations
smaller crossover
principal insight
additions numbers
matrices power
method strassen
brute method
ordered nondecreasing
rectangle points
closer pair
num dminsq
upper boundary
lower boundary
boundary called
points pmaxpn
traversal stack
total weight
electronic computers
section technique
situation arises
sparse matrices
zeros objects
makes key
overwrite elements
counter initialized
mismatch occurs
comparisons pattern
pratt algorithm
aligning pattern
successfully matching
large shift
size shift
shift character
text aligned
case character
counterpart pattern
pattern letter
letter shift
finally character
shifts position
algorithm characters
encountered text
length characters
rightmost characters
pattern left
table horspool
input pattern
pattern alphabet
alphabet characters
characters matched
table text
table shifts
matched characters
matched successfully
shift reasoning
shift computed
pattern dbcbab
abcbab pattern
pattern construct
successfully matches
simplified versions
gene segment
random binary
records student
records keys
keys hashing
distributing keys
keys dimensional
larger problem
case keys
hashing scheme
hashing chaining
key word
word hash
key kid
size hash
cell unsuccessful
matching key
version hashing
probing sequence
birthday paradox
case entry
index information
tree introduced
data records
children keys
room leaf
split nodes
considered tree
initially tree
singly linked
applications indispensable
precisely defined
description algorithm
important set
multiples eliminated
eliminated previous
algorithms today
algorithms data
algorithm simpler
set inputs
remaining cents
problems greedy
graph section
application huffman
greedy algorithms
corner board
chips board
board chips
chips adjacent
partition board
subgraph tree
graph weights
graph efficient
tree sequence
algorithm expands
tree greedy
vertex minimum
edge edges
labels vertex
fringe unseen
unseen vertices
finding vertex
edge current
update labels
addition edge
delete minimum
priority min
element min
min size
problem greedy
spent job
applying prim
graph obtained
discovered algorithm
inclusion create
figure edge
forest consists
single tree
subsets union
union algorithms
makeset creates
performing union
representative array
representation subsets
path compression
operation tree
weights design
vertices important
finds shortest
subtree vertices
vertex priority
vertex source
encode text
text symbols
shorter bit
symbols longer
encoded text
ith symbol
prefix free
frequency symbols
occurrence frequencies
frequencies text
codeword lengths
encoding alphabet
compression ratio
construct huffman
questions answerable
chosen probability
code data
data symbol
variance codeword
english text
experiment encoding
english texts
tree leaves
operations performed
ordered tree
log algorithm
determinant matrix
generating subsets
spent sorting
distinct values
modef requency
forward elimination
matrix nonsingular
ele ments
figure construction
height nodes
priority queues
files integers
applying horner
domino set
numerical algorithms
problem difficult
polynomial algorithms
partition problem
pair points
index figure
edges digraph
key array
case recurrence
sample inputs
multiplicative constants
balanced trees
exhaustive brute
encountered brute
brute proach
elements exchange
passes sorted
times executed
key swaps
version sort
weighs grams
key encountered
enhanced version
version sequential
write solving
ships opponent
points standard
problem leads
dimensional space
largest distance
points boundary
sets convex
points solve
vertices polygon
problem completely
exercises assuming
axioms distance
nearest neighbor
suggests generating
problem domain
vertex permutations
computing total
exhaustive leads
selected elements
permutations integers
exhaustive applied
algorithms exhaustive
letter represents
adjacent unvisited
dead vertex
vertex stack
stack dead
forest shown
depth algorithm
marked dfs
representation graph
forest edges
applications dfs
vertices visited
added removed
bfs forest
fewest edges
algorithm efficiencies
factorial function
inputs case
functions growth
figure big
loop body
explicit formula
exponential algorithm
compute ratios
sample instances
pseudorandom numbers
scatterplot points
efficiency operation
edges vertices
preceding chapters
modern computers
obtaining lower
difficult task
intractability problems
bound lower
conclude algorithm
finding median
log questions
leaves largest
algorithm merging
reduction approach
reduction problem
multiplication matrices
problem multiplying
complexity classes
problem complexity
multiplication squaring
case decision
largest leaves
outcomes sorting
arbitrary element
array comparisons
ternary tree
leaves log
genuine fake
jigsaw puzzle
problems scientists
computing professionals
problems solvable
solvable polynomial
series decision
alan turing
completes proof
problems fall
problem cycles
vertices hamiltonian
takes input
string generated
true problem
decision versions
proper subset
notion completeness
polynomial reducibility
boolean expression
vertex size
king arthur
solving mathematical
fact numerical
replacing infinite
truncation errors
errors major
ill conditioned
equation real
secondary school
initial approximation
decreasing converges
prove iterations
george forsythe
half planes
instance reduced
equal figure
obvious formula
examples decrease
compute instance
odd compute
technique sorting
subarray left
sorted figure
good performance
fast average
marked neighbors
marked cells
increasing decreasing
directed digraph
digraph representing
subscript numbers
directed cycles
edge encountered
dfs stack
fig ure
based direct
ordering generated
set decrease
elements permutation
permu tations
minimal requirement
figure generating
permutations generated
permutations elements
arrow points
permutation mobile
initialize permutation
largest index
adding elements
binary numbers
algorithm lexicographic
figure easy
single bit
recursively algorithm
make bit
generate binary
binary searching
iteration binary
initial size
discuss continuous
odd values
person position
position numbering
discern pattern
minimum cuts
picture questions
partition array
lomuto partitioning
elements indexed
interpolation binary
interpolation searching
searching named
index computed
random keys
game nim
single pile
players turns
taking chip
player moving
winning strategy
winning losing
instance losing
player make
pile sizes
sum nim
winning player
algorithm practical
area triangle
element smaller
make set
partition achieved
partitioning procedure
inputs problem
elements arrays
key moves
comparisons case
computes recursively
height algorithm
log nlog
figure idea
pairs points
points min
algorithm identifies
depth forest
algorithm determines
fast memory
stored disk
positions sorted
letters alphabet
hashing section
array integers
parental nodes
trees section
smaller keys
key tree
middle key
node splits
nodes keys
searching tree
principal varieties
table numbers
array positions
shifting pattern
counterpart text
dna sequence
trees principal
main memory
idea tree
tree similar
multiplications additions
key values
expressing algorithm
programming language
majority algorithms
sequence steps
depth vertex
people bridge
problem arises
element priority
tree connected
elements subset
technique suggests
symbol alphabet
implementing priority
graduate student
greedy strategy
sum weights
weights edges
efficiency single
problem model
strings symbols
element node
quadratic worst
partial pivoting
solve systems
identity matrix
insert key
size instance
finding initial
maximizing network
special structure
bipartite matching
pairing elements
school graduates
nobel prize
applications economics
feasible points
obtained solving
line common
national medal
shifting line
maximizing subject
large problems
problems variables
variables feasible
identifying extreme
current optimal
equivalent problem
replaced equivalent
slack variable
nonnegative variables
solving called
nonbasic variables
column entry
columns labeled
column columns
current tableau
negative entries
negative column
solution coefficient
variable called
variable nonbasic
tableau rows
tableau nonnegative
variables values
smallest subscript
obvious basic
artificial variables
constraints variables
ellipsoid method
subject aij
assumed numbered
vertex leaving
simply network
xji xij
capacities uij
total inflow
edge maximum
general template
template solving
amounts edge
edges current
capacity edges
edges flows
forward backward
sum capacities
xij vertex
min rij
xji vertex
min xji
augmentation performed
source current
current maximum
labels source
network flows
property edges
network directed
path belongs
vertex labeling
bold augmentation
cuts network
capacity network
network cut
cut equal
edges required
uij element
network maximum
table seating
subset edges
figure bipartite
odd length
matching edges
vertex matched
adding matching
larger matching
numbered positions
path exists
case vertex
column shows
marriage partners
ties allowed
woman preference
jim ann
sue ann
tom figure
women rankings
rankings men
accepts proposal
total women
woman algorithm
proposed sue
gale shapley
matchings stable
proposing version
generating sequence
improving values
properties graphs
sort selection
traversal vertices
stack vertex
solving puzzle
brute algorithms
points figure
class design
traverse graph
job assigned
person cost
ith person
total cost
characters left
graph acyclic
solve instances
acyclicity graph
visiting vertices
elements key
probability successful
mod large
sort line
algorithm operations
multiplicative constant
specific values
single operation
input matrices
logarithm base
determine efficiency
reasons study
practical standpoint
standard set
cornerstone science
algorithms applications
professional personal
studying algorithms
algorithms special
answers specific
algorithms leads
issues related
designing analyzing
language algorithm
required output
diagram figure
represented ways
larger numbers
observation integer
smaller iteration
problems algorithms
smaller numbers
input numbers
common factors
legitimate algorithm
factorization steps
prime numbers
primes exceeding
eliminates multiples
numbers eliminated
eliminated remaining
implemented programs
algorithm description
lists numbers
numbers board
problem practical
understand problem
exact approximate
central assumption
ram model
parallel algorithms
techniques design
solved instances
learning techniques
classify algorithms
linked array
succinct description
geometric shapes
algorithm correctness
mathematical rigor
jon bentley
algorithm sorts
algorithm talking
computing solved
world puzzle
english pseudocode
attention researchers
piece information
sort student
students gpa
situations algorithms
sorted alphabetically
strings comprise
languages compiling
section graphs
theoretical practical
difficulty stems
critical role
icosian game
color map
arrays implementing
element located
string strings
pointers nodes
linked special
pointer element
linked elements
elements null
doubly linked
insertions deletions
linked element
queues important
stack plates
elements added
adjacent connected
undirected edge
edge incident
vertices undirected
graph sparse
model connected
subgraph graph
called child
siblings vertex
vertex children
rooted vertex
defined ordered
parental vertex
computing purposes
nodes pointers
left pointer
sets comprises
set represented
relationship data
efficient algorithmic
set abstract
priority dictionary
oriented languages
means classes
lists represented
enqueue dequeue
edges path
problem efficient
idea differ
representation instance
instance representation
idea presorting
implemented arrays
computing mode
largest frequency
input bits
values encountered
runlength modevalue
algorithms dealing
numbers boxes
coefficients equation
nxn annxn
isaac newton
equation substitute
elementary operations
replacing equation
difference equation
multiple equation
elementary operation
matrix pivot
equations specifically
scaling factor
errors section
elimination stage
inverse matrix
diagonal elements
computing determinant
det equal
simply equal
applications section
compute determinant
equal product
decomposition method
elimination method
panels toggling
affects total
height equal
good properties
difference heights
red black
requirement tree
called rotations
idea rebalancing
important trees
figure insertion
figure rotation
rotation called
trees nodes
rotation left
insertion log
key deletion
kinds nodes
key root
tree leaf
inequality log
write constructing
defined binary
shape property
positions array
parent key
checks parental
holds position
efficiency deletion
stage algorithm
stage construction
construction stage
investigate efficiency
spaghetti sort
heapsort horner
horner binary
years horner
horner method
polynomial formula
filled left
entry computed
algorithm horner
polynomial horner
multiplications horner
horner byproducts
division algorithm
computing power
binary polynomial
lowest term
apply horner
division apply
kettle cupboard
professor kettle
alg problem
points words
numbers paths
function maximization
minimization problem
calculus procedure
critical points
investments stocks
required integers
continuous version
goal state
river crossings
construct min
graph triangle
vertex coloring
representation problem
section methods
problem determining
real roots
important unresolved
arithmetic operations
scale sets
problem partition
fastest algorithm
problem log
arise naturally
evaluation algorithm
algorithm turns
leaves represent
specific examples
distinct problem
comparing elements
complexity class
sort element
represents solution
clique size
major obstacle
numbers digital
array numbers
root left
figure standard
algorithms binary
multiplications algorithm
single node
requires multiplications
algorithm outlined
adjacency representation
analyze efficiency
set algorithm
loses game
implementa tion
size obtained
decreasing values
arrays key
array version
undirected graphs
edge digraph
solution efficient
left problem
generate permutations
single element
binary log
position figure
array assume
algorithm examples
approximation algorithm
remainder division
alphabet character
data compression
elements positions
implementing dictionaries
positions elements
express numbers
setting sum
called recurrence
outline general
established tradition
elements matrices
size metric
size algorithms
input algorithms
units measuring
measuring running
approach dependence
efficiency metric
operations executed
algorithms basic
established framework
framework analysis
operations basic
input sizes
small inputs
function growth
quadratic function
algorithms running
kind inputs
efficiency case
efficiency determine
analysis case
behavior typical
size sequential
general formula
algorithm inspect
elements inputs
probabilistic assumptions
run algorithm
entire sequence
distinguish worst
distinct pairs
prove formula
addition sorting
function argument
inventor asked
square chessboard
operation principal
indicator algorithm
natural numbers
informal introduction
lower growth
executed parts
smaller growth
based definitions
log lim
algorithm worse
running typically
prove fact
classes algorithms
door wall
analysis nonrecursive
algorithm loop
executed repetition
analyzing nonrecursive
loop times
executed counting
algorithm machine
alternative computing
definition compute
total calls
equation defines
defined recurrence
recurrence solve
solve difficult
investigating recursive
recursive solution
largest disk
disk directly
disk algorithm
mask inefficiency
inefficiency recursive
algorithm binrec
advantage theorem
formula valid
sum cubes
disks moved
hamburgers fried
algorithm hamburgers
sequence benefits
fibonacci rabbits
rectangle sides
nearest integer
pair rabbits
male female
input sample
data observed
hypothesis algorithm
sample developed
instance sizes
sizes typically
range chosen
generated randomly
observed metric
experiment sample
sequence pseudorandom
quadratic cubic
convex shape
applicability algorithm
logarithmic linear
counter inserted
scatterplot algorithm
algorithm scatterplot
davg algorithm
representing item
existing visualizations
research education
subtree smaller
positive numbers
solve problems
root element
figure addition
changing element
adding edge
called quick
symbols symbol
smaller equal
cworst log
comparisons needed
polynomial anxn
directed graphs
figure illustration
outline algorithm
incident edge
edges connecting
elements sets
fortunately important
vertices deleted
matrix notations
largest absolute
solution exists
problems optimal
nonnegativity constraints
george dantzig
karmarkar algorithm
total iterations
contradicts assumption
disjoint sets
inequalities problem
called basic
problem unique
smallest convex
adjacent vertex
edge figure
connectivity acyclicity
vertex ancestor
game played
smallest elements
prob lems
triangle vertices
design strategy
problem obvious
problems examples
examples problems
assertions true
additions algorithm
mathematical analysis
algorithm log
problem prove
solution prayers
prayers goddess
goddess algorithmics
algorithmics chapter
epigraph answered
answered spent
spent executing
executing conquer
conquer turns
turns significantly
significantly smaller
smaller solving
problem method
method fact
fact conquer
yields important
algorithms science
classic examples
chapter sequential
algorithms keeping
mind conquer
technique ideally
ideally suited
suited parallel
parallel computations
computations subproblem
subproblem solved
solved simultaneously
simultaneously processor
processor conquer
called pairwise
pairwise summation
summation substantially
substantially accumulated
accumulated error
error sum
approximately digital
digital hig
hig mentioned
mentioned typical
size generally
generally instance
size needing
needing solved
solved constants
constants assuming
assuming size
size power
power simplify
simplify analysis
analysis recurrence
running function
function accounts
accounts spent
spent dividing
solutions sum
recurrence called
general conquer
conquer recurrence
recurrence growth
solution depends
depends values
analysis conquer
algorithms greatly
greatly simplified
simplified theorem
theorem appendix
appendix master
recurrence log
log nlogb
nlogb analogous
analogous results
results hold
hold notations
notations recurrence
additions conquer
conquer sum
sum computation
size nlogb
nlogb nlog
nlog solution
solution efficiency
class drudgery
drudgery solving
recurrence approach
approach establish
growth unknown
unknown multiplicative
constant solving
equation specific
specific initial
condition yields
exact powers
powers pointing
pointing recurrence
recurrence covers
covers decreaseby
decreaseby constant
previous chapter
chapter fact
fact people
binary degenerate
cases andconquer
andconquer subproblems
subproblems half
size solved
solved decrease
factor divideand
divideand conquer
design paradigms
paradigms mergesort
mergesort perfect
perfect successful
successful application
technique sorts
array dividing
dividing halves
merging smaller
smaller sorted
arrays single
mergesort sorts
recursive mergesort
mergesort input
nondecreasing mergesort
merge merging
arrays pointers
pointers array
array indices
indices initialized
arrays merged
merged elements
elements pointed
pointed compared
compared smaller
smaller added
added array
array constructed
constructed index
index smaller
element incremented
incremented successor
successor array
copied operation
repeated arrays
arrays exhausted
exhausted remaining
copied array
merge merges
merges sorted
sorted output
output sorted
figure mergesort
mergesort operation
operation efficient
efficient mergesort
mergesort assuming
assuming simplicity
simplicity power
comparisons cmerge
cmerge analyze
analyze cmerge
cmerge key
comparisons performed
performed merging
merging stage
stage comparison
comparison total
arrays needing
needing processed
processed reduced
reduced worst
case arrays
elements alternating
alternating arrays
case cmerge
cmerge recurrence
cworst master
theorem cworst
fact easy
easy exact
solution worst
case theoretical
minimum general
large comparisons
case turns
turns gon
gon log
log noteworthy
noteworthy advantage
advantage mergesort
quick sort
heapsort important
important advanced
discussed stability
exercises principal
principal short
short coming
coming mergesort
mergesort linear
storage algorithm
requires merging
merging resulting
algorithm complicated
complicated theoretical
theoretical main
main ideas
ideas leading
leading variations
variations mergesort
mergesort algorithm
algorithm implemented
implemented merging
merging pairs
elements merging
sorted pairs
pairs power
power slight
slight bookkeeping
bookkeeping complications
complications arise
arise avoids
avoids space
space overhead
overhead stack
stack recursive
calls sorted
sorted parts
parts sort
sort recursively
recursively merge
merge scheme
scheme sorting
sorting files
files residing
residing secondary
memory devices
devices called
multiway mergesort
finding sition
sition largest
output arrays
finding values
exponenti ation
section theoretical
minimum log
chapter logarithm
logarithm bases
bases irrelevant
irrelevant contexts
contexts arising
arising analyzing
class true
asser tions
tions master
theorem logarithms
logarithms growth
solutions recurrences
recurrences apply
apply mergesort
mergesort sort
alphabetical mergesort
mergesort stable
assume set
mergesort case
inputs solve
moves version
taking key
moves account
account algorithm
numbers pair
pair inversion
inversion numbers
design log
counting inversions
inversions implement
implement version
mergesort language
choice tromino
tromino puzzle
puzzle tromino
tromino accurately
accurately tromino
tromino shaped
shaped tile
tile formed
formed squares
squares problem
problem chess
chess board
missing square
square trominoes
trominoes oriented
oriented arbitrary
arbitrary squares
missing overlaps
overlaps gol
gol design
quicksort important
approach mergesort
mergesort divides
divides input
quicksort divides
divides encountered
encountered idea
idea array
partition section
partition arrangement
arrangement array
equal partition
achieved final
sorting subarrays
subarrays left
left independently
independently method
method difference
difference mergesort
mergesort division
division problem
subproblems entire
entire combining
solutions entire
entire division
division stage
stage required
required combine
combine solutions
subproblems pseudocode
pseudocode quicksort
quicksort algorithm
quicksort sorts
sorts subarray
subarray quicksort
output subarray
subarray sorted
nondecreasing partition
position quicksort
quicksort partition
partition discussed
section alternatively
alternatively partition
partition generally
subarray sophisticated
method suggested
suggested hoare
hoare prominent
prominent british
british scientist
scientist invented
invented quicksort
quicksort hoare
hoare age
age invented
invented algorithm
sort words
words machine
machine translation
translation project
project russian
russian english
english hoare
hoare thought
thought bubblesort
bubblesort amazing
amazing luck
luck thought
thought quicksort
quicksort hard
hard assessment
assessment lucky
lucky wonderful
wonderful career
career computing
computing discovering
discovering sorting
algorithm hoa
hoa years
years received
received turing
award fundamental
contributions definition
definition design
design programming
programming languages
languages knighted
knighted services
services education
education science
science selecting
element respect
respect subarray
subarray strategies
strategies selecting
pivot issue
issue analyze
efficiency simplest
simplest strategy
strategy selecting
selecting subarray
subarray element
scan subarray
subarray ends
ends comparing
comparing subarray
left subarray
element subarray
pivot stopping
stopping scans
scans encountering
pivot yield
yield splits
splits arrays
arrays lot
lot duplicates
duplicates makes
faster array
elements split
split subarrays
subarrays sizes
sizes reducing
size scanning
array scans
scans situations
situations arise
arise depending
depending scanning
crossed scanning
crossed simply
simply exchange
exchange resume
resume scans
scans incrementing
incrementing decrementing
decrementing scanning
crossed partitioned
partitioned subarray
subarray exchanging
pivot finally
finally scanning
equal subarray
partitioned split
position combine
combine case
case crossed
crossed indices
indices exchanging
pivot pseudocode
algorithm hoarepartition
hoarepartition partitions
subarray hoare
position returned
returned function
function swap
swap undo
undo swap
swap index
index subarray
bounds pseudocode
pseudocode checking
checking possibility
possibility index
index incremented
incremented append
append array
array sentinel
sentinel index
index advancing
advancing position
position sophisticated
method pivot
selection mentioned
makes sentinel
sentinel unnecessary
unnecessary sorting
quicksort figure
figure discussion
efficiency noting
noting key
achieved scanning
indices coincide
coincide splits
splits middle
middle subarrays
subarrays case
case satisfies
recurrence cbest
cbest master
theorem cbest
log solving
yields cbest
case splits
splits skewed
skewed extreme
extreme subarrays
subarrays size
size subarray
partitioned unfortunate
unfortunate situation
situation increasing
arrays inputs
solved strictly
array pivot
scan left
scan indicating
indicating split
figure quicksort
quicksort operation
operation array
array transformations
transformations pivots
pivots shown
bold tree
calls quicksort
input values
values subarray
bounds split
position partition
partition obtained
obtained making
making comparisons
partition exchanging
pivot algorithm
left strictly
sorting strictly
arrays diminishing
sizes processed
processed total
equal cworst
cworst utility
utility quicksort
case behavior
behavior cavg
cavg average
comparisons quicksort
quicksort randomly
size partition
comparisons achieve
partition left
left subarrays
elements assuming
assuming partition
position probability
probability recurrence
relation cavg
cavg solution
solution trickier
trickier worst
case analyses
analyses turns
turns cavg
average quicksort
quicksort makes
case innermost
loop efficient
efficient runs
faster mergesort
heapsort log
chapter randomly
arrays nontrivial
sizes justifies
justifies algorithm
inventor quicksort
quicksort importance
importance persistent
years refine
refine basic
improvements discovered
discovered researchers
researchers pivot
selection methods
methods randomized
randomized quicksort
quicksort random
random element
element median
median method
method median
median leftmost
rightmost middle
array switching
switching insertion
sort small
elements systems
systems sorting
sorting small
subarrays finishing
finishing algorithm
sort applied
applied entire
entire sorted
array modifications
modifications partitioning
partitioning algorithm
partition segments
segments smaller
pivot problem
exercises robert
sed world
world leading
leading expert
expert quicksort
quicksort improvements
improvements combination
combination cut
cut running
quicksort weaknesses
weaknesses stable
stable requires
requires stack
stack parameters
parameters subarrays
subarrays sorted
size stack
stack log
sorting smaller
smaller subarrays
subarrays obtained
obtained partitioning
partitioning worse
worse space
heapsort sophisticated
sophisticated ways
ways choosing
make quadratic
quadratic running
case eliminate
eliminate completely
completely performance
performance randomly
arrays sensitive
sensitive implementation
details algorithm
algorithm architecture
architecture data
data february
february issue
computing science
engineering joint
joint publication
publication american
american institute
institute physics
physics ieee
ieee society
society selected
selected quicksort
quicksort algorithms
algorithms greatest
greatest development
development practice
practice science
engineering century
century exercises
apply quicksort
alphabetical draw
calls partitioning
procedure outlined
section prove
left pointed
pointed showing
showing quicksort
quicksort stable
algorithm array
elements sentinel
sentinel mentioned
mentioned text
text needed
needed single
single sentinel
sentinel suffices
suffices input
input version
version quicksort
quicksort section
section arrays
input quicksort
quicksort median
median pivot
selection strictly
increas ing
arrays estimate
faster quicksort
array random
numbers insertion
sort true
false element
element arrays
sorted faster
faster insertion
quicksort design
algorithm rearrange
rearrange elements
bers negative
negative elements
elements positive
positive elements
efficient dutch
rearrange array
characters red
red white
white blue
blue colors
colors dutch
flag dij
dij design
solution dutch
quicksort implement
implement quicksort
quicksort language
run sample
inputs verify
verify theoretical
theoretical assertions
assertions algorithm
efficiency nuts
bolts collection
collection bolts
bolts widths
widths nuts
nuts allowed
allowed nut
nut determine
determine nut
nut larger
larger smaller
smaller matches
matches nuts
bolts problem
problem nut
nut design
problem average
log raw
traversals related
related properties
properties section
technique applied
defined finite
set nodes
nodes consists
consists root
root disjoint
disjoint binary
root binary
case ordered
standard interpretation
interpretation alternative
alternative definition
definition binary
definition divides
divides binary
smaller structures
structures left
subtree problems
trees solved
solved applying
technique recursive
computing height
recall height
leaf computed
computed maximum
maximum heights
heights root
left tleft
tleft tright
tright figure
standard representation
tree subtrees
subtrees account
account extra
extra root
root convenient
height computes
recursively height
output height
max height
height tlef
tlef height
height tright
tright problem
size nodes
comparisons compute
relation tlef
tlef tright
tright solve
solution addition
addition frequently
checking typical
typical binary
executed additions
additions single
comparison addition
addition numbers
numbers helps
helps analysis
analysis tree
algorithms draw
tree extension
extension replacing
subtrees special
special nodes
nodes extra
extra nodes
squares figure
called external
external original
original nodes
circles called
called internal
internal definition
definition extension
extension binary
single external
node easy
easy height
addition internal
extended tree
tree makes
comparison figure
left extension
extension internal
circles external
squares tree
node ascertain
ascertain algorithm
efficiency external
nodes extended
nodes checking
checking figure
similar examples
examples easy
easy hypothesize
hypothesize external
nodes prove
total nodes
root children
children internal
node equation
equation immediately
implies equality
equality applies
applies nonempty
nonempty binary
tree definition
definition node
children binary
tree denote
denote numbers
numbers parental
leaves returning
returning algorithm
height comparisons
tree additions
additions important
important conquer
trees classic
traversals preorder
traversals nodes
recursively visiting
visiting tree
subtrees differ
differ timing
timing root
root preorder
preorder traversal
visited left
subtrees visited
visited inorder
inorder traversal
subtree visiting
visiting subtree
subtree postorder
subtrees traversals
traversals illustrated
figure pseudocodes
pseudocodes straightforward
straightforward repeating
repeating descriptions
descriptions traversals
traversals standard
standard feature
feature data
structures textbooks
textbooks efficiency
analysis identical
identical analysis
analysis height
tree finally
finally questions
questions binary
trees require
require traversals
traversals left
subtrees insert
insert operations
operations binary
processing subtrees
applications conquer
conquer examples
technique preorder
postorder figure
traversals exercises
exercises design
computing levels
levels binary
trees efficiency
algorithm seeks
seeks compute
compute leaves
algorithm leafcounter
leafcounter computes
recursively leaves
output leaves
leaves leafcounter
leafcounter tlef
tlef leafcounter
leafcounter tright
tright algorithm
correction compute
compute height
tree asymptotic
asymptotic ficiency
stack explicitly
implicitly algorithm
altogether prove
equality mathematical
induction traverse
traverse binary
postorder write
pseudocode classic
algorithms preorder
preorder postorder
postorder binary
trees assuming
recur sive
calls classic
algorithms yields
yields sorted
sorted applied
prove property
property draw
nodes labeled
labeled inorder
yield lists
lists inorder
postorder permutations
permutations labels
labels inorder
constructs binary
tree lists
lists labels
labels generated
generated inorder
solution internal
paths internal
root internal
node similarly
similarly external
external path
paths external
root external
node prove
prove internal
write computing
computing internal
tree investigate
investigate empirically
empirically average
generated binary
tree chocolate
chocolate puzzle
puzzle chocolate
chocolate break
break pieces
pieces break
break straight
line broken
broken design
minimum breaks
breaks minimum
minimum justify
justify properties
properties binary
tree multiplication
section surprising
algorithms seemingly
seemingly straightfor
straightfor ward
ward tasks
tasks multiplying
integers multiplying
multiplying square
matrices achieve
achieve asymptotic
efficiency ingenious
ingenious application
technique multiplication
integers applications
applications notably
notably modern
cryptography require
require manipulation
manipulation inte
inte gers
gers decimal
digits integers
integers single
single word
word modern
modern require
special treatment
treatment practi
cal supports
supports investigations
investigations algorithms
efficient manipulation
manipulation large
integers section
outline interesting
multiplying numbers
numbers conventional
conventional pen
mul tiplying
integers digits
digits multiplied
multiplied digits
digits total
total digit
multiplications numbers
digits pad
pad shorter
shorter leading
leading zeros
zeros equalize
equalize lengths
lengths impossible
algorithm digit
digit multiplica
multiplica tions
turns case
case miracle
miracle conquer
conquer accomplish
accomplish feat
feat demonstrate
demonstrate basic
basic idea
case digit
integers numbers
represented formula
yields digit
multiplications pen
algorithm fortunately
fortunately compute
compute middle
middle term
term digit
digit multiplication
multiplication taking
advantage products
products computed
computed special
special numbers
numbers multiplied
multiplied pair
pair digit
formula product
apply multiplying
numbers middle
middle promised
promised advantage
advantage conquer
technique denote
denote half
half digits
digits half
half notations
notations implies
implies taking
advantage digit
products power
power recursive
integers pure
pure recursion
recursion stopped
stopped deem
deem small
numbers size
size directly
directly digit
make multiplica
multiplica tion
numbers requires
multiplications digit
numbers recurrence
multiplications solving
solving backward
substitutions yields
yields log
nlog advantage
advantage property
property logarithms
logarithms alogb
clogb additions
subtractions decreased
decreased num
ber multiplications
multiplications requiring
requiring operations
operations digit
subtractions executed
integers operations
operations needed
compute products
products digit
numbers formulas
formulas require
require additions
subtraction recurrence
recurrence applying
theorem stated
stated beginning
chapter nlog
nlog means
means total
subtractions asymptotic
cations asymptotic
asymptotic advantage
advantage algorithm
practical depends
depends quality
algorithm wide
wide disparity
disparity reported
reported results
results machines
machines conquer
algorithm reported
reported outperform
outperform conventional
conventional method
method numbers
digits run
faster numbers
digits area
area importance
importance modern
cryptography outperformance
outperformance crossover
crossover machine
machine switching
switching conventional
conventional algorithm
algorithm multiplicands
multiplicands smaller
crossover finally
finally oriented
language java
java smalltalk
smalltalk aware
aware languages
languages special
special classes
classes dealing
dealing large
integers discovered
discovered year
year russian
russian mathematician
mathematician anatoly
anatoly karatsuba
karatsuba conquer
proved wrong
wrong prevailing
prevailing opinion
opinion efficiency
efficiency integer
algorithm discovery
discovery encouraged
encouraged researchers
researchers asymptotically
asymptotically faster
algorithms algebraic
algebraic problems
section strassen
multiplication conquer
approach digit
multiplications multiplying
integers surprised
surprised similar
similar feat
accomplished multiplying
published strassen
strassen str
str principal
insight algorithm
algorithm lies
lies discovery
discovery product
multiplications opposed
opposed required
section accomplished
accomplished formulas
formulas matrices
subtractions brute
lead multiplying
algorithm importance
importance stems
stems asymptotic
asymptotic superiority
superiority matrix
matrix infinity
infinity matrices
power matrices
matrices padded
padded rows
columns zeros
zeros product
product submatrices
submatrices difficult
verify submatrices
submatrices numbers
computed strassen
strassen formulas
formulas numbers
replaced submatrices
submatrices products
computed recursively
multiplication evaluate
evaluate asymptotic
relation log
nlog smaller
smaller required
algorithm savings
savings multiplications
multiplications achieved
achieved expense
expense making
making extra
extra additions
matrices make
make additions
subtractions matrices
matrices size
size additions
simply multiplied
multiplied observations
observations yield
yield recurrence
relation closed
exercises simply
simply establish
growth master
theorem nlog
nlog words
words additions
additions growth
growth multiplications
multiplications puts
puts strassen
algorithm nlog
nlog efficiency
strassen discovery
discovery algorithms
algorithms multiplying
matrices real
numbers progressively
progressively smaller
smaller constants
constants invented
invented fastest
algorithm coopersmith
coopersmith winograd
winograd coo
coo efficiency
efficiency decreasing
values exponents
exponents obtained
obtained expense
expense increasing
increasing complexity
complexity algorithms
large multiplicative
constants practical
practical interesting
interesting theoretical
theoretical view
view closer
closer theoretical
theoretical lower
bound matrix
multiplication multiplications
multiplications gap
gap bound
remains unresolved
unresolved matrix
multiplication computationally
computationally equivalent
equivalent important
equations discussed
exercises smallest
product decimal
integers compute
compute applying
text prove
equality alogb
clogb section
section nlog
nlog log
log closed
formula multiplications
addition assuming
assuming power
power sake
simplicity subtle
subtle assumption
assumption setting
setting recurrences
recurrences true
true final
final answers
answers assumption
assumption digit
additions pen
integers disregard
disregard potential
potential carries
carries verify
verify formulas
formulas underlying
underlying strassen
matrices apply
apply strassen
compute exiting
exiting recursion
recursion computing
matrices brute
additions required
required strassen
assume power
power pan
pan discovered
discovered conquer
conquer matrix
based multiplying
multiplications asymptotic
efficiency pan
pan algorithm
practical implementations
implementations strassen
method matrix
matrix sizes
crossover run
determine crossover
crossover closest
problems conquer
conquer section
solving classic
dimensional versions
versions problems
discuss sophisticated
sophisticated asymptotically
asymptotically efficient
problems based
technique closest
plane sake
points ordered
coordinate sort
sort efficeint
efficeint sorting
mergesort convenient
convenient points
coordinate denote
denote problem
solved obvious
obvious brute
points subsets
subsets points
points drawing
drawing vertical
vertical line
line median
median coordinates
line solve
idea conquer
problem rectangle
dmin recursively
recursively subsets
subsets smallest
smallest distances
distances pairs
min necessarily
necessarily smallest
distance pairs
pair sides
sides separating
line combining
subproblems points
points limit
attention points
points symmetric
symmetric vertical
vertical width
line distance
points width
line obtained
obtained ordered
coor dinate
dinate scan
scan updating
updating information
information dmin
distance encounter
encounter closer
points initially
initially dmin
dmin subsequently
subsequently dmin
dmin chance
chance closer
dmin difference
difference coordinates
coordinates dmin
dmin geometri
geometri cally
cally means
means rectangle
rectangle shown
figure principal
insight exploited
exploited algorithm
algorithm observation
observation rectangle
points half
half left
left rectangle
rectangle distance
distance easy
prove total
total points
points rectangle
rectangle exceed
exceed prob
exercises careful
analysis reduces
reduces joh
joh algorithm
points moving
moving pseudocode
algorithm advice
advice section
roots innermost
algorithm efficientclosestpair
efficientclosestpair solves
solves closest
conquer input
plane sorted
coordinates array
coordinates output
output euclidean
points minimal
minimal distance
remaining points
array efficientclosestpair
efficientclosestpair min
min points
dminsq num
dminsq min
min dminsq
dminsq sqrt
sqrt dminsq
dminsq algorithm
algorithm spends
spends linear
linear dividing
problems half
combining obtained
obtained solutions
solutions assuming
assuming usual
usual power
theorem log
log necessity
necessity presort
presort input
points efficiency
class sorting
mergesort fact
class achieve
achieve proved
log natural
natural assumptions
assumptions operations
pre convex
problem revisit
revisit convex
section smallest
plane conquer
called quickhull
quickhull resemblance
resemblance quicksort
quicksort set
plane assume
coordinates ties
ties resolved
resolved increasing
increasing coordinates
points involved
involved difficult
prove geometrically
geometrically obvious
obvious fact
fact leftmost
rightmost distinct
distinct extreme
hull figure
figure straight
points directed
line separates
separates points
points sets
line left
line directed
directed forms
forms counterclockwise
counterclockwise cite
cite analytical
analytical condition
condition based
checking determinant
determinant formed
formed coordinates
line extreme
hull excluded
excluded consideration
consideration boundary
hull polygonal
polygonal chains
chains upper
boundary lower
boundary upper
called upper
points lower
called lower
points fact
set composed
composed upper
hulls constructed
constructed independently
independently similar
similar fashion
fashion observation
observation exploited
exploited algorithms
problem concreteness
concreteness discuss
discuss quickhull
quickhull proceeds
proceeds construct
construct upper
hull lower
hull constructed
manner figure
figure upper
points pmax
pmax figure
idea quickhull
quickhull upper
hull simply
simply line
endpoints algorithm
identifies pmax
pmax farthest
farthest line
figure maximizes
maximizes angle
angle pmaxppn
pmaxppn selected
selected pmax
pmax maximizes
maximizes area
identifies points
set left
line pmax
pmax points
points make
line make
set difficult
prove pmax
pmax vertex
vertex upper
pmaxpn vertices
hull eliminated
eliminated consideration
consideration points
left lines
lines pmax
pmax algorithm
constructing upper
upper hulls
hulls pmax
pmax recursively
recursively simply
simply concatenate
concatenate upper
geometric operations
operations implemented
implemented fortunately
fortunately advantage
plane area
triangle equal
equal half
half magnitude
magnitude determinant
determinant expression
expression positive
line formula
formula constant
constant lies
lies left
line determined
determined points
points distance
line quickhull
quickhull worst
efficiency quicksort
quicksort problem
exercises average
algorithm benefit
benefit quicksort
quicksort savings
savings average
average balanced
balanced split
split problem
subproblems significant
significant fraction
fraction points
pmaxpn figure
figure eliminated
eliminated processing
processing natural
natural assumption
assumption points
points chosen
chosen randomly
randomly uniform
uniform dis
dis tribution
tribution convex
convex region
region circle
circle rectangle
rectangle average
quickhull turns
turns linear
linear ove
ove exercises
exercises dimensional
dimensional version
version closest
algorithm directly
technique determine
class good
prove conquer
problem examines
examines vertical
vertical figures
figures points
points encountered
encountered algorithm
version conquer
conquer dimensional
set simply
simply sort
sort sets
sets nondecreasing
coordinates recursive
recursive assuming
assuming sorting
mergesort set
relation running
case solve
solve implement
implement conquer
conquer closest
choice web
web visualization
visualization represent
represent voronoi
voronoi polygon
polygon set
defined perimeter
perimeter set
plane closer
closer union
union voronoi
voronoi polygons
polygons points
called voronoi
diagram voronoi
diagram set
points visualization
generating voronoi
diagram web
web study
examples diagrams
diagrams based
observations solution
previous generalized
case pmax
pmax quickhull
algorithm analytically
analytically case
quickhull specific
inputs make
make quickhull
quickhull run
run quadratic
quadratic implement
implement quickhull
quickhull language
choice creating
creating decagons
decagons points
plane line
line devise
construct decagons
decagons vertices
points decagons
decagons convex
convex simple
simple boundary
boundary decagons
decagons common
common shortest
path fenced
fenced area
area dimensional
dimensional clidean
plane shape
shape convex
points necessarily
necessarily points
max design
path oro
oro summary
summary conquer
technique solves
dividing smaller
size solving
solving recursively
recursively combining
technique inapplicable
inapplicable inferior
inferior simpler
simpler algorithmic
solutions running
running conquer
algorithms satisfies
recurrence master
establishes growth
solutions mergesort
mergesort conquer
works dividing
dividing input
array halves
sorted halves
halves original
log cases
cases key
comparisons theoretical
minimum principal
principal drawback
drawback significant
significant extra
storage requirement
requirement quicksort
quicksort conquer
works partitioning
partitioning input
elements relative
relative preselected
preselected element
element quicksort
quicksort noted
noted superior
superior efficiency
sorting randomly
arrays quadratic
postorder similar
similar algorithms
require recursive
recursive processing
processing left
examples conquer
technique analysis
analysis helped
helped replacing
special external
nodes conquer
requires digit
multiplications matrices
matrices exploiting
exploiting conquer
multiplications conquer
technique successfully
successfully applied
things mercy
mercy things
things johann
johann wolfgang
wolfgang von
von ethe
ethe space
computing values
points domain
domain premium
premium precompute
precompute function
table human
human computers
computers advent
advent electronic
computers process
process burdening
burdening libraries
libraries volumes
volumes mathematical
mathematical tables
tables lost
lost appeal
appeal widespread
widespread electronic
computers underlying
idea proven
proven development
development important
terms idea
afterward approach
enhancement discuss
counting methods
methods sorting
section boyer
matching simplified
version sug
sug gested
horspool section
offs simply
simply extra
data approach
approach prestructuring
prestructuring highlights
highlights facets
facets variation
variation space
space processing
processing problem
standard terms
terms synonymously
synonymously technique
technique preprocessing
preprocessing preconditioning
preconditioning confusingly
confusingly terms
terms applied
applied methods
methods idea
idea preprocessing
preprocessing extra
space chapter
chapter confusion
confusion input
enhancement special
special space
space technique
solved input
enhancement variety
variety deals
deals access
access structuring
structuring illustrate
illustrate approach
approach hashing
section indexing
indexing trees
technique related
related space
space idea
idea dynamic
programming strategy
strategy based
based recording
solu tions
tions overlapping
solu tion
discuss developed
developed technique
technique separately
separately chapter
chapter final
final comments
comments interplay
interplay space
design resources
space design
design situations
situations fact
fact align
align bring
bring algorithmic
solution minimizes
minimizes running
running space
space consumed
consumed situation
arises algorithm
represent problem
input leads
problem traversing
traversing graphs
graphs efficiency
breadth depends
repre senting
senting graphs
numbers vertices
edges input
input graphs
graphs sparse
sparse edges
representation efficient
space running
running points
points view
view situation
arises manipulation
manipulation sparse
matrices sparse
sparse polynomi
polynomi als
als percentage
percentage zeros
objects sufficiently
sufficiently high
high space
space ignoring
ignoring zeros
objects representation
representation processing
processing discuss
discuss space
offs mentioning
mentioning hugely
hugely important
important area
area data
compression data
sion size
reduction goal
goal technique
discuss data
chapter reader
interested topic
topic wealth
wealth algorithms
algorithms books
books sorting
sorting counting
counting applying
applying input
enhancement technique
obvious idea
idea element
sorted total
element results
numbers positions
index counting
counting sorted
simply copying
copying elements
counting sort
array initially
initially final
sorting comparison
nondecreasing efficiency
algorithm considers
considers pairs
array formally
formally times
executed equal
sum encountered
encountered times
addition linear
space positive
positive algorithm
moves placing
placing directly
directly final
counting idea
idea productively
productively situation
situation elements
sorted small
values assume
assume sort
sort values
values applying
applying general
general sorting
algorithm advantage
advantage additional
information values
simply make
make elements
equal remaining
equal generally
generally element
element values
integers lower
bound compute
compute frequency
frequency values
sorted filled
filled positions
positions overwrite
elements realistic
realistic situation
situation sorting
sorting items
information keys
keys overwrite
values equal
equal lowest
lowest copied
copied elements
elements copied
copied positions
positions accumulated
accumulated sums
sums frequencies
frequencies called
called distribution
distribution statistics
statistics method
method distribution
counting sorting
values set
set overwritten
overwritten process
sorting frequency
frequency distribution
distribution arrays
values frequencies
frequencies distribution
values distribution
values proper
proper positions
positions rences
rences elements
elements final
final sorted
positions distribution
values reduced
reduced element
element positions
positions convenient
convenient process
process input
element distribution
distribution position
sorted decrease
decrease distribution
distribution proceed
proceed element
array entire
entire processing
processing depicted
counting distribution
values decremented
decremented shown
algorithm distributioncountingsort
distributioncountingsort sorts
range distribution
nondecreasing initialize
initialize frequencies
frequencies compute
frequencies reuse
reuse distribution
distribution downto
downto assuming
assuming range
values fixed
fixed linear
makes consecutive
consecutive passes
passes input
class efficient
heapsort encountered
encountered important
obtained exploiting
exploiting specific
specific nature
nature inputs
inputs sorting
counting works
works addition
addition trading
space exercises
exercises exchange
exchange numeric
numeric values
variables extra
storage comparison
correctly arrays
values assuming
assuming set
alphabetical distribution
algorithm distribution
stable design
size values
values distinct
integers ancestry
ancestry problem
asks determine
ancestor vertex
binary generally
generally rooted
rooted ordered
design input
enhancement algorithm
algorithm sufficient
sufficient information
information solve
pair tree
vertices constant
constant technique
technique virtual
virtual initialization
initialization efficient
efficient initialize
initialize elements
elements constant
constant initialized
initialized utilizing
utilizing variable
variable counter
auxiliary arrays
size defined
defined counter
counter indices
elements initialized
initialized kth
element counter
initialized sketch
sketch state
state arrays
arrays signments
signments general
general scheme
scheme initialized
initialized distance
distance sorting
sorting egyptian
egyptian stone
stone statues
statues standing
row art
art gallery
gallery hall
hall curator
curator statues
statues ordered
ordered height
height minimize
total distance
distance statues
statues moved
moved assume
simplicity statues
statues heights
heights azi
azi write
matrices matrix
matrix write
sparse polynomials
polynomials degrees
degrees good
idea write
write plays
plays classic
classic game
game tic
tic tac
tac toe
toe human
human user
user storing
storing positions
positions game
board input
enhancement string
matching section
technique input
enhancement applied
recall problem
matching requires
finding occurrence
occurrence string
pattern longer
longer string
text discussed
section simply
simply matches
left mismatch
occurs shifts
position trial
trial maximum
maximum trials
trials worst
class average
shift random
texts average
turns faster
algorithms discovered
discovered exploit
exploit input
enhancement idea
preprocess pattern
pattern information
information table
table information
information actual
text idea
idea bestknown
bestknown algorithms
algorithms knuth
knuth morris
morris pratt
knu boyer
boy principal
difference algorithms
algorithms lies
lies characters
text knuthmorris
knuthmorris pratt
left idea
idea leads
leads simpler
algorithms pursue
pursue boyer
starts aligning
beginning characters
text trial
trial fails
fails shifts
pattern comparisons
comparisons trial
trial algorithm
left starting
pattern underlying
simple actual
implementation working
working method
method discussion
discussion simplified
hor addition
addition simpler
simpler horspool
efficient boyer
random strings
strings horspool
starting pattern
pattern moving
characters successfully
substring stopped
stopped altogether
altogether continued
continued occurrence
pattern desired
desired mismatch
occurs shift
make large
shift risking
risking possibility
possibility missing
determines size
character matches
matches counterpart
pattern general
general possibilities
possibilities case
letter safely
safely shift
length shift
case occurrences
occurrences character
shift align
align rightmost
text case
pattern shifted
shifted entire
length case
case finally
case rightmost
occurrence characters
text examples
examples demonstrate
demonstrate left
left character
comparisons lead
lead farther
farther shifts
position brute
pattern trial
trial lose
lose superiority
superiority fortunately
fortunately idea
idea input
enhancement makes
makes repetitive
repetitive comparisons
comparisons unnecessary
unnecessary precompute
precompute shift
sizes table
table indexed
indexed characters
characters encountered
text natural
texts space
space punctuation
punctuation symbols
symbols special
characters information
information text
text eventual
eventual searching
searching required
required table
entries shift
barber table
entries equal
equal entries
entries simple
computing shift
initialize entries
entries pattern
length scan
scan pattern
left repeating
times character
pattern overwrite
overwrite entry
table character
character distance
distance character
scans pattern
left overwrite
overwrite character
occurrence algorithm
algorithm shifttable
shifttable fills
fills shift
horspool boyer
moore algorithms
algorithms input
characters output
output table
size indexed
indexed alphabet
characters filled
filled shift
formula size
size table
summarize algorithm
algorithm horspool
length alphabet
column shift
character aligned
text pseudocode
pseudocode horspool
algorithm horspoolmatching
horspoolmatching implements
implements horspool
text output
left matching
substring matches
matches shifttable
shifttable generate
generate table
position pattern
pattern matched
characters table
table application
application horspool
comprises english
spaces denoted
denoted underscores
underscores shift
table mentioned
mentioned filled
filled character
character shift
shift actual
actual text
text proceeds
proceeds simple
demonstrate worst
exercises random
texts efficiency
class horspool
average brute
fact mentioned
mentioned efficient
efficient sophisticated
sophisticated predecessor
predecessor discovered
discovered boyer
moore boyer
outline boyer
comparison rightmost
rightmost character
text fails
algorithm thing
thing horspool
characters retrieved
table precomputed
precomputed explained
earlier algorithms
algorithms act
act differently
differently positive
positive pattern
successfully mismatch
mismatch encountered
pattern situation
situation boyer
determines shift
size quantities
quantities guided
guided text
character caused
caused mismatch
mismatch counterpart
pattern called
called badsymbol
badsymbol shift
reasoning shift
reasoning horspool
text conveniently
conveniently size
formula entry
entry precomputed
precomputed table
algorithm matched
letter text
positions formula
formula mismatching
mismatching character
text occurs
occurs pattern
pattern provided
provided pattern
positions shift
pattern negative
negative positions
positions fall
fall brute
brute thinking
thinking simply
simply shift
position summarize
summarize bad
computed boyer
algorithm quantity
quantity positive
negative expressed
expressed compact
compact formula
max shift
shift guided
guided successful
successful characters
pattern refer
refer ending
ending portion
portion pattern
size denote
denote suff
suff shift
shift apply
apply reasoning
reasoning guided
guided filling
filling bad
table based
based single
single alphabet
pattern suffixes
suffixes sizes
sizes good
table case
suff pattern
pattern accurate
accurate occurrence
occurrence useless
useless shift
pattern occurrence
character simply
simply failed
failed trial
trial case
occurrence preceded
suff rightmost
abcbab distances
distances pattern
abcbab occurrence
occurrence cases
cases shift
dbcbab shift
characters shifting
length occurrence
abcbab shifting
shifting matching
substring starts
starts text
aligned characters
dbcbab abcbab
substring prefix
prefix beginning
suffix ending
ending pattern
pattern erroneous
erroneous shift
shift based
based suffix
size occurrence
pattern preceded
occurrence longest
longest prefix
prefix size
size matches
matches suffix
size prefix
prefix exists
exists shift
computed distance
distance prefix
prefix suffix
suffix set
set pattern
length values
values good
abcbab prepared
prepared summarize
summarize boyer
entirety boyer
construct bad
earlier pattern
construct good
earlier align
encountered character
successfully case
column bad
character retrieve
entry good
positions computed
max shifting
shifting maximum
maximum shifts
shifts log
log ical
ical shifts
shifts based
observations text
matched group
group pattern
pattern rightmost
characters imply
imply shifting
shifting characters
characters spectively
spectively lead
lead aligning
interested shifting
pattern missing
substring maximum
numbers searching
text english
spaces bad
baobab actual
text figure
figure proceeds
proceeds pattern
pattern fails
fails counterpart
shifts tern
max positions
positions successfully
characters failure
suffix leads
pattern successfully
pair failure
shift max
figure string
matching boyer
iteration bad
symbol leads
pattern finds
finds matching
text successfully
matching characters
text searching
searching occurrence
pattern worst
ciency boyer
fast large
large alphabets
alphabets relative
relative length
pattern people
people simplified
versions horspool
algorithm dealing
dealing natural
language strings
strings exercises
text bess
bess knew
knew baobabs
baobabs problem
searching genes
genes dna
sequences hor
algorithm dna
sequence represented
represented text
text alphabet
segment pattern
segment chromo
chromo tcctattctt
tcctattctt apply
algorithm locate
locate pattern
pattern dna
sequence ttatagatctcgtattcttttatagatctcctattctt
ttatagatctcgtattcttttatagatctcctattctt character
comparisons horspool
zeros searching
length horspool
input horspool
algorithm discovers
discovers matching
substring large
shift make
comparisons boyer
zeros boyer
correctly bad
shifts boyer
correctly good
shifts characters
implement horspool
experiment efficiencies
efficiencies matching
matching random
patterns random
binary texts
texts random
language patterns
patterns natural
texts strings
characters establish
establish cyclic
shift plea
plea cyclic
shift leap
leap vice
versa formally
formally cyclic
shift obtained
obtained concatenating
concatenating character
character suffix
suffix character
character prefix
prefix design
design space
algorithm hashing
implement dictionaries
dictionaries recall
recall dictionary
searching lookup
lookup insertion
deletion defined
defined elements
set arbitrary
arbitrary nature
nature numbers
strings practice
practice important
records school
school citizen
citizen records
records governmental
governmental office
office records
records library
library typically
typically records
records comprise
comprise fields
fields responsible
responsible keeping
keeping information
information entity
entity represents
represents student
student fields
fields student
student date
birth sex
sex home
address major
major fields
fields called
key identifying
identifying entities
entities represented
represented records
student discussion
discussion assume
dictionary records
hashing based
idea distributing
table distribution
distribution computing
computing keys
keys predefined
predefined function
function assigns
assigns integer
address key
keys nonnegative
integers hash
division keys
assign letter
letter position
position alphabet
alphabet denoted
denoted ord
ord apply
apply kind
kind function
function integers
integers finally
string unsophisticated
unsophisticated option
option mod
mod option
option compute
compute ord
mod constant
constant larger
ord general
general hash
function conflicting
conflicting require
require ments
ments hash
size excessively
large compared
compared keys
keys sufficient
sufficient jeopardize
jeopardize implementation
implementation efficiency
distribute keys
evenly requirement
requirement makes
makes desirable
desirable applications
applications hash
function dependent
dependent bits
key hash
function easy
easy compute
compute obtained
treating ord
ord digits
digits based
computing decimal
decimal horner
horner finding
finding remainder
remainder dividing
dividing figure
hashing choose
choose hash
size smaller
keys collisions
collisions phenomenon
phenomenon keys
figure collisions
collisions expected
expected considerably
considerably larger
fact worst
table fortunately
fortunately appropriately
appropriately chosen
chosen hash
size good
good hash
function situation
situation rarely
rarely hashing
scheme collision
principal versions
versions hashing
called chaining
chaining closed
called addressing
addressing hashing
chaining hashing
lists attached
attached cells
table keys
words money
function simple
function strings
strings mentioned
mentioned positions
positions word
word letters
alphabet compute
sum remainder
division table
table key
hash mod
mod key
word installed
installed ninth
ninth cell
cell mod
mod final
result process
process figure
keys mod
mod dictionary
implemented table
lists simply
simply applying
key procedure
procedure creating
creating table
table illustrate
illustrate key
kid hash
figure compute
compute hash
kid attached
attached cell
cell linked
linked key
key collisions
collisions case
case traverse
traverse linked
linked comparing
string kid
kid string
unsuccessful general
general efficiency
searching depends
depends lengths
lengths linked
lists dictionary
dictionary table
table sizes
sizes quality
quality keys
construction chaining
chaining hash
function hash
evenly keys
keys ratio
ratio called
called factor
factor hash
table plays
plays crucial
crucial role
role efficiency
hashing average
average pointers
pointers chain
chain links
links inspected
inspected successful
searches turns
turns standard
assumptions searching
randomly selected
element hash
function distributing
keys uniformly
uniformly table
table cells
cells results
results natural
natural identical
searching sequentially
sequentially linked
linked gained
gained hashing
hashing reduction
reduction average
average size
factor size
factor small
small imply
imply lot
lot lists
lists inefficient
inefficient space
space large
large longer
longer times
times factor
factor amazingly
amazingly efficient
efficient scheme
key average
average price
price comparisons
comparisons true
true addition
addition comparisons
comparisons spend
spend computing
key constant
operation independent
independent remarkable
remarkable efficiency
result method
method ingenuity
ingenuity expense
expense extra
space dictionary
deletion identical
searching insertions
insertions problem
exercises modification
modification deletion
deletion performed
performed searching
deleted removing
removing efficiency
efficiency operations
operations identical
searching average
equal hash
size closed
addressing closed
stored hash
lists implies
implies table
large keys
keys strategies
strategies employed
employed collision
resolution simplest
simplest called
probing checks
checks cell
cell collision
collision occurs
occurs cell
cell key
key installed
installed cell
cell occupied
occupied availability
availability cell
cell successor
successor checked
checked hash
table reached
reached wrapped
wrapped beginning
beginning table
table treated
treated circular
circular array
array method
figure word
function illustrate
illustrate chaining
chaining key
key computing
construction cell
unsuccessful cell
cell occupant
occupant equal
equal matching
key cell
cell manner
manner encounter
encounter matching
successful cell
unsuccessful word
word lit
lit table
figure lit
lit mod
cell immediately
immediately kid
kid mod
mod kid
kid parted
parted declare
declare unsuccessful
unsuccessful insertion
insertion operations
operations straightforward
hashing deletion
deletion simply
simply delete
delete key
key state
figure unable
unable key
key afterward
afterward computing
algorithm location
location unsuccessful
unsuccessful result
result simple
simple solution
solution keys
parted money
money figure
construction linear
probing lazy
lazy deletion
deletion previously
previously occupied
occupied locations
locations special
symbol distinguish
distinguish locations
locations occupied
occupied mathematical
analysis linear
probing difficult
problem chaining
chaining simplified
versions results
results state
state average
average times
algorithm access
access hash
factor successful
searches accuracy
accuracy approximations
approximations increases
increases larger
larger sizes
sizes hash
numbers surprisingly
small densely
densely populated
populated tables
tables large
large percentage
percentage values
values hash
table closer
closer performance
performance linear
prob ing
ing deteriorates
deteriorates phenomenon
called clustering
clustering cluster
cluster linear
sequence contiguously
contiguously occupied
occupied cells
cells wrapping
wrapping final
figure clusters
clus ters
news hashing
hashing make
make dictionary
operations efficient
efficient clusters
clusters larger
larger probability
probability element
element attached
attached cluster
cluster increases
increases addition
addition large
large clusters
clusters probabil
probabil ity
ity clusters
clusters coalesce
coalesce key
insertion causing
causing clustering
clustering collision
resolution strategies
strategies suggested
suggested alleviate
alleviate problem
important hashing
scheme hash
function determine
fixed increment
increment probing
sequence collision
collision location
location mod
mod location
location table
table probed
probed sequence
sequence incre
incre ment
ment table
size prime
divisor condition
satisfied automatically
automatically prime
prime functions
functions recommended
recommended literature
literature mod
small tables
tables mod
mod larger
solved young
young graduate
student mathematics
mathematics named
named donald
knuth important
important scientists
scientists multivolume
multivolume treatise
treatise art
art programming
programming knui
knuiii knuiv
knuiv remains
remains comprehensive
comprehensive influential
influential algorithmics
algorithmics published
published mathematical
analysis hashing
hashing proved
difficult partial
partial results
results considerable
considerable practical
experience method
method good
good hashing
hashing functions
functions primary
primary secondary
secondary hashing
hashing perior
perior linear
probing performance
performance deteriorates
deteriorates table
table natural
natural solution
situation rehashing
rehashing current
table scanned
scanned keys
keys relocated
relocated larger
larger table
table worthwhile
worthwhile main
main properties
properties hashing
principal competitor
competitor implementing
dictionaries asymptotic
hashing searching
deletion implemented
implemented average
case balanced
trees average
average efficiencies
efficiencies log
cases ordering
ordering preservation
preservation balanced
trees hashing
hashing assume
assume existence
existence key
key ordering
ordering makes
makes hashing
hashing suitable
suitable applications
applications iterate
iterate keys
keys der
der require
require range
range queries
queries counting
counting keys
keys lower
bounds discovery
discovery ibm
ibm researchers
researchers hashing
hashing important
applications standard
standard technique
technique stor
stor ing
table symbols
symbols generated
generated compilation
compilation hashing
hashing handy
handy applications
applications checking
positions generated
generated chess
chess playing
playing sidered
sidered modifications
modifications proved
proved storing
dictionaries disks
disks variation
variation hashing
called extendible
disk access
access expensive
expensive compared
compared probes
probes performed
performed main
mem ory
ory preferable
preferable make
make probes
probes disk
accesses location
location computed
computed hash
function extendible
disk bucket
bucket hold
hold keys
key bucket
bucket identified
identified keys
keys read
read main
memory searched
discuss trees
alternative storing
dictionaries exercises
exercises input
table input
construct closed
idea hash
function letter
letter natural
language word
word probability
probability keys
keys evenly
evenly cells
table birthday
paradox birthday
paradox asks
asks people
people room
room chances
chances birthday
birthday month
month day
day unexpected
unexpected problem
problem implication
implication hashing
hashing result
questions chaining
chaining version
hashing insert
insert keys
keys knew
knew keys
keys dictionary
dictionary distinct
distinct dictionary
modification keys
keys linked
linked sorted
sorted dictio
dictio nary
modification advantage
advantage keys
stored entire
entire table
table sorted
sorted hashing
hashing elements
efficiency application
application efficiency
section presorting
entry worst
entry efficiency
classes implementations
implementations adt
adt dictionary
dictionary unordered
unordered ordered
ordered binary
binary balanced
balanced array
array tree
tree hashing
hashing insertion
deletion discussed
discussed hashing
hashing context
context techniques
based space
offs takes
advantage general
strategy write
write hashing
hashing problem
text generate
generate distinct
distinct words
words occurrences
occurrences word
text insert
insert counters
counters pro
gram empirical
empirical efficiency
hashing theoretical
theoretical results
figure parental
trees idea
idea extra
faster access
large records
records stored
disk principal
principal device
device organizing
sets index
information location
location records
records key
values data
sets structured
structured records
records opposed
opposed unstruc
unstruc tured
tured data
data text
text images
images video
video important
important index
index organization
organization tree
introduced bayer
bayer mcgreight
mcgreight bay
bay extends
extends idea
section permitting
permitting single
tree version
version data
stored leaves
leaves increasing
increasing keys
nodes indexing
indexing specifically
specifically parental
keys assumed
assumed sake
simplicity distinct
keys interposed
interposed pointers
equal smaller
key subtree
addition tree
tree structural
structural properties
properties root
leaf children
leaves children
balanced leaves
leaves node
node depicted
nodes classic
section comprises
comprises nodes
figure searching
similar searching
root chain
chain pointers
pointers leaf
keys leaf
stored sorted
sorted parental
node large
large make
make worthwhile
worthwhile key
comparisons concerned
concerned typical
application data
structure storing
data disk
disk nodes
correspond disk
disk pages
pages needed
access disk
disk page
page typically
typically orders
magnitude larger
larger needed
needed keys
keys fast
memory disk
accesses principal
indicator efficiency
efficiency similar
similar data
structures nodes
tree access
access key
tree estimate
estimate height
positive height
height root
key nodes
keys total
keys nodes
nodes children
children nodes
nodes total
general nodes
keys finally
finally leaf
leaf nodes
height inequality
inequality series
series standard
standard simplifications
simplifications problem
exercises inequality
inequality reduces
reduces yields
inequality immediately
implies searching
important ascertain
class actual
actual disk
accesses implied
implied formula
formula table
values estimates
estimates records
records typical
typical values
values tree
tree upper
bound mind
mind table
entries upper
upper estimates
estimates disk
accesses actual
applications rarely
rarely exceeds
exceeds tree
root nodes
nodes stored
stored fast
memory minimize
minimize disk
accesses operations
deletion straightforward
straightforward ing
outline insertion
algorithm deletion
algorithm references
references aho
aho cor
cor straightforward
algorithm inserting
insertion tree
tree outlined
procedure key
leaf room
leaf position
position keys
sorted room
leaf split
split half
half sending
sending half
half records
records node
node smallest
pointer inserted
parent immediately
immediately key
key pointer
pointer leaf
leaf recursive
recursive procedure
procedure percolate
percolate tree
created halves
halves root
keys split
split children
children root
shows result
result inserting
figure restriction
restriction leaves
leaves items
items aware
aware algorithms
algorithms implementing
implementing inser
inser tions
tree possibility
possibility recursive
nodes encountered
searching leaf
leaf possibility
possibility node
splits moving
moving key
node sibling
sibling inserting
figure moving
moving smallest
leaf sibling
sibling keys
keys replacing
replacing key
parent smallest
smallest figure
child modification
modification space
space expense
expense slightly
slightly complicated
complicated algorithm
tree indexing
indexing large
large considered
tree varieties
varieties types
trees btree
btree constructed
insertions data
records initially
tree considered
keys reside
reside leaves
leaves upper
upper levels
levels organized
organized tree
tree comprising
comprising index
index entire
entire structure
called fact
tree exercises
examples index
index real
applications involve
involve computers
computers prove
equality derivation
derivation upper
tree derivation
derivation inequality
inequality minimum
minimum tree
tree guarantees
guarantees disk
accesses searching
searching records
records exceed
exceed assume
assume root
root page
page stored
stored main
memory draw
assume leaf
leaf items
items outline
tree modifica
modifica tion
operation leaf
key encounters
encounters node
nodes sending
sending middle
node parent
root middle
key created
created construct
inserting keys
keys initially
advantage insertion
insertion procedure
procedure compared
compared trees
section disadvantage
disadvantage write
implementing key
visualization key
tree summary
summary space
technique trading
space prevalent
prevalent trading
space input
enhancement principal
varieties trading
afterward sorting
counting important
matching examples
technique distribution
counting special
special method
method sorting
sorting lists
lists elements
values horspool
matching considered
considered simplified
ideas input
enhancement left
left comparisons
characters algorithms
algorithms bad
moore table
table called
called good
table prestructuring
prestructuring technique
offs extra
data hashing
hashing trees
examples prestructuring
prestructuring hashing
hashing efficient
efficient approach
approach implementing
dictionaries based
idea mapping
mapping keys
size limitations
limitations table
table make
make collision
varieties hashing
chaining keys
table closed
addressing keys
stored table
table enable
enable searching
deletion average
tree generalizes
generalizes idea
allowing multiple
multiple keys
node principal
tree keeping
keeping index
disk choosing
choosing tree
tree appropriately
appropriately implement
deletion disk
accesses extremely
finding greatest
factors prime
consecutive primes
algorithm sieve
integers euclid
divisions euclid
set instances
speed memory
definite integrals
problems involving
designing algorithms
general techniques
algorithm designed
algorithm simplicity
algorithmic solutions
finding real
eat goat
called key
generally speaking
world applications
algorithms graph
obvious applications
called binary
linked node
operation called
vertices pair
edge graph
equal edge
vertex listed
tree representation
set defined
implementation dictionary
group algorithms
greed lack
lack word
word good
good greed
greed works
works michael
michael douglas
douglas actor
actor role
role gordon
gordon gecko
gecko wall
wall street
street revisit
revisit making
problem faced
minimum spanning tree
dynamic programming algorithm
boyer moore algorithm
vertices numbered higher
intermediate vertices numbered
paths intermediate vertices
topological sorting problem
optimal binary tree
single source shortest
lengths shortest paths
source shortest paths
linear programming problem
basic feasible solution
shortest paths problem
weighted connected graph
basic operation executed
kth smallest element
convex hull set
hull set points
augmenting path method
coin row problem
intermediate vertex numbered
vertex numbered higher
algorithm basic operation
variable size decrease
problems solved polynomial
comparison based algorithm
problem dynamic programming
design dynamic programming
shortest augmenting path
stable marriage problem
stable marriage algorithm
left binary exponentiation
recurrence relation key
character rightmost occurrence
good suffix table
bad symbol table
ith row column
average comparisons successful
entry pivot column
augmenting path algorithm
binary reflected gray
reflected gray code
decrease constant factor
dynamic programming algorithms
memory function method
binary trees keys
existence paths intermediate
shortest path paths
numbered higher shortest
shortest paths lengths
shortest paths intermediate
problem feasible region
brute string matching
relation key comparisons
extended binary tree
preceded character rightmost
hash table size
hamiltonian circuit problem
path augmenting path
ann lea sue
stable marriage matching
pairs shortest paths
problem solved polynomial
yield optimal solution
algorithm minimum spanning
spanning tree graph
connected weighted graph
points feasible region
size decrease algorithm
length shortest path
algorithm design techniques
spanning tree problem
ties broken arbitrarily
greatest common divisor
upper triangular matrix
closest pair problem
dynamic programming approach
index max index
max index max
coin optimal solution
largest coins robot
cell adjacent cell
programming algorithm knapsack
items knapsack capacity
item optimal subset
knapsack problem dynamic
dynamic programming table
floyd algorithm pairs
algorithm pairs shortest
transitive closure digraph
ith vertex intermediate
path intermediate vertex
boxed row column
row column existence
column existence paths
efficiency warshall algorithm
equal length shortest
maximum cardinality matching
matching bipartite graph
lea sue free
sue free men
free men bob
preorder inorder postorder
solutions smaller subproblems
instance knapsack problem
constructing optimal binary
establishing lower bounds
lower bound class
information theoretic lower
problem lower bound
decision tree algorithm
binary decision tree
draw decision tree
decision problems solved
problem polynomially reducible
characters pattern text
pattern barber text
pattern entire length
character pattern characters
bad symbol shift
good suffix shift
occurrence suff preceded
suff preceded character
keys hashed cell
hash table figure
comparisons successful table
inserting tree figure
strongly connected components
bit strings length
partition based algorithm
winning position player
algorithmic problem solving
yields optimal solution
algorithm kruskal algorithm
edges minimum spanning
spanning tree weighted
constructing minimum spanning
minimum weight edge
nearest tree vertex
tree vertices remaining
design greedy algorithm
shortest path source
fixed length encoding
frequencies symbol occurrences
huffman coding tree
searching sorted array
upper triangular coefficient
triangular coefficient matrix
binary exponentiation algorithm
feasible region problem
objective function equal
solve linear programming
entries objective row
directed edge positive
maximum matching bipartite
tom ann lea
computing greatest common
comparisons worst case
linear programming problems
vertex intermediate vertex
trivial lower bound
theoretic lower bound
problem coins weighings
class decision problems
decision traveling salesman
cnf satisfiability problem
dynamic programming technique
solving problems overlapping
classic dynamic programming
solving coin row
coins robot bring
robot bring cell
longest path dag
pseudocode dynamic programming
knapsack capacity optimal
composition optimal subset
memory function algorithm
algorithm constructing optimal
root optimal tree
column matrix equal
means exists path
numbered higher equal
numbered higher paths
paths lengths shortest
decrease conquer technique
source removal algorithm
key comparisons binary
russian peasant multiplication
element ith row
row column matrix
solve recurrence relation
times basic operation
child serves root
serves root subtree
root subtree keys
arrays worst case
key comparisons mergesort
write pseudocode conquer
pseudocode conquer algorithm
pivot left scan
scanning indices crossed
dutch national flag
inorder postorder traversals
traversal root visited
path length extended
length extended binary
multiplying digit integers
points sorted nondecreasing
points left line
sorted nondecreasing coordinates
graph positive integer
extra space facilitate
space facilitate faster
sorting distribution counting
natural language texts
horspool algorithm searching
text horspool algorithm
shift pattern entire
rightmost occurrence pattern
horspool algorithm pattern
shift pattern positions
symbol shift table
suffix shift table
moore algorithm pattern
suffix table shift
symbol table good
table good suffix
text algorithm retrieves
algorithm retrieves bad
retrieves bad symbol
hash function mod
cells hash table
hashed cell hash
cell hash table
money parted hash
prim algorithm section
times algorithm basic
growth constant multiple
method backward substitutions
greedy algorithm yields
algorithm yields optimal
constructed solution obtained
tree weighted connected
constructs minimum spanning
algorithm constructing minimum
input weighted connected
set tree vertices
vertex added tree
figure demonstrates application
spanning tree prove
proof prim algorithm
represented weight matrix
resulting set elements
efficiency sequence unions
sequence unions finds
graph minimum spanning
nearest source vertices
solve single source
weighted graph digraph
weighted path length
integer linear programming
convex hull problem
feasible region linear
region linear programming
extreme feasible region
initial basic feasible
path source sink
maximum problem network
augmenting path respect
augmenting path matching
committee members committee
members committee members
definition based algorithm
string matching problem
points convex hull
line segment endpoints
set points plane
person job person
string matching algorithm
extreme points feasible
application brute approach
improved modest effort
stack fake coins
set points convex
convex hull line
hull line segment
points line convex
domain grows exponentially
small instance problem
design exhaustive algorithm
depth dfs breadth
dfs breadth bfs
unvisited vertices edges
problem computing greatest
equivalent upper triangular
elements main diagonal
classical binary tree
space efficiencies algorithm
problems overlapping subproblems
algorithm knapsack problem
subset items knapsack
set recurrence relation
comparison based algorithms
algorithms sorting searching
numerical analysis science
based algorithm problem
lower bound tight
information theoretic argument
sorted array log
log lower bound
tight lower bound
decision tree figure
lower bound log
based algorithm sorting
algorithm sorting element
ternary decision tree
log positive integer
tree algorithm solves
solves problem coins
solved polynomial algorithm
positive integer weights
polynomially reducible decision
instance hamiltonian circuit
determine graph positive
degree taylor polynomial
numbers represented floating
significant decimal digits
error relative error
large relative error
dfs based algorithm
algorithm searching sorted
algorithm solves problem
comparison based sorting
relationship solution instance
variety decrease conquer
varies iteration algorithm
algorithm topological sorting
solve topological sorting
digraph represented adjacency
johnson trotter algorithm
algorithm generating bit
generating bit strings
key binary tree
instance chips winning
chips winning position
presorting based algorithm
key comparisons successful
binary tree defined
height binary tree
randomly ordered arrays
partition split position
set solve recurrence
pen pencil algorithm
algorithm multiplying digit
algorithm closest pair
analyzing efficiency nonrecursive
empirical analysis algorithm
efficiency analysis framework
basic operation times
orders growth functions
average case analysis
basic efficiency classes
comparing orders growth
functions orders growth
times comparison executed
von neumann neighborhood
disks peg auxiliary
linear equations unknowns
shortest path problem
algorithm dijkstra algorithm
starting character pattern
matching substring text
pattern shift pattern
positive decimal integer
average case efficiencies
shortest paths vertex
finding shortest paths
partially constructed solution
programming technique solving
technique solving problems
overlapping subproblems typically
subproblems typically subproblems
typically subproblems arise
subproblems arise recurrence
arise recurrence relating
subproblems dynamic programming
dynamic programming suggests
programming suggests solving
suggests solving smaller
recording results table
results table solution
table solution original
original problem obtained
compute nth fibonacci
application dynamic programming
variation dynamic programming
recurrence relating solution
solution problem solutions
problem solutions smaller
dynamic programming applications
dynamic ming algorithm
maximum coins maximum
compute filling row
filling row table
row table left
table left manner
left manner similar
maximum money picked
positive integers indicating
integers indicating coin
denominations shown figure
shown figure yields
sum means coin
means coin optimal
minimum coins denominations
applies dynamic programming
coin collecting problem
adjacent cell left
values row column
algorithm space efficiency
optimal path cell
path cell adjacent
efficiency solving coin
apply dynamic programming
series games win
games win series
write pseudocode dynamic
knapsack problem memory
subsets ith item
ith item optimal
optimal subset item
subset item optimal
capacity optimal subset
optimal subset selected
subset selected items
entry previous row
row columns left
goal figure table
solving knapsack problem
capacity figure solving
figure solving instance
solving instance knapsack
programming algorithm instance
item weight capacity
space efficiency algorithm
needed composition optimal
table entries initialized
function method knapsack
method knapsack problem
nonnegative integer indicating
apply memory function
function method instance
problem memory function
table generated dynamic
true false sequence
false sequence values
table knapsack problem
knapsack problem nondecreasing
binary tree optimal
key left subtree
keys optimally arranged
root optimal binary
table dynamic programming
programming algorithm constructing
successful searches optimal
tables main table
main table root
table root table
comparisons successful tree
optimal tree key
efficiency algorithm optimalbst
tree set keys
algorithm finding optimal
warshall algorithm computing
algorithm computing transitive
computing transitive closure
transitive closure directed
closure directed graph
recall adjacency matrix
directed path positive
positive length ith
digraph adjacency matrix
adjacency matrix transitive
matrix transitive closure
specifically element ith
numbered higher series
higher series starts
series starts intermediate
starts intermediate vertices
intermediate vertices paths
adjacency matrix digraph
vertex intermediate paths
algorithm compute elements
compute elements matrix
elements matrix predecessor
matrix predecessor series
predecessor series element
series element ith
path ith vertex
numbered higher intermediate
higher intermediate vertices
kth vertex intermediate
vertex intermediate vertices
exists path intermediate
generating elements matrix
figure application warshall
application warshall algorithm
warshall algorithm digraph
higher paths boxed
paths boxed row
algorithm digraph shown
pseudocode warshall algorithm
sparse graphs represented
traversal based algorithm
digraph weight matrix
bit strings bitwise
strings bitwise operation
path paths ith
paths ith vertex
simply weight matrix
weight matrix graph
graph negative length
path paths intermediate
higher equal length
application floyd algorithm
algorithm cubic efficiency
higher shortest paths
higher shortest path
apply warshall algorithm
warshall algorithm transitive
algorithm transitive closure
pairs straws connected
optimal solution problem
improved objective function
feasible solution optimal
simplex method classic
iterative improvement algorithms
figure feasible region
maximal objective function
adjacent extreme points
rows objective row
row entry pivot
pivot column tableau
entries pivot column
coefficient values problem
problem simplex method
xij uij edge
augmenting path augmenting
ford fulkerson method
rij uij xij
edge augmenting path
maximum minimum cut
finding maximum matching
bipartite graph vertices
path respect matching
matching maximum matching
maximum matching algorithm
jim tom jim
tom jim lea
tower hanoi puzzle
worst case average
subproblems ideally equal
ideally equal size
problem smaller subproblems
compute sum numbers
conquer algorithm called
instance size divided
size divided instances
divided instances size
establish solution growth
application conquer technique
halves sorting recursively
sorting recursively merging
power recurrence relation
comparisons mergesort worst
conquer algorithm finding
algorithm problem write
algorithm solve recurrence
design conquer algorithm
left scan denoted
scan denoted index
denoted index pointer
index pointer starts
pointer starts element
elements smaller pivot
subarray scan skips
scan skips elements
pivot stops encountering
stops encountering element
elements larger pivot
scanning indices pointing
indices pointing element
pointing element pointing
element pointing equal
prove scanning indices
case input strictly
input strictly decreasing
strictly decreasing arrays
real num bers
national flag problem
binary tree traversals
binary tree input
tree input binary
input binary tree
binary tree output
nodes binary tree
nodes shown squares
nodes shown circles
internal external node
root visited visiting
visited visiting left
binary tree algorithm
binary tree preorder
tree preorder inorder
classic traversal algorithms
postorder traversals tree
internal path length
defined sum lengths
sum lengths paths
multiplication large integers
strassen matrix multiplication
digit numbers product
numbers product computed
sum digits sum
product halves product
sum halves sum
applying master theorem
numbers decimal digits
integer multiplication algorithm
required brute algorithm
matrices strassen algorithm
multiplications strassen algorithm
strassen algorithm multiplying
algorithm multiplying matrices
additions strassen algorithm
based conquer technique
brute algorithm points
conquer algorithm closest
points closer dmin
width separating line
dmin minimum distance
points array points
array points array
set points left
hull sequence line
sequence line segments
line segments vertices
segments vertices points
hull entire set
upper lower hulls
case efficiency quickhull
closest pair algorithm
conquer sorting algorithm
adjacency lists graph
set convex hull
design brute algorithm
vertices connected component
job person job
space offs algorithm
offs algorithm design
algorithm design issue
design issue theoreticians
issue theoreticians practitioners
theoreticians practitioners computing
idea preprocess problem
preprocess problem input
problem input additional
input additional information
additional information obtained
information obtained accelerate
obtained accelerate solving
accelerate solving problem
solving problem afterward
technique exploits space
exploits space offs
facilitate faster flexible
faster flexible access
flexible access data
comparison counting algorithm
small set values
array hold sorted
distribution counting algorithm
initialized index element
index element initialized
write multiplying sparse
problem string matching
matches pairs characters
pairs characters pattern
random natural language
actual pattern text
characters pattern counterparts
pattern counterparts text
left boyer moore
simplified version boyer
version boyer moore
searching pattern barber
missing matching substring
aligned character pattern
character pattern case
pattern aligned text
pattern characters letter
characters letter situation
letter situation similar
situation similar case
shift sizes computed
sizes computed formula
pattern distance rightmost
alphabet pattern text
pattern text construct
construct shift table
align pattern beginning
pattern beginning text
beginning text matching
text matching substring
matching substring pattern
substring pattern reaches
pattern reaches character
reaches character text
character text starting
text starting character
matched mismatching pair
case retrieve entry
retrieve entry column
horspool algorithm string
english letters spaces
hor spool algorithm
barber text characters
text characters failing
characters failing letter
occurrence pattern abcbab
table boyer moore
shift table earlier
character pairs matched
text mismatched character
table shift pattern
pattern baobab text
failure comparison space
comparison space character
space character text
character text algorithm
pattern max iteration
leads farther shift
farther shift pattern
apply horspool algorithm
make character comparisons
algorithm make searching
moore algorithm correctly
table pattern shifts
efficient algorithm task
algorithm task space
task space efficiencies
keys cells hash
hash table evenly
figure collision keys
collision resolution mechanism
resolution mechanism principal
hashing keys stored
keys stored linked
stored linked lists
table linked lists
hash function key
keys money parted
parted hash addresses
hash addresses money
addresses money parted
figure hash table
hash table construction
hash function distributes
function distributes keys
hash table factor
computing hash function
operations insertion deletion
closed hashing addressing
state hash table
storing large dictionaries
extendible hashing disk
input hash function
function mod construct
hash table largest
table largest key
successful table average
operations benefit modification
equal smallest key
total minimum keys
upper bound height
bound height tree
tree obtained inserting
obtained inserting tree
key insertion algorithm
insertion algorithm tree
design analysis algorithms
vertices connected edge
equality gcd mod
middle school procedure
problem algorithm solves
person takes minutes
important problem types
problems numerical problems
large data sets
abstract data types
prove greedy algorithm
suggests constructing solution
obtained solution problem
solution problem reached
sequence locally optimal
locally optimal choices
optimal choices yield
prim algorithm kruskal
dijkstra algorithm shortest
trees minimum spanning
tree prim algorithm
spanning trees graph
algorithm constructs minimum
consists single vertex
nearest vertex tree
smallest weight ties
weight ties broken
tree constructed algorithm
spanning tree input
tree input weighted
connected graph output
graph output set
output set edges
set edges composing
edges composing minimum
composing minimum spanning
tree adjacent tree
adjacent tree vertex
simple task finding
broken arbitrarily identified
arbitrarily identified vertex
identified vertex added
added tree operations
application prim algorithm
algorithm specific graph
algorithm yield minimum
generated prim algorithm
tree graph minimum
graph minimum weight
assumption minimum spanning
weight equal weight
tree minimum spanning
correctness proof prim
algorithm depends data
depends data structures
graph represented weight
weight matrix priority
matrix priority implemented
priority implemented unordered
implemented unordered array
vertices remaining vertices
remaining vertices illustration
illustration figure application
shown bold figure
adjacency lists priority
greedy algorithm minimum
greedy algorithm yield
algorithm yield optimal
greedy algorithm problem
apply prim algorithm
prim algorithm graph
algorithm graph priority
priority fringe vertices
algorithm correctly graphs
correctly graphs negative
graphs negative edge
negative edge weights
weights minimum spanning
algorithm previous section
mini mum spanning
kruskal algorithm minimum
edges nondecreasing weights
correctness kruskal algorithm
application kruskal algorithm
prim kruskal algorithms
elements entire set
union disjoint subsets
implementation makeset requires
operation initialization singleton
initialization singleton subsets
sequence union operations
broken arbitrarily size
sequence union size
union size operations
updated resulting set
log union size
unions finds log
log quick union
version called union
true false minimum
weight edge connected
edge connected weighted
weighted graph edges
graph edges minimum
edge weights connected
weights connected weighted
weighted graph distinct
graph distinct graph
distinct graph minimum
minimum spanning forest
paths problem vertex
paths leading source
algorithm single source
dijkstra algorithm finds
vertex nearest source
source vertices adjacent
algorithm selects vertex
path source vertex
application dijkstra algorithm
algorithm compares path
compares path lengths
path lengths edge
prim algorithm compares
graph nonnegative weights
vertices weighted graph
graph digraph variation
digraph variation called
variation called single
single pair shortest
pair shortest path
solving single source
length encoding assigns
codewords frequent symbols
variable length encoding
codeword prefix codeword
root tree weight
huffman tree construction
numbers assigned leaves
path root ith
root ith leaf
minimum weighted path
questions needed chosen
codeword length frequent
function alphabet size
graph coloring problem
key comparisons worst
based sorting algorithm
matrix adjacency lists
simple path root
wolf goat cabbage
gaussian elimination algorithm
design presorting based
based algorithm solving
problem deter efficiency
deter efficiency class
original upper triangular
solve gaussian elimination
gaussian elimination matrix
stage gaussian elimination
apply gaussian elimination
equations unknowns unique
unknowns unique solution
gaussian elimination solve
tree avl tree
rotation avl tree
performed key inserted
child tree root
tree root insertion
height avl tree
equal keys children
essentially binary tree
parental dominance holds
deleting root key
term brute algorithm
compute left binary
problems solved algorithm
figure decision tree
graph hamiltonian circuit
hamiltonian circuit graph
solution original problem
constant factor algorithms
algorithm generating permutations
fake coin problem
elements greater equal
analysis recursive algorithms
tree recursive calls
case efficiency algorithm
recurrence initial conditions
elements fibonacci sequence
computing nth fibonacci
algorithm input size
bits binary representation
systems linear equations
algorithm string matching
searching insertion deletion
algorithm design strategies
brute straightforward approach
straightforward approach solving
directly based problem
based problem statement
problem statement definitions
statement definitions concepts
definitions concepts involved
based brute approach
brute approach problem
exchange element putting
element putting smallest
putting smallest element
smallest element final
element final position
action algorithm illustrated
vertical final positions
final positions considered
positions considered subsequent
considered subsequent iterations
makes exchanges sorted
exchanges sorted algorithm
brute approach results
approach results algorithm
results algorithm improved
algorithm improved modest
brute algorithm computing
algorithm based brute
ring star fully
star fully connected
fully connected mesh
dark light dark
algorithm make comparisons
array characters representing
points plane higher
plane higher dimensional
solution closest pair
compute distance pair
distance closest points
smaller square root
sets depicted figure
triangle rectangle generally
rectangle generally convex
generally convex polygon
definition convex hull
line segment connecting
segment connecting points
connecting points set
line convex hull
vertices points line
segment endpoints points
set extreme points
convex hull boundary
pair problem points
efficient algorithm office
algorithm office location
office location minimizing
class brute algorithm
brute algorithm convex
algorithm convex hull
brute approach combinatorial
constraints finding desired
salesman problem knapsack
knapsack problem assignment
hamiltonian circuit defined
figure presents small
presents small instance
instance assignment problem
assignment problem exhaustive
exhaustive impractical small
impractical small instances
exhaustive algorithm problem
queens row column
algorithm generating magic
generating magic squares
traversal arbitrary vertex
visited iteration algorithm
data structure representing
structure representing graph
unvisited vertices algorithm
connected component starting
component starting vertex
starting vertex visited
vertex visited unvisited
visited unvisited vertices
forest tree edges
tree edges shown
edges shown solid
traversal constructing called
serves root tree
root tree forest
tree forest unvisited
forest unvisited vertex
unvisited vertex reached
attached child vertex
child vertex reached
vertex reached edge
reached edge called
edge called tree
called tree edge
edge leading previously
leading previously visited
previously visited vertex
visited vertex predecessor
vertex predecessor parent
predecessor parent tree
traversal graph input
input graph output
output graph vertices
graph vertices marked
vertices marked consecutive
marked consecutive integers
traversal vertex unvisited
unvisited vertex marked
unvisited vertices connected
vertices connected vertex
connected vertex path
vertex path numbers
graph vertices edges
forest undirected graph
tree edges dfs
previously unvisited vertices
vertices reached pushed
stack vertices dead
ends popped stack
applications finding articulation
finding articulation points
traversal starting vertex
bfs based algorithm
minimum edge path
vertices adjacent levels
adjacent levels bfs
levels bfs tree
main facts depth
efficiency adjacency matrix
ties vertex alphabetical
true false dfs
false dfs forests
based algorithm checking
algorithm checking graph
checking graph bipartite
general framework outlined
framework outlined section
efficiency nonrecursive algorithms
analyzing efficiency recursive
indicating input size
constant multiple large
size algorithm runs
input size algorithm
constant multiple infinity
notation definition function
definition function denoted
function denoted bounded
integer definition illustrated
definition illustrated figure
limit based approach
input array real
digits binary representation
recurrence relation additions
executions basic operation
variable uniformly distributed
static algorithm visualization
recursive algorithm computing
solving systems linear
problem maximize subject
path positive length
binary tree set
relating solution problem
comparisons successful searches
length ith vertex
optimal solution instance
values knapsack capacity
vertices numbered vertices
numbered vertices numbered
pairs shortest path
solved algorithm problems
polynomial problem solved
lower bounds efficiency
needed solve problem
decision trees technique
establish lower bounds
based algorithms sorting
sorting searching sorted
called computational complexity
problems continuous mathematics
continuous mathematics solving
mathematics solving equations
systems equations evaluating
equations evaluating func
evaluating func tions
func tions computing
tions computing integrals
algorithm respect algorithms
respect algorithms problem
algorithm problem bound
algorithm lower bound
algorithm matching lower
matching lower bound
prove comparison based
trivial lower bounds
based counting items
counting items problem
items problem input
problem input processed
input processed output
processed output items
output items produced
lower bound algorithm
permutations distinct items
searching element sorted
lower bound based
called information theoretic
adversary method establishing
method establishing lower
lower bounds based
bounds based logic
based logic malevolent
algorithm consuming path
lower bound obtained
encountered problem discussing
lower bound key
bound key comparisons
comparisons comparison based
lower bound problem
solve lower bound
euclidean minimum spanning
multiplying arbitrary square
arbitrary square matrices
section exercises prove
log weighings worst
weighings worst case
connectivity graph vertices
binary decision trees
array decision trees
decision tree element
average comparisons algorithm
element insertion sort
decision tree binary
tree binary element
binary element array
ternary decision trees
decision trees figure
lower bound binary
tree height leaves
design comparison based
sorting element array
worst case draw
coins weighings extra
polynomial algorithm definition
solved polynomial called
seeks classify problems
decision problems answers
definition class decision
solved polynomial deterministic
algorithms class problems
class problems called
polynomial important problems
problems decision problems
adjacent vertices colored
decision problem solved
halting problem input
halts halt input
halt input halt
input halt halts
halt halts input
contributions theoretical science
bin packing problem
vast majority decision
majority decision problems
checking proposed solution
proposed solution solves
solution solves problem
nondeterministic guessing stage
hundreds difficult combinatorial
problem class definition
definition decision problem
problems polynomially reducible
reducible decision version
hamil tonian circuit
hamiltonian circuit length
problem hamiltonian circuit
image instance decision
instance decision traveling
entire expression true
deterministic polynomial algorithm
reducible problem polynomial
hamiltonian circuit eulerian
eulerian circuit graph
size graph subset
independent set size
continuous mathematical problems
truncation error smaller
represented floating numbers
precision significant decimal
absolute error relative
relative error representing
subtracting equal floating
equal floating numbers
relative errors approximations
danger subtractive cancellation
significant digits approximation
iterations newton method
general linear programming
problem optimal solution
vertex free vertex
technique based exploiting
based exploiting relationship
exploiting relationship solution
problem solution smaller
solution smaller instance
relationship established exploited
major variations decrease
variations decrease conquer
decrease conquer decrease
conquer decrease constant
problem figure decrease
instance half size
decrease conquer size
conquer size reduction
size reduction pattern
reduction pattern varies
pattern varies iteration
iteration algorithm euclid
application decrease technique
sorted array size
straight insertion sort
based recursive idea
iteration insertion sort
insertion sort makes
input array sorted
graph directions edges
dfs forest digraph
digraph dfs traversal
dfs forest directed
forest directed graph
starts listed vertex
problem solution digraph
topological sorting digraph
sorting problem solution
sorting problem algorithm
yields solution topological
solution topological sorting
application algorithm digraph
vertex incoming edges
based algorithm topological
source determine vertex
determine vertex digraph
vertex digraph represented
called strongly connected
dfs traversal digraph
algorithms generating combinatorial
discuss algorithms generating
generating permutations smaller
insert left insert
left insert left
trotter algorithm generating
generating permutations input
permutations input positive
integer output permutations
largest mobile element
algorithm generate subsets
element set subsets
subsets bit strings
generate bit strings
bit string based
string based algorithm
nonrecursive algorithm generating
generating binary reflected
decrease conquer algorithm
efficient algorithm searching
index array element
array element equal
case efficiency binary
coins piles coins
recurrence relation weighings
russian peasant method
people positions eliminated
person initial position
initial position person
prove general validity
bit cyclic shift
cyclic shift left
algorithm fake coin
russian peasant algorithm
solution josephus problem
size decrease algorithms
segment elements smaller
segment elements greater
smallest element array
solves selection problem
linear worst case
interpolation variable size
decrease algorithm searching
searching insertion binary
insertion binary tree
decreasing sequence keys
played piles chips
puts opponent winning
opponent winning position
losing positions player
instance nim sum
binary tree classify
tree classify algorithm
classify algorithm variable
algorithm variable size
decrease algorithm efficiency
class algorithm worst
worst case outline
direct application decrease
computational geometry closest
geometry closest pair
problem instance size
sorting algorithm works
input subarray array
subarray array defined
array defined left
defined left indices
left indices output
strictly increasing array
conquer general algorithm
mergesort worst case
comparisons algorithm brute
problem write pseudocode
running worst case
leaves binary tree
tree defined sum
product digits product
approach solving problem
binary tree figure
counting input array
output array elements
array elements sorted
elements sorted nondecreasing
brute algorithm section
string characters called
algorithm searching pattern
pattern characters pattern
mismatching pair encountered
searching patterns binary
patterns binary text
binary text zeros
table average key
traveling salesman problem
worst case comparisons
log worst case
common divisor integers
consecutive integer checking
integer checking algorithm
roots quadratic equation
graph figure adjacency
tree vertices graph
length simple path
collection disjoint subsets
edge connecting vertex
algorithm shortest path
shortest paths vertices
obtained greedy algorithm
spanning tree spanning
tree spanning tree
finding minimum spanning
algorithm prim algorithm
edges shown bold
section greedy algorithm
mum spanning tree
union operations union
algorithm greedy algorithm
input positive integer
points cartesian plane
computing square roots
element uniqueness problem
circuit eulerian circuit
brute algorithm problem
bit string representing
important special case
brute algo rithm
solving problem deter
instance linear programming
state space graph
state space graphs
set subsets set
satisfies constraints problem
typically involves small
involves small localized
improves objective function
objective function algorithm
function algorithm returns
algorithm returns feasible
returns feasible solution
solution optimal stops
greedy algorithm finding
important problems solved
method classic algorithm
important problem maximizing
efficient simplex method
iterative improvement algorithm
improvement algorithm problem
matching problem finding
feasible solution problem
constraints problem feasible
set points defined
points defined inequality
defined inequality comprises
inequality comprises points
comprises points line
largest objective function
points objective function
objective function problem
optimal solution linear
solution linear programming
programming problem optimal
programming problem constraints
points problem feasible
problems feasible region
programming problem unbounded
subject constraints optimal
constraints optimal solution
unbounded feasible region
feasible region optimal
region optimal solution
extreme problem feasible
subject linear programming
objective function extreme
extreme points grow
points grow exponentially
apply simplex method
variables required nonnegative
programming problem standard
feasible solution set
solution set variables
set variables solve
variables solve resulting
solve resulting basic
basic feasible solutions
values objective function
labeled basic variables
basic variables basic
values basic variables
row simplex method
tableau represents optimal
represents optimal solution
objective row possibly
signals fact objective
fact objective function
objective function increasing
function increasing coordinate
means min largest
min largest adjacent
largest adjacent extreme
objective row commonly
row commonly select
commonly select negative
variable basic variable
pivot column pivot
positive entry pivot
ratio dividing row
dividing row entry
row smallest ratio
row departing variable
pivot column ratio
entries pivot row
tableau represents basic
represents basic feasible
entry objective row
steps simplex method
select negative entry
variable pivot column
simplex method called
simplex method algorithm
iterative improvement idea
sequence feasible solutions
sequence adjacent extreme
problem solve linear
programming problem minimize
problem minimize subject
simplex method problem
simplex method solve
primal dual problems
edges vertex called
total material leaving
vertex conservation requirement
network sources sinks
intermediate vertices network
programming problem simplex
xij edge network
path called augmenting
called augmenting path
method ford fulkerson
augmenting path idea
edge capacity uij
augmenting path maximum
augmenting paths shown
connected directed edge
edge positive unused
positive unused capacity
unused capacity rij
capacity rij uij
edge positive xji
edges kind called
edges tail listed
conservation requirement vertex
positive unused capacities
forward edges positive
edges positive flows
edges augmenting path
iteration augmenting path
max min cut
min cut theorem
shown figure augmenting
figure augmenting path
edmonds karp edm
unlabeled vertex connected
connected vertex traversal
vertex traversal directed
traversal directed edge
vertex labeled min
network single source
source single sink
augmenting path sink
maximum application algorithm
final obtained augmenting
obtained augmenting path
directed path source
augment sink path
cut smallest capacity
capacity minimum cut
minimum cut network
sum flows edges
minimum cut capacity
figure algorithm finds
column set uij
cardinality matching largest
iterative improvement technique
bipartite graph matching
matching graph figure
matching shown figure
matching path augmenting
matching obtained augmentation
obtained augmentation matching
augmentation matching augmenting
matching augmenting path
maximum matching figure
matching perfect matching
matching matches vertices
respect matching exists
length alternating edges
free vertices sets
edge free vertex
free vertex adjacent
endpoint augmenting path
finds maximum matching
vertex adjacent free
graph vertices vertex
vertices vertex set
vertex set edges
cardinality matching problem
matching problem bipartite
problem bipartite graph
hall marriage theorem
matching called stable
men set women
position ranking preference
men preferences women
preferences women preferences
lea ann sue
jim tom bob
tom bob jim
bob jim tom
sue jim tom
instance stable marriage
blocking pair marriage
pair marriage matching
marriage problem stable
marriage matching men
matching men women
highest ranked woman
men bob proposed
accepted tom ann
men bob jim
bob jim proposed
rejected tom ann
tom jim sue
men bob tom
bob tom proposed
algorithm yields stable
yields stable matching
stable matching woman
optimal stable matching
efficiency class stable
class stable marriage
marriage matching instance
prove optimal stable
optimal stable marriage
input nonnegative integer
square root function
graph traversal algorithms
problem traveling salesman
connected components graph
edges dfs forest
vertices dead ends
dead ends popped
grows exponentially faster
solving problem directly
problem directly based
extreme points set
points set convex
extreme points convex
boundary convex hull
brute algorithm searching
person assigned job
edge connects vertex
graph bipartite vertices
vertices colored colors
based algorithm matrix
solved brute algorithm
vertex unvisited vertex
graph depth breadth
worst case inputs
algorithm innermost loop
nonnegative integer output
nonnegative integer definition
important algorithms areas
person understand teaching
notion algorithm section
problem solved algorithms
analyzing algorithms section
fundamental data structures
instructions solving problem
legitimate input finite
largest integer divides
gcd euclid algorithm
algorithms computing greatest
euclid algorithm presented
school procedure computing
procedure computing gcd
common elements sorted
elements sorted lists
common divisor positive
divisor positive integers
precision required algorithm
extended euclid algorithm
locker doors closed
input algorithm specifies
algorithm specifies instance
specifies instance problem
capabilities computational device
hungarian american mathematician
case algorithm called
general design techniques
solving problems algorithmically
problems algorithmically applicable
algorithmically applicable variety
applicable variety problems
variety problems areas
problems areas computing
algorithms underlying design
review basic data
basic data structures
algorithms natural language
natural language pseudocode
desirable characteristic algorithm
easier design algorithm
standard formula roots
formula roots quadratic
common divisor algorithm
antoine saint exupe
figure good algorithm
good algorithm result
algorithm result repeated
cabbage solve problem
takes minutes person
minutes person takes
problem types sorting
types sorting searching
sorting searching string
searching string processing
string processing graph
processing graph problems
graph problems combinatorial
combinatorial problems geometric
geometric problems numerical
important sorting algorithms
algorithms searching problem
string sequence characters
sequence characters alphabet
thought collection points
connected line segments
line segments called
segments called edges
wide variety applications
problem mentioned earlier
interested geometric algorithms
problem combinatorial terms
algorithms operate data
important elementary data
elementary data structures
data structures array
structures array linked
item null figure
representing abstract data
data items collection
collection data items
edge directed vertex
vertex called edge
depicted figure vertices
figure adjacency lists
figure weighted graph
path simple length
graph figure path
figure graph connected
figure graph cycles
rooted trees important
vertex free tree
root tree vertices
free tree rooted
efficient access large
access large data
path root vertex
vertex tree figure
length longest simple
height tree levels
tree figure binary
left child vertex
implementation binary tree
child sibling representation
representation tree figure
set unordered collection
unordered collection items
abstract data adt
delete ith element
stack operation sequence
operation sequence starts
element row column
items weights values
weights values knapsack
efficiency space efficiency
graphs represented adjacency
algorithm finding maximum
based idea transformation
instance simplification variety
transform conquer strategy
special property makes
instance simplification representation
simplest case trees
based representation idea
variety transform conquer
efficiency log worst
algo rithm problem
requires log comparisons
runlength runvalue runlength
searches needed justify
algorithm problem quadratic
problem quadratic efficiency
maximum points set
solution original upper
matrix zeros main
arbitrary coefficient matrix
solve upper triangular
yields upper triangular
input matrix column
matrix column vector
column vector output
vector output equivalent
output equivalent upper
triangular matrix values
matrix values column
exchange ith row
coefficient ith column
expensive addition subtraction
substitution stage gaussian
gaussian elimination yields
lower triangular matrix
computing matrix inverse
applying gaussian elimination
gaussian elimination linear
elimination linear equations
method solving equations
elimination solve instance
solve instance problem
instance problem panels
problem panels board
panels board initially
board initially lit
insertion deletion log
efficiency dictionary operations
definition avl tree
avl tree requires
left subtrees node
figure avl tree
avl tree binary
binary tree avl
avl tree numbers
node left subtrees
tree rooted unbalanced
rooted unbalanced node
unbalanced node closest
node closest newly
closest newly inserted
newly inserted leaf
single rotation general
rotation performed key
inserted left subtree
subtree left child
left child tree
left rotation mirror
rotation mirror image
key inserted subtree
rotation tree rooted
rotation figure general
figure general rotation
general rotation avl
avl tree shaded
tree shaded node
shaded node inserted
constructing avl tree
ordered keys children
node key leaf
keys tree nodes
log worst average
avl trees draw
trees draw binary
successively starting tree
tree real numbers
real numbers design
range difference largest
difference largest smallest
largest smallest numbers
smallest numbers tree
numbers tree determine
tree determine worst
smallest largest keys
theoretically important sorting
binary tree keys
parental node algorithm
larger key children
algorithm input array
require key comparisons
key comparisons height
parental dominance requirement
stage maximum deletions
algorithm finding deleting
finding deleting element
wealth literature subject
algorithm evaluating polynomial
input array coefficients
array coefficients polynomial
coefficients polynomial degree
polynomial degree stored
degree stored lowest
stored lowest highest
lowest highest output
highest output polynomial
output polynomial downto
horner optimal algorithm
optimal algorithm polynomial
algorithm polynomial evaluation
exploit binary representation
binary representation exponent
string representing exponent
binary exponentiation method
computes left binary
exponentiation algorithm input
algorithm input binary
input binary digits
digits binary expansion
product compute left
product accumulator algorithm
product term product
horner evaluate polynomial
apply left binary
exponentiation algorithm compute
problem solving strategy
horner polynomial evaluation
computing common multiple
product common prime
common prime factors
graph problem counting
paths length ith
ith vertex graph
vertex graph undirected
undirected directed equals
directed equals element
equals element adjacency
element adjacency matrix
adjacency matrix square
relationship minimization maximization
minimization maximization problems
finding extremum points
optimal decision making
decision making reduced
making reduced instance
variables subject constraints
subject constraints linear
equations linear inequalities
stocks bonds cash
invested stocks bonds
knapsack problem posed
fraction item knapsack
path initial state
initial state vertex
peasant wolf goat
state vertex labeled
vertex labeled pwgc
final state vertex
algorithm computing lcm
edge coloring problem
tiles unordered pair
unordered pair integers
problem easier solve
binary exponentiation algorithms
solving equations systems
equations systems equations
log binary tree
internal nodes tree
binary tree height
average worst cases
finding minimum numbers
set real numbers
finding largest element
lighter heavier genuine
coloring problem graph
key comparisons algorithm
adjacency matrix representation
edges tree edges
euclid algorithm computing
instance problem solution
problem size subproblem
size subproblem size
subproblem size solution
size solution subproblem
solution subproblem solution
subproblem solution original
original problem figure
cworst worst case
generating combinatorial objects
section discuss algorithms
key compared element
function grows slowly
sorted array elements
largest key comparisons
efficiency brute algorithm
algorithm problem section
general framework analyzing
notations big omega
big omega big
omega big theta
section general framework
outlined section systematically
section systematically applied
systematically applied analyzing
applied analyzing efficiency
algorithms main tool
efficiency recursive algorithms
algorithms computing fibonacci
computing fibonacci numbers
framework analyzing efficiency
space efficiency called
runs space efficiency
measuring input size
algorithm efficiency function
efficiency function parameter
function parameter indicating
size bits binary
consuming operation algorithm
operation algorithm innermost
analysis algorithm ficiency
counting times algorithm
inputs size compute
nonrecursive recursive algorithms
algo rithm basic
operation executed algorithm
running implementing algorithm
table values functions
functions important analysis
inputs realistic sizes
difference orders growth
function log increases
case input size
size input inputs
input inputs size
inputs size algorithm
basic operation inputs
operation inputs size
worst case analysis
algorithm runs fastest
sorted arrays algorithm
probability occurring ith
occurring ith position
investigation worst case
worst case efficiencies
efficiency measured counting
extra memory units
memory units consumed
growth algorithm running
input size infinity
largest element numbers
case scenario pairs
formula bits binary
higher growth constant
nonnegative functions defined
functions defined set
asymptotic notations formal
notations formal definitions
multiple large positive
large positive constant
positive constant nonnegative
constant nonnegative integer
constants required definition
big omega notation
denoted bounded positive
bounded positive constant
based approach comparing
approach comparing orders
lim limit equal
exponential functions orders
orders growth values
growth values base
efficiencies large algorithms
large algorithms fall
algorithms fall classes
algorithm asymptotic efficiency
typically characterizes efficiency
characterizes efficiency algorithms
efficiency algorithms embedded
algorithms embedded loops
embedded loops section
typical algorithms generate
listed increasing growth
elements array distinct
efficiency class entire
class entire algorithm
apply general framework
size elements array
general analyzing efficiency
algorithms parameter parameters
parameter parameters indicating
parameters indicating input
size algorithm basic
depends size input
case efficiencies investigated
efficiencies investigated separately
investigated separately set
set sum expressing
rules sum manipulation
recurrence relation times
analyzing recursive algorithms
recursive algorithms section
repetition innermost loop
loop variable limits
based algorithm computing
elements computed scalar
computed scalar dot
input positive decimal
decimal integer output
integer output binary
output binary digits
operation times basic
minval maxval minval
questions problem algorithm
input matrix real
matrix real numbers
cells von neumann
neumann neighborhood range
compute recursive algorithm
multiplications needed compute
recurrence relation initial
relation initial condition
solving recurrence relations
larger disk smaller
recursively disks peg
calls tower hanoi
figure tree recursive
calls recursive algorithm
recurrence recursive calls
algorithm computing sum
algorithm input positive
version tower hanoi
peg disk peg
design recursive algorithm
applications fibonacci numbers
computes nth fibonacci
definition input nonnegative
integer output nth
output nth fibonacci
algorithm computing nth
recursive definition based
analyze data obtained
basic operation physical
operation physical running
instances size included
generating random numbers
pseudo random variable
random variable uniformly
uniformly distributed interval
uniformly distributed integer
distributed integer values
linear congruential method
values sample range
mathematical empirical analyses
empirical analyses algorithms
images convey information
convey information algorithms
principal variations algorithm
variations algorithm visualization
algorithm visualization static
visualization static algorithm
algorithm visualization dynamic
visualization dynamic algorithm
dynamic algorithm visualization
algorithm visualization called
visualization called algorithm
called algorithm animation
figure initial final
initial final screens
final screens typical
screens typical visualization
typical visualization sorting
visualization sorting algorithm
sophisticated software systems
main tool analyzing
tool analyzing efficiency
expressing executions basic
basic operation ascertain
efficient algorithm finding
data structure called
vertices set vertices
algorithm solving systems
positive integer output
subsets element set
idea ghost spoken
ghost spoken charles
spoken charles dickens
charles dickens dynamic
dickens dynamic programming
programming algorithm design
design technique inter
technique inter esting
inter esting history
esting history invented
history invented prominent
invented prominent mathematician
prominent mathematician richard
mathematician richard bellman
richard bellman general
bellman general method
general method optimizing
method optimizing multistage
optimizing multistage decision
multistage decision pro
decision pro cesses
pro cesses word
cesses word programming
word programming technique
programming technique stands
technique stands planning
stands planning refer
planning refer programming
refer programming proving
programming proving important
proving important tool
important tool applied
tool applied mathematics
applied mathematics dynamic
mathematics dynamic programming
dynamic programming tually
programming tually considered
tually considered science
considered science circles
science circles general
circles general algorithm
design technique special
technique special types
special types optimization
types optimization problems
optimization problems view
problems view tech
view tech nique
tech nique dynamic
nique dynamic programming
recurrence relating problem
relating problem solution
problem solution solutions
solution solutions smaller
smaller subproblems solving
subproblems solving overlapping
solving overlapping subproblems
overlapping subproblems dynamic
solving smaller subproblems
smaller subproblems recording
subproblems recording results
problem obtained technique
obtained technique illustrated
technique illustrated revisiting
illustrated revisiting fibonacci
revisiting fibonacci numbers
numbers dis cussed
dis cussed section
cussed section read
section read section
read section discussion
section discussion beautiful
discussion beautiful topic
beautiful topic feel
topic feel temptation
feel temptation read
temptation read succumb
read succumb fibonacci
succumb fibonacci numbers
fibonacci numbers elements
numbers elements sequence
elements sequence defined
initial conditions recurrence
conditions recurrence directly
recurrence directly compute
directly compute nth
nth fibonacci recompute
fibonacci recompute values
recompute values function
values function times
function times figure
times figure problem
figure problem computing
problem computing expressed
computing expressed terms
expressed terms smaller
terms smaller overlapping
smaller overlapping subproblems
overlapping subproblems computing
subproblems computing simply
computing simply elements
simply elements dimensional
elements dimensional array
dimensional array consecutive
array consecutive values
consecutive values starting
values starting view
starting view initial
view initial conditions
initial conditions equation
conditions equation producing
equation producing elements
producing elements element
elements element array
element array single
array single loop
single loop pseudocode
loop pseudocode simple
simple algorithm section
algorithm section fact
section fact extra
fact extra array
extra array accomplish
array accomplish task
accomplish task recording
task recording values
recording values elements
values elements fibonacci
fibonacci sequence problem
sequence problem exercises
problem exercises phenomenon
exercises phenomenon unusual
phenomenon unusual counter
unusual counter examples
counter examples chapter
examples chapter straightforward
chapter straightforward application
straightforward application dynamic
dynamic programming interpreted
programming interpreted special
interpreted special variety
special variety space
variety space dynamic
space dynamic programming
programming algorithm fined
algorithm fined extra
fined extra space
extra space algorithms
space algorithms compute
algorithms compute nth
nth fibonacci computing
fibonacci computing preceding
computing preceding elements
preceding elements sequence
elements sequence section
sequence section typical
section typical algorithm
typical algorithm based
algorithm based classic
based classic dynamic
programming approach solve
approach solve smaller
solve smaller subproblems
smaller subproblems problem
subproblems problem variation
problem variation dynamic
programming approach seeks
approach seeks solving
seeks solving unnecessary
solving unnecessary subproblems
unnecessary subproblems technique
subproblems technique illustrated
technique illustrated section
illustrated section exploits
section exploits called
exploits called memory
called memory functions
memory functions considered
functions considered variation
considered variation dynamic
dynamic programming classical
programming classical version
classical version dynamic
version dynamic programming
dynamic programming variation
programming variation crucial
variation crucial designing
crucial designing algorithm
designing algorithm remains
algorithm remains deriving
remains deriving recurrence
deriving recurrence relating
smaller subproblems availability
subproblems availability equation
availability equation computing
equation computing nth
nth fibonacci exceptions
fibonacci exceptions majority
exceptions majority dynamic
majority dynamic programming
programming applications deal
applications deal optimiza
deal optimiza tion
optimiza tion problems
tion problems mention
problems mention general
mention general principle
general principle underlines
principle underlines applications
underlines applications richard
applications richard bellman
richard bellman called
bellman called principle
called principle optimality
principle optimality terms
optimality terms original
terms original formulation
original formulation optimal
formulation optimal solution
solution instance optimization
instance optimization problem
optimization problem composed
problem composed optimal
composed optimal solutions
optimal solutions subin
solutions subin stances
subin stances principle
stances principle optimality
principle optimality holds
optimality holds rare
holds rare fails
rare fails finding
fails finding longest
finding longest simple
simple path graph
path graph applicability
graph applicability problem
applicability problem checked
problem checked principal
checked principal difficulty
principal difficulty developing
difficulty developing dynamic
developing dynamic ming
ming algorithm sections
algorithm sections exercises
sections exercises chapter
exercises chapter standard
chapter standard examples
standard examples dynamic
examples dynamic programming
programming algorithms section
algorithms section fact
section fact invented
fact invented independently
invented independently discovery
independently discovery dynamic
discovery dynamic programming
dynamic programming viewed
programming viewed examples
viewed examples technique
examples technique applications
technique applications numerous
applications numerous applications
numerous applications range
applications range optimal
range optimal breaking
optimal breaking text
breaking text lines
text lines baa
lines baa image
baa image resizing
image resizing avi
resizing avi variety
avi variety applications
variety applications sophisticated
applications sophisticated engineering
sophisticated engineering problems
engineering problems ber
problems ber basic
ber basic examples
basic examples goal
examples goal section
goal section dynamic
section dynamic programming
dynamic programming typical
programming typical examples
typical examples coin
examples coin row
problem row coins
row coins values
coins values positive
values positive integers
integers necessarily distinct
necessarily distinct goal
distinct goal maximum
goal maximum money
maximum money subject
money subject constraint
subject constraint coins
constraint coins adjacent
coins adjacent initial
adjacent initial row
initial row picked
row picked maximum
picked maximum picked
maximum picked row
picked row coins
row coins derive
coins derive recurrence
derive recurrence partition
recurrence partition allowed
partition allowed coin
allowed coin selections
coin selections groups
selections groups coin
groups coin largest
coin largest group
largest group equal
group equal nth
equal nth coin
nth coin maximum
coin maximum coins
coins maximum group
maximum group equal
group equal definition
equal definition recurrence
definition recurrence subject
recurrence subject obvious
subject obvious initial
obvious initial conditions
conditions max compute
max compute filling
manner similar nth
similar nth fibonacci
nth fibonacci algorithm
fibonacci algorithm fib
algorithm fib section
fib section algorithm
section algorithm coinrow
algorithm coinrow applies
coinrow applies formula
applies formula maximum
formula maximum money
money picked coin
picked coin row
coin row picking
row picking adjacent
picking adjacent coins
adjacent coins input
coins input array
input array positive
array positive integers
indicating coin values
coin values output
values output maximum
output maximum money
money picked max
picked max application
max application algorithm
application algorithm coin
algorithm coin row
coin row denominations
row denominations shown
figure yields maximum
yields maximum pointing
maximum pointing index
pointing index max
index max figure
max figure solving
figure solving coin
row problem dynamic
dynamic programming coin
programming coin row
coin row fact
row fact solved
fact solved problem
solved problem coins
problem coins row
coins row maximum
row maximum coins
coins maximum total
maximum total computations
total computations possibilities
computations possibilities produced
possibilities produced maxima
produced maxima formula
maxima formula application
formula application formula
application formula sum
formula sum means
optimal solution moving
solution moving computing
moving computing maximum
computing maximum produced
maximum produced sum
produced sum means
optimal solution finally
solution finally maximum
finally maximum computing
maximum computing produced
computing produced implying
produced implying coin
implying coin optimal
optimal solution coin
solution coin optimal
optimal solution repeating
solution repeating computations
repeating computations backtracing
computations backtracing information
backtracing information terms
information terms larger
terms larger recorded
larger recorded extra
recorded extra array
extra array values
array values computed
values computed coinrow
computed coinrow largest
coinrow largest money
largest money picked
money picked coins
picked coins composing
coins composing optimal
composing optimal set
optimal set takes
set takes space
takes space superior
space superior alternatives
superior alternatives straightforward
alternatives straightforward topdown
straightforward topdown application
topdown application recurrence
application recurrence solving
recurrence solving problem
solving problem exhaustive
exhaustive problem section
section exercises making
exercises making problem
making problem general
problem general instance
general instance problem
instance problem minimum
problem minimum coins
united states countries
states countries simple
countries simple efficient
simple efficient algorithm
efficient algorithm discussed
algorithm discussed chapter
discussed chapter dynamic
chapter dynamic programming
programming algorithm general
algorithm general case
general case assuming
case assuming availability
assuming availability unlimited
availability unlimited quantities
unlimited quantities coins
quantities coins denominations
coins denominations minimum
denominations minimum coins
minimum coins values
coins values convenient
values convenient define
convenient define obtained
define obtained adding
obtained adding coin
adding coin denomination
coin denomination denominations
denomination denominations select
denominations select minimizing
select minimizing constant
minimizing constant smallest
constant smallest recurrence
smallest recurrence min
recurrence min ndj
min ndj compute
ndj compute filling
manner similar coin
similar coin row
row problem computing
problem computing table
computing table entry
table entry requires
entry requires finding
requires finding minimum
minimum numbers algorithm
numbers algorithm changemaking
algorithm changemaking applies
changemaking applies dynamic
dynamic programming minimum
programming minimum coins
coins denominations input
denominations input positive
positive integer array
integer array increasing
array increasing positive
increasing positive integers
indicating coin denominations
coin denominations output
denominations output minimum
output minimum coins
minimum coins temp
coins temp min
temp min temp
min temp application
temp application algorithm
application algorithm denominations
algorithm denominations shown
figure yields coins
yields coins space
coins space efficiencies
efficiencies algorithm min
algorithm min figure
min figure application
figure application algorithm
application algorithm mincoinchange
algorithm mincoinchange coin
mincoinchange coin denominations
coin denominations coins
denominations coins optimal
coins optimal solution
optimal solution backtrace
solution backtrace computa
backtrace computa tions
computa tions denominations
tions denominations produced
denominations produced minima
produced minima formula
minima formula instance
formula instance considered
instance considered application
considered application formula
application formula minimum
formula minimum produced
minimum produced minimum
produced minimum produced
minimum produced coin
produced coin denomination
coin denomination minimum
denomination minimum coin
minimum coin set
coin set coin
set coin collecting
collecting problem coins
problem coins cells
coins cells board
cells board coin
board coin cell
coin cell robot
cell robot located
robot located upper
located upper left
upper left cell
left cell board
cell board coins
board coins bring
coins bring cell
bring cell robot
cell robot cell
robot cell current
cell current location
current location robot
location robot visits
robot visits cell
visits cell coin
cell coin picks
coin picks coin
picks coin design
coin design algorithm
design algorithm maximum
algorithm maximum coins
maximum coins robot
coins robot path
robot path largest
path largest coins
bring cell ith
cell ith row
row column board
column board cell
board cell adjacent
adjacent cell adjacent
cell left largest
left largest numbers
largest numbers coins
numbers coins brought
coins brought cells
brought cells adjacent
adjacent cells row
cells row adjacent
row adjacent cells
adjacent cells left
cells left cells
left cells column
cells column cells
column cells assume
cells assume equal
assume equal nonexistent
equal nonexistent neighbors
nonexistent neighbors largest
neighbors largest coins
bring cell maximum
cell maximum numbers
maximum numbers coin
numbers coin cell
coin cell words
cell words formula
words formula max
formula max cij
max cij coin
cij coin cell
coin cell cij
cell cij formulas
cij formulas table
formulas table values
table values row
row column typical
column typical dynamic
typical dynamic programming
programming algorithms involving
algorithms involving dimensional
involving dimensional tables
dimensional tables algorithm
tables algorithm robotcoincollection
algorithm robotcoincollection applies
robotcoincollection applies dynamic
dynamic programming compute
programming compute largest
compute largest coins
coins robot board
robot board starting
board starting moving
starting moving upper
moving upper left
left corner input
corner input matrix
input matrix elements
matrix elements equal
elements equal cells
equal cells coin
cells coin output
coin output largest
output largest coins
bring cell max
cell max algorithm
max algorithm illustrated
illustrated figure coin
figure coin setup
coin setup figure
setup figure computing
figure computing formula
computing formula cell
formula cell table
cell table takes
table takes constant
takes constant efficiency
constant efficiency algorithm
efficiency algorithm space
space efficiency tracing
efficiency tracing computations
tracing computations backward
computations backward makes
backward makes optimal
makes optimal path
optimal path optimal
path optimal path
adjacent cell optimal
cell optimal path
cell left cell
left cell direction
cell direction yields
direction yields optimal
yields optimal paths
optimal paths instance
paths instance figure
instance figure shown
shown figure ties
figure ties optimal
ties optimal path
optimal path obtained
path obtained figure
obtained figure coins
figure coins dynamic
coins dynamic programming
programming algorithm results
algorithm results paths
results paths coins
paths coins maximum
coins maximum coins
maximum coins exercises
coins exercises dynamic
exercises dynamic programming
dynamic programming common
programming common conquer
common conquer principal
conquer principal difference
principal difference solve
difference solve instance
solve instance coin
instance coin row
row problem efficiency
problem efficiency solving
row problem straight
problem straight forward
straight forward application
forward application recurrence
application recurrence exponential
recurrence exponential efficiency
exponential efficiency solving
row problem exhaustive
problem exhaustive exponential
exhaustive exponential apply
exponential apply dynamic
programming algorithm solutions
algorithm solutions making
solutions making problem
making problem denominations
problem denominations modify
denominations modify dynamic
modify dynamic programming
programming algorithm coin
algorithm coin collecting
collecting problem cells
problem cells board
cells board inaccessible
board inaccessible robot
inaccessible robot apply
robot apply algorithm
apply algorithm board
algorithm board inaccessible
board inaccessible cells
inaccessible cells shown
cells shown optimal
shown optimal paths
optimal paths board
paths board rod
board rod cutting
rod cutting problem
cutting problem design
problem design dynamic
programming algorithm fol
algorithm fol lowing
fol lowing problem
lowing problem maximum
problem maximum total
maximum total sale
total sale price
sale price obtained
price obtained cutting
obtained cutting rod
cutting rod units
rod units integer
units integer length
integer length pieces
length pieces sale
pieces sale price
sale price piece
price piece units
piece units space
units space efficiencies
efficiencies algorithm shortest
shortest path counting
path counting chess
counting chess rook
chess rook horizontally
rook horizontally vertically
vertically square row
square row column
row column chessboard
column chessboard shortest
chessboard shortest paths
shortest paths rook
paths rook corner
rook corner chessboard
corner chessboard diagonally
chessboard diagonally corner
diagonally corner length
corner length path
length path measured
path measured squares
measured squares passes
squares passes squares
passes squares solve
squares solve problem
solve problem dynamic
programming algorithm elementary
algorithm elementary combinatorics
elementary combinatorics minimum
combinatorics minimum sum
sum descent positive
descent positive integers
positive integers arranged
integers arranged equilateral
arranged equilateral triangle
equilateral triangle numbers
triangle numbers base
numbers base shown
base shown figure
shown figure problem
figure problem smallest
problem smallest sum
smallest sum descent
sum descent triangle
descent triangle apex
triangle apex base
apex base sequence
base sequence adjacent
sequence adjacent numbers
adjacent numbers shown
shown figure circles
figure circles design
circles design dynamic
programming algorithm problem
problem efficiency binomial
efficiency binomial coefficient
binomial coefficient design
coefficient design efficient
algorithm computing bino
computing bino mial
bino mial coefficient
mial coefficient multiplications
coefficient multiplications space
multiplications space efficiencies
efficiencies algorithm longest
algorithm longest path
path dag design
dag design efficient
algorithm finding length
finding length longest
path dag problem
dag problem important
problem important prototype
important prototype dynamic
prototype dynamic programming
programming applications determines
applications determines minimal
determines minimal needed
minimal needed completing
needed completing project
completing project comprising
project comprising precedence
comprising precedence constrained
precedence constrained tasks
constrained tasks coin
tasks coin row
row problem discussed
section problem finding
problem finding longest
finding longest path
path dag maximum
dag maximum square
maximum square submatrix
square submatrix boolean
submatrix boolean matrix
boolean matrix largest
matrix largest square
largest square submatrix
square submatrix elements
submatrix elements zeros
elements zeros design
zeros design dynamic
programming algorithm efficiency
efficiency algorithm finding
finding largest free
largest free square
free square area
square area screen
area screen selecting
screen selecting construction
selecting construction site
construction site world
site world series
world series odds
series odds teams
odds teams playing
teams playing series
playing series games
series games teams
games teams wins
teams wins games
wins games assume
games assume probability
assume probability winning
probability winning game
winning game equal
game equal probability
equal probability losing
probability losing game
losing game ties
game ties probability
ties probability winning
probability winning series
winning series games
win series games
win series set
series set recurrence
recurrence relation dynamic
relation dynamic programming
programming algorithm probability
algorithm probability team
probability team winning
team winning game
winning game series
game series proba
series proba bility
proba bility winning
bility winning game
winning game write
game write pseudocode
programming algorithm solving
problem determine space
determine space efficiencies
space efficiencies knapsack
efficiencies knapsack problem
problem memory functions
memory functions section
functions section designing
section designing dynamic
designing dynamic programming
knapsack problem items
problem items weights
items knapsack problem
knapsack problem introduced
section discussed solving
discussed solving exhaustive
solving exhaustive assume
exhaustive assume weights
assume weights knapsack
weights knapsack capacity
knapsack capacity positive
capacity positive integers
positive integers item
integers item values
item values integers
values integers design
integers design dynamic
programming algorithm derive
algorithm derive recurrence
derive recurrence relation
recurrence relation expresses
relation expresses solution
expresses solution instance
solution instance knapsack
knapsack problem terms
problem terms solutions
terms solutions smaller
solutions smaller subinstances
smaller subinstances instance
subinstances instance defined
instance defined items
defined items weights
capacity optimal solution
solution instance valuable
instance valuable subset
knapsack capacity subsets
capacity subsets items
subsets items knapsack
knapsack capacity categories
capacity categories ith
categories ith item
ith item subsets
item subsets ith
optimal subset definition
subset definition subsets
definition subsets ith
optimal subset items
optimal subset optimal
subset optimal solution
solution feasible subsets
feasible subsets items
subsets items maximum
items maximum values
maximum values ith
values ith item
ith item knapsack
item knapsack optimal
knapsack optimal subset
selected items optimal
items optimal subset
selected items observations
items observations lead
observations lead recurrence
lead recurrence max
recurrence max convenient
max convenient define
convenient define initial
define initial conditions
initial conditions goal
conditions goal maximal
goal maximal subset
maximal subset items
optimal subset figure
subset figure illustrates
figure illustrates values
illustrates values involved
values involved equations
involved equations compute
equations compute entry
compute entry ith
entry ith row
row column compute
column compute maximum
compute maximum entry
maximum entry previous
previous row column
row column sum
column sum entry
sum entry previous
previous row columns
columns left table
left table filled
table filled row
filled row column
row column goal
column goal figure
figure table solving
table solving knapsack
dynamic programming capacity
programming capacity figure
algorithm instance data
instance data item
data item weight
weight capacity dynamic
capacity dynamic programming
programming table filled
table filled applying
filled applying formulas
applying formulas shown
formulas shown figure
figure maximal composition
maximal composition optimal
optimal subset backtracing
subset backtracing computations
backtracing computations entry
computations entry table
entry table item
table item included
item included optimal
included optimal solution
solution optimal subset
optimal subset filling
subset filling remaining
filling remaining units
remaining units knapsack
units knapsack capacity
capacity item optimal
item optimal selection
optimal selection leaves
selection leaves element
leaves element remaining
element remaining composition
remaining composition similarly
composition similarly item
similarly item final
item final optimal
final optimal solution
optimal solution item
solution item efficiency
item efficiency space
efficiency algorithm needed
algorithm needed composition
composition optimal solution
optimal solution asked
solution asked prove
asked prove assertions
prove assertions exercises
assertions exercises memory
exercises memory functions
memory functions discussed
functions discussed beginning
discussed beginning chapter
beginning chapter illustrated
chapter illustrated subsequent
illustrated subsequent sections
subsequent sections dynamic
sections dynamic programming
dynamic programming deals
programming deals problems
deals problems solutions
problems solutions recurrence
solutions recurrence relation
recurrence relation overlapping
relation overlapping subproblems
overlapping subproblems direct
subproblems direct approach
direct approach finding
approach finding solution
finding solution recurrence
solution recurrence leads
recurrence leads algorithm
leads algorithm solves
algorithm solves common
solves common subproblems
common subproblems inefficient
subproblems inefficient typically
inefficient typically exponential
typically exponential worse
exponential worse classic
worse classic dynamic
programming approach works
approach works fills
works fills table
fills table solutions
table solutions smaller
smaller subproblems solved
subproblems solved unsatisfying
solved unsatisfying aspect
unsatisfying aspect approach
aspect approach solutions
approach solutions smaller
smaller subproblems solution
subproblems solution problem
solution problem drawback
problem drawback approach
drawback approach natural
approach natural combine
natural combine strengths
combine strengths approaches
strengths approaches goal
approaches goal method
goal method solves
method solves subproblems
solves subproblems method
subproblems method exists
method exists based
exists based memory
based memory functions
memory functions method
functions method solves
method solves problem
solves problem manner
problem manner addition
manner addition maintains
addition maintains table
maintains table kind
table kind dynamic
kind dynamic programming
programming algorithm initially
algorithm initially table
initially table entries
entries initialized special
initialized special null
special null symbol
null symbol calculated
symbol calculated method
calculated method checks
method checks entry
checks entry table
table entry null
entry null simply
null simply retrieved
simply retrieved table
retrieved table computed
table computed recursive
computed recursive result
recursive result recorded
result recorded table
recorded table algorithm
table algorithm implements
algorithm implements idea
implements idea knapsack
idea knapsack problem
knapsack problem initializing
problem initializing table
initializing table recursive
table recursive function
recursive function called
function called items
called items knapsack
knapsack capacity algorithm
capacity algorithm mfknapsack
algorithm mfknapsack implements
mfknapsack implements memory
implements memory function
knapsack problem input
problem input nonnegative
integer indicating items
indicating items considered
items considered nonnegative
considered nonnegative integer
integer indicating knapsack
indicating knapsack capacity
knapsack capacity output
capacity output optimal
output optimal feasible
optimal feasible subset
feasible subset items
subset items global
items global variables
global variables input
variables input arrays
input arrays eights
arrays eights alues
eights alues table
alues table entries
entries initialized row
initialized row column
row column initialized
column initialized weights
initialized weights mfknapsack
weights mfknapsack max
mfknapsack max mfknapsack
max mfknapsack values
mfknapsack values mfknapsack
values mfknapsack weights
mfknapsack weights apply
weights apply memory
method instance considered
instance considered table
considered table figure
table figure results
figure results nontrivial
results nontrivial values
nontrivial values row
row column computed
column computed capacity
computed capacity figure
function algorithm nontrivial
algorithm nontrivial entry
nontrivial entry retrieved
entry retrieved recomputed
retrieved recomputed larger
recomputed larger instances
larger instances proportion
instances proportion entries
proportion entries significantly
entries significantly larger
significantly larger general
larger general constant
general constant factor
constant factor gain
factor gain memory
gain memory function
knapsack problem efficiency
class algorithm significant
algorithm significant improvement
significant improvement expected
improvement expected dynamic
expected dynamic programming
programming algorithms computation
algorithms computation takes
computation takes constant
takes constant mind
constant mind memory
mind memory function
function algorithm space
space efficient version
efficient version algorithm
version algorithm exercises
algorithm exercises apply
exercises apply dynamic
algorithm instance knapsack
knapsack problem item
problem item weight
weight capacity optimal
capacity optimal subsets
optimal subsets instance
subsets instance general
instance general table
general table generated
generated dynamic ming
ming algorithm optimal
algorithm optimal subset
optimal subset knapsack
subset knapsack problem
problem instance write
instance write pseudocode
knapsack problem write
pseudocode algorithm finds
algorithm finds composition
finds composition optimal
optimal subset table
subset table generated
generated dynamic programming
knapsack prob lem
prob lem prove
lem prove efficiency
prove efficiency space
space efficiency needed
efficiency needed composition
optimal subset filled
subset filled dynamic
filled dynamic programming
programming table true
table true false
sequence values row
values row dynamic
row dynamic programming
programming table knapsack
problem nondecreasing true
nondecreasing true false
sequence values column
values column dynamic
column dynamic ming
dynamic ming table
ming table knapsack
problem nondecreasing design
nondecreasing design dynamic
programming algorithm version
algorithm version knapsack
knapsack problem unlimited
problem unlimited quantities
unlimited quantities copies
quantities copies item
copies item kinds
item kinds efficiency
kinds efficiency algorithm
efficiency algorithm apply
algorithm apply memory
method instance knapsack
knapsack problem entries
problem entries dynamic
entries dynamic programming
programming table computed
table computed memory
computed memory function
function method retrieved
method retrieved recomputation
retrieved recomputation prove
recomputation prove efficiency
prove efficiency class
efficiency class memory
class memory function
function algorithm knap
algorithm knap problem
knap problem algorithm
algorithm problem memory
memory function approach
function approach unattractive
approach unattractive problem
unattractive problem computing
problem computing binomial
computing binomial coefficient
binomial coefficient formula
coefficient formula write
formula write research
write research applications
research applications dynamic
applications dynamic programming
dynamic programming finding
programming finding longest
finding longest common
longest common subsequence
common subsequence sequences
subsequence sequences optimal
sequences optimal string
optimal string editing
string editing minimal
editing minimal triangulation
minimal triangulation polygon
triangulation polygon optimal
polygon optimal binary
optimal binary trees
binary tree important
tree important data
data structures science
structures science principal
science principal applications
principal applications implement
applications implement dictionary
implement dictionary set
dictionary set elements
set elements operations
elements operations searching
insertion deletion probabilities
deletion probabilities figure
probabilities figure binary
trees keys searching
keys searching elements
searching elements set
elements set accumulated
set accumulated data
accumulated data searches
data searches natural
searches natural pose
natural pose optimal
pose optimal binary
binary tree average
tree average comparisons
average comparisons smallest
comparisons smallest simplicity
smallest simplicity limit
simplicity limit discussion
limit discussion minimizing
discussion minimizing average
minimizing average comparisons
comparisons successful method
successful method extended
method extended unsuccessful
extended unsuccessful searches
unsuccessful searches keys
searches keys searched
keys searched probabilities
searched probabilities figure
probabilities figure depicts
figure depicts binary
depicts binary trees
trees keys average
keys average comparisons
comparisons successful trees
successful trees fact
trees fact optimal
fact optimal binary
tree optimal tiny
optimal tiny optimal
tiny optimal tree
optimal tree generating
tree generating binary
generating binary trees
trees keys general
keys general algorithm
general algorithm exhaustive
algorithm exhaustive approach
exhaustive approach unrealistic
approach unrealistic total
unrealistic total binary
total binary trees
trees keys equal
keys equal nth
equal nth catalan
nth catalan grows
catalan grows infinity
grows infinity fast
infinity fast problem
fast problem section
section exercises distinct
exercises distinct keys
distinct keys ordered
keys ordered smallest
ordered smallest largest
smallest largest probabilities
largest probabilities searching
probabilities searching smallest
searching smallest average
smallest average comparisons
comparisons successful binary
successful binary tree
binary tree tij
tree tij keys
tij keys integer
keys integer indices
integer indices classic
indices classic dynamic
programming approach values
approach values smaller
values smaller instances
smaller instances problem
instances problem interested
problem interested derive
interested derive recurrence
derive recurrence underlying
recurrence underlying dynamic
underlying dynamic programming
programming algorithm ways
algorithm ways choose
ways choose root
choose root keys
root keys binary
keys binary tree
figure root key
left subtree tik
subtree tik keys
tik keys optimally
optimally arranged subtree
arranged subtree tkj
subtree tkj optimal
tkj optimal bst
optimal bst figure
bst figure binary
binary tree bst
tree bst root
bst root optimal
optimal binary subtrees
binary subtrees tik
subtrees tik tkj
tik tkj keys
tkj keys optimally
optimally arranged taking
arranged taking advantage
taking advantage principle
advantage principle optimality
principle optimality tree
optimality tree levels
levels starting make
starting make comparison
make comparison numbers
comparison numbers equal
numbers equal keys
equal keys levels
keys levels recurrence
levels recurrence relation
recurrence relation obtained
relation obtained min
obtained min tik
min tik ikj
tik ikj tkj
ikj tkj min
tkj min tik
min tik tkj
tik tkj ikj
tkj ikj min
ikj min ikj
min ikj recurrence
ikj recurrence min
recurrence min ikj
min ikj assume
ikj assume formula
assume formula interpreted
formula interpreted comparisons
interpreted comparisons tree
comparisons tree formula
tree formula implies
formula implies node
implies node binary
node binary tree
binary tree goal
tree goal figure
figure table dynamic
binary tree dimensional
tree dimensional table
dimensional table figure
table figure shows
figure shows values
shows values needed
values needed comput
needed comput ing
comput ing formula
ing formula row
formula row columns
columns left column
left column rows
column rows row
rows row arrows
row arrows pairs
arrows pairs sums
pairs sums computed
sums computed smallest
computed smallest recorded
smallest recorded suggests
recorded suggests filling
suggests filling table
filling table diagonals
table diagonals starting
diagonals starting zeros
starting zeros main
main diagonal probabilities
diagonal probabilities moving
probabilities moving upper
moving upper corner
upper corner algorithm
corner algorithm sketched
algorithm sketched computes
sketched computes average
computes average comparisons
searches optimal binary
tree optimal tree
optimal tree maintain
tree maintain dimensional
maintain dimensional table
dimensional table minimum
table minimum achieved
minimum achieved table
achieved table shape
table shape table
shape table figure
table figure filled
figure filled manner
filled manner starting
manner starting entries
starting entries table
entries table filled
table filled entries
filled entries indices
entries indices roots
indices roots optimal
roots optimal subtrees
optimal subtrees makes
subtrees makes reconstruct
makes reconstruct optimal
reconstruct optimal tree
optimal tree entire
tree entire set
entire set illustrate
set illustrate algorithm
illustrate algorithm applying
algorithm applying key
applying key set
key set beginning
set beginning section
beginning section key
section key probability
key probability initial
probability initial tables
initial tables main
root table compute
table compute min
compute min binary
min binary trees
trees keys root
keys root optimal
optimal tree index
tree index average
index average comparisons
successful tree finish
tree finish computations
finish computations exercises
computations exercises final
exercises final tables
final tables main
root table average
key comparisons optimal
comparisons optimal tree
optimal tree equal
equal root optimal
tree key left
left subtree keys
subtree key specific
key specific structure
specific structure subtrees
structure subtrees roots
subtrees roots consulting
roots consulting root
consulting root table
root table root
table root optimal
optimal tree left
left child root
child root onenode
root onenode tree
onenode tree root
root node optimal
node optimal tree
tree key figure
key figure presents
figure presents optimal
presents optimal tree
optimal tree entirety
tree entirety figure
entirety figure optimal
figure optimal binary
binary tree pseudocode
tree pseudocode dynamic
programming algorithm optimalbst
algorithm optimalbst finds
optimalbst finds optimal
finds optimal binary
binary tree dynamic
tree dynamic programming
dynamic programming input
programming input array
input array probabilities
array probabilities sorted
probabilities sorted keys
sorted keys output
keys output average
output average comparisons
searches optimal bst
optimal bst table
bst table subtrees
table subtrees roots
subtrees roots optimal
roots optimal bst
optimal bst diagonal
bst diagonal minval
diagonal minval kmin
minval kmin sum
kmin sum minval
sum minval sum
minval sum algorithm
sum algorithm space
space efficiency quadratic
quadratic efficiency version
efficiency version algorithm
version algorithm cubic
algorithm cubic careful
cubic careful analysis
careful analysis shows
analysis shows entries
shows entries root
entries root table
root table nondecreasing
table nondecreasing row
nondecreasing row column
row column limits
column limits values
limits values range
values range makes
range makes running
makes running algorithm
running algorithm exercises
algorithm exercises finish
exercises finish computations
finish computations started
computations started section
started section constructing
section constructing optimal
binary tree efficiency
tree efficiency algorithm
algorithm optimalbst cubic
optimalbst cubic space
cubic space efficiency
algorithm optimalbst quadratic
optimalbst quadratic write
quadratic write pseudocode
write pseudocode linear
pseudocode linear algorithm
linear algorithm generates
algorithm generates optimal
generates optimal binary
tree root table
root table devise
table devise compute
devise compute sums
compute sums dynamic
sums dynamic programming
binary tree constant
tree constant sum
constant sum true
sum true false
true false root
false root optimal
tree key highest
key highest probability
highest probability construct
probability construct optimal
construct optimal binary
set keys equally
keys equally searched
equally searched average
searched average comparisons
successful tree distinct
tree distinct binary
distinct binary trees
binary trees constructed
trees constructed set
constructed set orderable
set orderable keys
orderable keys satisfies
keys satisfies recurrence
satisfies recurrence relation
recurrence relation solution
relation solution recurrence
solution recurrence catalan
recurrence catalan numbers
catalan numbers verify
numbers verify assertion
verify assertion growth
assertion growth implication
growth implication exhaustive
implication exhaustive algorithm
exhaustive algorithm constructing
finding optimal binary
binary tree generalize
tree generalize optimal
generalize optimal binary
optimal binary algorithm
binary algorithm taking
algorithm taking account
taking account unsuc
account unsuc cessful
unsuc cessful searches
cessful searches write
searches write pseudocode
write pseudocode memory
pseudocode memory function
memory function optimal
function optimal binary
binary tree problem
tree problem limit
problem limit function
limit function finding
function finding smallest
finding smallest key
smallest key comparisons
comparisons successful matrix
successful matrix chain
matrix chain multiplication
chain multiplication problem
multiplication problem minimizing
problem minimizing total
minimizing total multiplications
multiplications computing product
product matrices dimensions
matrices dimensions assume
dimensions assume intermediate
assume intermediate products
intermediate products matrices
matrices computed brute
computed brute definition
brute definition based
based algorithm matrices
matrices multiplications differ
multiplications differ factor
differ factor ways
factor ways compute
ways compute product
compute product matrices
product matrices design
matrices design dynamic
programming algorithm finding
finding optimal multiplying
optimal multiplying matrices
multiplying matrices warshall
matrices warshall floyd
warshall floyd algorithms
floyd algorithms section
section algorithms warshall
algorithms warshall algorithm
directed graph floyd
graph floyd algorithm
paths problem algorithms
problem algorithms based
algorithms based essentially
based essentially idea
essentially idea exploit
idea exploit relationship
exploit relationship problem
relationship problem simpler
problem simpler smaller
simpler smaller version
smaller version warshall
version warshall floyd
warshall floyd published
floyd published algorithms
published algorithms mention
algorithms mention ing
mention ing dynamic
programming algorithms dynamic
algorithms dynamic programming
dynamic programming flavor
programming flavor considered
flavor considered applications
considered applications tech
applications tech nique
tech nique warshall
nique warshall algorithm
warshall algorithm recall
algorithm recall adjacency
adjacency matrix aij
matrix aij directed
aij directed graph
directed graph boolean
graph boolean matrix
boolean matrix ith
matrix ith row
row column directed
column directed edge
directed edge ith
ith vertex interested
vertex interested matrix
interested matrix information
matrix information existence
information existence directed
existence directed paths
directed paths arbitrary
paths arbitrary lengths
arbitrary lengths vertices
lengths vertices graph
vertices graph matrix
graph matrix called
matrix called transitive
called transitive closure
closure digraph determine
digraph determine constant
determine constant vertex
constant vertex reachable
vertex reachable ith
reachable ith vertex
ith vertex application
vertex application examples
application examples spreadsheet
examples spreadsheet cell
spreadsheet cell changed
cell changed spreadsheet
changed spreadsheet software
spreadsheet software cells
software cells affected
cells affected spreadsheet
affected spreadsheet modeled
spreadsheet modeled digraph
vertices represent spreadsheet
represent spreadsheet cells
spreadsheet cells edges
cells edges cell
edges cell dependencies
cell dependencies transitive
dependencies transitive closure
transitive closure information
closure information software
information software engineering
software engineering transitive
engineering transitive closure
transitive closure investigating
closure investigating data
investigating data control
data control dependencies
control dependencies inheritance
dependencies inheritance testing
inheritance testing oriented
testing oriented software
oriented software electronic
software electronic engineering
electronic engineering redundancy
engineering redundancy identification
redundancy identification generation
identification generation digital
generation digital circuits
digital circuits definition
circuits definition transitive
definition transitive closure
graph vertices defined
vertices defined boolean
defined boolean matrix
boolean matrix tij
matrix tij element
tij element ith
row column exists
column exists nontrivial
exists nontrivial path
nontrivial path directed
ith vertex tij
vertex tij digraph
tij digraph adjacency
transitive closure figure
closure figure generate
figure generate transitive
generate transitive closure
closure digraph depth
digraph depth breadth
depth breadth performing
breadth performing traversal
performing traversal starting
traversal starting ith
starting ith figure
ith figure digraph
figure digraph adjacency
transitive closure vertex
closure vertex information
vertex information vertices
information vertices reachable
vertices reachable columns
reachable columns ith
columns ith row
ith row transitive
row transitive closure
transitive closure traversal
closure traversal vertex
traversal vertex starting
vertex starting yields
starting yields transitive
yields transitive closure
transitive closure entirety
closure entirety method
entirety method traverses
method traverses digraph
traverses digraph times
digraph times algorithm
times algorithm exists
algorithm exists called
exists called warshall
called warshall algorithm
warshall algorithm stephen
algorithm stephen warshall
stephen warshall discovered
warshall discovered war
discovered war convenient
war convenient assume
convenient assume digraph
assume digraph vertices
digraph vertices rows
vertices rows columns
rows columns adjacency
adjacency matrix numbered
matrix numbered warshall
numbered warshall algorithm
warshall algorithm constructs
algorithm constructs transitive
constructs transitive closure
transitive closure series
closure series boolean
series boolean matrices
boolean matrices information
matrices information directed
information directed paths
directed paths digraph
paths digraph specifically
digraph specifically element
matrix equal exists
equal exists directed
vertices paths adjacency
paths adjacency matrix
matrix digraph recall
digraph recall adjacency
adjacency matrix information
matrix information edge
information edge paths
edge paths intermediate
intermediate vertices information
vertices information paths
information paths vertex
paths vertex intermediate
vertex intermediate freedom
intermediate freedom speak
freedom speak general
speak general subsequent
general subsequent matrix
subsequent matrix series
matrix series vertex
series vertex intermediate
intermediate paths predecessor
paths predecessor matrix
predecessor matrix series
matrix series reflects
series reflects paths
reflects paths vertices
paths vertices digraph
vertices digraph intermediate
digraph intermediate digraph
intermediate digraph transitive
digraph transitive closure
transitive closure central
closure central algorithm
central algorithm compute
matrix equal means
equal means exists
exists path ith
numbered higher figure
higher figure changing
figure changing zeros
changing zeros warshall
zeros warshall algorithm
warshall algorithm situations
algorithm situations path
situations path inter
path inter mediate
inter mediate vertices
mediate vertices kth
vertices kth vertex
kth vertex path
vertex path intermediate
path intermediate vertices
higher equal possibility
equal possibility path
possibility path kth
path kth vertex
intermediate vertices loss
vertices loss generality
loss generality assume
generality assume occurs
assume occurs case
occurs case create
case create path
create path property
path property simply
property simply eliminating
simply eliminating vertices
eliminating vertices occurrences
vertices occurrences caveat
occurrences caveat path
caveat path rewritten
path rewritten vertices
rewritten vertices numbered
vertices numbered representation
numbered representation means
representation means exists
numbered higher means
higher means exists
numbered higher proved
higher proved easy
proved easy converse
easy converse assertion
converse assertion true
assertion true formula
true formula generating
formula generating elements
elements matrix formula
matrix formula heart
formula heart warshall
heart warshall algorithm
warshall algorithm formula
algorithm formula implies
formula implies generating
implies generating elements
elements matrix convenient
matrix convenient applying
convenient applying warshall
applying warshall algorithm
warshall algorithm element
algorithm element rij
element rij remains
rij remains element
remains element rij
element rij changed
rij changed element
changed element row
row column element
element column row
column row illustrated
row illustrated figure
illustrated figure application
algorithm digraph figure
digraph figure shown
shown figure existence
figure existence paths
intermediate vertices adjacency
vertices adjacency matrix
adjacency matrix boxed
matrix boxed row
numbered higher vertex
higher vertex path
vertex path boxed
path boxed row
higher paths figure
paths figure application
digraph shown bold
bold pseudocode warshall
warshall algorithm warshall
algorithm warshall implements
warshall implements warshall
implements warshall algorithm
transitive closure input
closure input adjacency
matrix digraph vertices
digraph vertices output
vertices output transitive
output transitive closure
closure digraph observations
digraph observations warshall
observations warshall algorithm
warshall algorithm remarkably
algorithm remarkably succinct
remarkably succinct efficiency
succinct efficiency fact
efficiency fact sparse
fact sparse graphs
adjacency lists traversal
lists traversal based
based algorithm figure
algorithm figure digraph
figure digraph weight
weight matrix distance
matrix distance matrix
distance matrix mentioned
matrix mentioned beginning
beginning section asymptotic
section asymptotic efficiency
asymptotic efficiency warshall
warshall algorithm speed
algorithm speed implementation
speed implementation warshall
implementation warshall algorithm
warshall algorithm inputs
algorithm inputs restructuring
inputs restructuring innermost
restructuring innermost loop
innermost loop problem
loop problem section
exercises make algorithm
make algorithm run
run faster matrix
faster matrix rows
matrix rows bit
rows bit strings
bitwise operation modern
operation modern languages
modern languages space
languages space efficiency
space efficiency warshall
warshall algorithm situation
algorithm situation similar
situation similar computing
similar computing fibonacci
computing fibonacci dynamic
fibonacci dynamic programming
programming algorithms matrices
algorithms matrices recording
matrices recording intermediate
recording intermediate results
intermediate results algorithm
results algorithm fact
algorithm fact unnecessary
fact unnecessary problem
unnecessary problem section
exercises asks avoiding
asks avoiding wasteful
avoiding wasteful memory
wasteful memory finally
memory finally underlying
finally underlying idea
underlying idea warshall
idea warshall algorithm
warshall algorithm applied
algorithm applied general
applied general problem
general problem finding
problem finding lengths
finding lengths shortest
paths weighted graphs
weighted graphs floyd
graphs floyd algorithm
connected graph undirected
undirected directed pairs
directed pairs shortest
problem asks distances
asks distances lengths
vertex vertices variations
vertices variations problem
variations problem involving
problem involving shortest
involving shortest paths
shortest paths graphs
paths graphs important
graphs important applications
important applications communications
applications communications transportation
communications transportation networks
transportation networks operations
networks operations research
operations research studied
research studied years
studied years recent
years recent applications
recent applications pairs
applications pairs shortest
path problem precomputing
problem precomputing distances
precomputing distances motion
distances motion planning
motion planning games
planning games convenient
games convenient lengths
convenient lengths shortest
shortest paths matrix
paths matrix called
matrix called distance
called distance matrix
distance matrix element
matrix element dij
element dij ith
dij ith row
column matrix length
matrix length shortest
shortest path ith
ith vertex figure
vertex figure generate
figure generate distance
generate distance matrix
distance matrix algorithm
matrix algorithm similar
algorithm similar warshall
similar warshall algorithm
warshall algorithm called
algorithm called floyd
called floyd algorithm
floyd algorithm inventor
algorithm inventor robert
inventor robert floyd
robert floyd applicable
floyd applicable undirected
undirected directed weighted
weighted graphs provided
graphs provided floyd
provided floyd explicitly
floyd explicitly referenced
explicitly referenced warshall
referenced warshall paper
warshall paper presenting
paper presenting algorithm
presenting algorithm flo
algorithm flo years
flo years earlier
years earlier bernard
earlier bernard roy
bernard roy published
roy published essentially
published essentially algorithm
essentially algorithm proceedings
algorithm proceedings french
proceedings french academy
french academy sciences
academy sciences roy
sciences roy negative
roy negative length
negative length distance
length distance vertices
distance vertices arbitrarily
vertices arbitrarily small
arbitrarily small repeating
small repeating times
repeating times algorithm
times algorithm enhanced
algorithm enhanced lengths
enhanced lengths shortest
paths vertex pairs
vertex pairs shortest
paths problem section
section exercises floyd
exercises floyd algorithm
floyd algorithm computes
algorithm computes distance
computes distance matrix
distance matrix weighted
matrix weighted graph
graph vertices series
vertices series matrices
series matrices lengths
matrices lengths shortest
shortest paths constraints
paths constraints paths
constraints paths considered
paths considered matrix
considered matrix specifically
matrix specifically element
matrix equal length
vertices paths simply
paths simply weight
graph matrix series
matrix series lengths
series lengths shortest
paths vertices intermediate
vertices intermediate distance
intermediate distance matrix
distance matrix sought
matrix sought warshall
sought warshall algorithm
warshall algorithm compute
column matrix means
matrix means equal
means equal length
numbered higher partition
higher partition paths
partition paths disjoint
paths disjoint subsets
disjoint subsets kth
subsets kth vertex
intermediate paths subset
paths subset intermediate
subset intermediate vertices
higher shortest definition
shortest definition matrices
definition matrices length
matrices length shortest
shortest path subset
path subset graph
subset graph negative
negative length limit
length limit attention
limit attention paths
attention paths subset
paths subset vertex
subset vertex intermediate
intermediate vertex visiting
vertex visiting path
visiting path length
path length paths
length paths vertices
paths vertices numbered
vertices numbered words
numbered words paths
words paths path
paths path intermediate
numbered higher path
higher path intermediate
numbered higher situation
higher situation depicted
situation depicted symbolically
depicted symbolically figure
symbolically figure length
figure length shortest
paths intermediate figure
intermediate figure underlying
figure underlying idea
underlying idea floyd
idea floyd algorithm
floyd algorithm vertices
algorithm vertices numbered
path paths kth
paths kth vertex
kth vertex equal
vertex equal taking
equal taking account
taking account lengths
account lengths shortest
shortest paths subsets
paths subsets leads
subsets leads recurrence
leads recurrence min
recurrence min wij
min wij element
wij element row
row column current
column current distance
current distance matrix
distance matrix replaced
matrix replaced sum
replaced sum elements
sum elements row
elements row column
column row sum
row sum smaller
sum smaller current
smaller current application
current application floyd
floyd algorithm graph
algorithm graph figure
graph figure illustrated
figure pseudocode floyd
pseudocode floyd algorithm
floyd algorithm takes
takes advantage fact
advantage fact matrix
fact matrix sequence
matrix sequence written
sequence written predecessor
written predecessor algorithm
predecessor algorithm floyd
algorithm floyd implements
floyd implements floyd
implements floyd algorithm
paths problem input
problem input weight
input weight matrix
matrix graph negative
negative length output
length output distance
output distance matrix
distance matrix shortest
matrix shortest paths
paths lengths overwritten
lengths overwritten min
overwritten min efficiency
min efficiency floyd
efficiency floyd algorithm
floyd algorithm cubic
cubic efficiency warshall
warshall algorithm chapter
algorithm chapter dijkstra
chapter dijkstra algorithm
dijkstra algorithm method
algorithm method finding
method finding shortest
intermediate vertices simply
vertices simply weight
weight matrix lengths
matrix lengths shortest
shortest path lengths
path lengths shortest
shortest path figure
path figure application
figure application floyd
floyd algorithm digraph
digraph shown updated
shown updated elements
updated elements shown
elements shown bold
shown bold exercises
bold exercises apply
exercises apply warshall
closure digraph fined
digraph fined adjacency
adjacency matrix prove
matrix prove efficiency
prove efficiency warshall
warshall algorithm cubic
cubic efficiency class
efficiency class warshall
class warshall algorithm
warshall algorithm inferior
algorithm inferior traversal
inferior traversal based
based algorithm sparse
algorithm sparse graphs
adjacency lists implement
lists implement warshall
implement warshall algorithm
warshall algorithm extra
extra memory storing
memory storing elements
storing elements algorithm
elements algorithm intermediate
algorithm intermediate matrices
intermediate matrices restructure
matrices restructure innermost
restructure innermost loop
loop algorithm warshall
algorithm warshall make
warshall make run
make run faster
run faster inputs
faster inputs rewrite
inputs rewrite pseudocode
rewrite pseudocode warshall
warshall algorithm assuming
algorithm assuming matrix
assuming matrix rows
matrix rows represented
rows represented bit
represented bit strings
bitwise operation formed
operation formed warshall
formed warshall algorithm
warshall algorithm determine
algorithm determine digraph
determine digraph dag
acyclic graph good
graph good algorithm
algorithm problem good
problem good idea
good idea apply
idea apply warshall
transitive closure undirected
closure undirected graph
undirected graph solve
graph solve pairs
solve pairs shortest
path problem digraph
problem digraph weight
prove matrix sequence
matrix sequence floyd
sequence floyd algorithm
floyd algorithm written
algorithm written predecessor
written predecessor graph
predecessor graph digraph
graph digraph negative
digraph negative weights
negative weights floyd
weights floyd algorithm
floyd algorithm yield
algorithm yield result
yield result enhance
result enhance floyd
enhance floyd algorithm
floyd algorithm shortest
algorithm shortest paths
paths lengths jack
lengths jack straws
jack straws game
straws game jack
game jack straws
jack straws plastic
straws plastic wooden
plastic wooden straws
wooden straws dumped
straws dumped table
dumped table players
table players disturbing
players disturbing straws
disturbing straws concerned
straws concerned pairs
concerned pairs straws
straws connected path
connected path touching
path touching straws
touching straws endpoints
straws endpoints straws
endpoints straws dumped
straws dumped large
dumped large piece
large piece graph
piece graph paper
graph paper determine
paper determine pairs
determine pairs straws
straws connected touching
connected touching connecting
touching connecting straws
connecting straws connected
straws connected indirectly
connected indirectly connected
indirectly connected straws
connected straws east
straws east central
east central regionals
central regionals acm
regionals acm international
acm international collegiate
international collegiate programming
collegiate programming contest
programming contest summary
contest summary dynamic
summary dynamic programming
smaller subproblems dynamic
solving smaller subproblem
smaller subproblem recording
subproblem recording results
problem obtained applicability
obtained applicability dynamic
applicability dynamic programming
dynamic programming optimization
programming optimization problem
optimization problem requires
problem requires problem
requires problem principle
problem principle optimality
principle optimality optimal
optimality optimal solution
optimal solution instances
solution instances optimal
instances optimal solutions
optimal solutions subinstances
solutions subinstances problems
subinstances problems making
problems making problem
making problem arbitrary
problem arbitrary coin
arbitrary coin denominations
coin denominations solved
denominations solved dynamic
solved dynamic programming
dynamic programming solving
programming solving knapsack
programming algorithm exemplifies
algorithm exemplifies application
exemplifies application technique
application technique difficult
technique difficult problems
difficult problems combinatorial
problems combinatorial optimization
combinatorial optimization memory
optimization memory function
memory function technique
function technique seeks
technique seeks combine
seeks combine strengths
combine strengths topdown
strengths topdown approaches
topdown approaches solving
overlapping subproblems solving
subproblems solving fashion
solving fashion subproblems
fashion subproblems problem
subproblems problem recording
problem recording solutions
recording solutions table
solutions table dynamic
dynamic programming constructing
programming constructing optimal
set keys probabilities
keys probabilities searching
probabilities searching warshall
searching warshall algorithm
warshall algorithm finding
algorithm finding transitive
finding transitive closure
transitive closure floyd
closure floyd algorithm
paths problem based
based idea interpreted
idea interpreted application
interpreted application dynamic
section important problem
cnxn subject ainxn
solving linear programming
bounded feasible region
pivot row pivot
row pivot row
single source single
free vertex free
bfs traversal graph
set men set
problems computational geometry
sort input array
output array sorted
array sorted nondecreasing
basic operation algorithm
matrix representation adjacency
straight line points
algorithm matrix multiplication
efficiency class brute
convex polygon vertices
determine worst case
computing square root
traversal graph traversal
algorithm average case
array real numbers
binary digits binary
represented adjacency lists
prays miracle prayer
miracle prayer reduces
prayer reduces great
reduces great god
great god grant
god grant ivan
grant ivan turgenev
ivan turgenev russian
turgenev russian novelist
russian novelist short
novelist short story
short story writer
story writer conquer
writer conquer general
design technique fame
technique fame catchy
fame catchy deserved
catchy deserved efficient
deserved efficient algorithms
efficient algorithms specific
algorithms specific implementations
specific implementations general
implementations general strategy
general strategy conquer
strategy conquer algorithms
conquer algorithms general
algorithms general problem
general problem divided
problem divided subproblems
divided subproblems ideally
equal size subproblems
size subproblems solved
subproblems solved typically
solved typically recursively
typically recursively dif
recursively dif ferent
dif ferent algorithm
ferent algorithm employed
algorithm employed subproblems
employed subproblems small
subproblems small solutions
small solutions subproblems
solutions subproblems combined
subproblems combined solution
combined solution original
original problem conquer
problem conquer technique
conquer technique diagrammed
technique diagrammed figure
diagrammed figure depicts
figure depicts case
depicts case dividing
case dividing problem
dividing problem smaller
smaller subproblems widely
subproblems widely occurring
widely occurring case
occurring case conquer
case conquer algorithms
conquer algorithms designed
designed executed single
executed single processor
single processor problem
processor problem computing
problem computing sum
sum numbers problem
numbers problem instances
instances problem compute
problem compute sum
sum numbers compute
numbers compute sum
compute sum remaining
sum remaining numbers
remaining numbers simply
numbers simply sums
simply sums computed
sums computed applying
computed applying method
applying method recursively
method recursively values
recursively values sum
values sum efficient
sum efficient compute
efficient compute sum
sum numbers moment
numbers moment reflection
moment reflection efficient
reflection efficient brute
efficient brute summation
brute summation problem
summation problem size
problem figure conquer
figure conquer technique
conquer technique typical
technique typical case
typical case small
case small summing
small summing numbers
summing numbers algorithm
numbers algorithm formal
formal analysis common
analysis common sense
common sense compute
sense compute sums
compute sums lead
sums lead negative
lead negative conquer
negative conquer algorithm

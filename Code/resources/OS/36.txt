Interrupts
14   CHAPTER 1 / COMPUTER SYSTEM OVERVIEW
1.4        INTERRUPTS
           Virtually all computers provide a mechanism by which other modules (I/O, mem-
           ory) may interrupt the normal sequencing of the processor. Table 1.1 lists the most
           common classes of interrupts.
              Interrupts are provided primarily as a way to improve processor utilization.
           For example, most I/O devices are much slower than the processor. Suppose that
           the processor is transferring data to a printer using the instruction cycle scheme of
           Figure 1.2. After each write operation, the processor must pause and remain idle
           until the printer catches up. The length of this pause may be on the order of many
           thousands or even millions of instruction cycles. Clearly, this is a very wasteful use
           of the processor.
              To give a specific example, consider a PC that operates at 1 GHz, which would
           allow roughly 109 instructions per second.2 A typical hard disk has a rotational
           speed of 7200 revolutions per minute for a half-track rotation time of 4 ms, which is
           4 million times slower than the processor.
              Figure 1.5a illustrates this state of affairs. The user program performs a series of
           WRITE calls interleaved with processing. The solid vertical lines represent segments
           of code in a program. Code segments 1, 2, and 3 refer to sequences of instructions that
           do not involve I/O. The WRITE calls are to an I/O routine that is a system utility and
           that will perform the actual I/O operation. The I/O program consists of three sections:
           ·  A sequence of instructions, labeled 4 in the figure, to prepare for the actual
              I/O operation. This may include copying the data to be output into a special
              buffer and preparing the parameters for a device command.
           ·  The actual I/O command. Without the use of interrupts, once this command
              is issued, the program must wait for the I/O device to perform the requested
              function (or periodically check the status, or poll, the I/O device). The program
              might wait by simply repeatedly performing a test operation to determine if
              the I/O operation is done.
           ·  A sequence of instructions, labeled 5 in the figure, to complete the operation.
              This may include setting a flag indicating the success or failure of the operation.
Table 1.1  Classes  of Interrupts
Program             Generated by some condition that occurs as a result of an instruction execution, such as
                    arithmetic overflow, division by zero, attempt to execute an illegal machine instruction,
                    and reference outside a user's allowed memory space.
Timer               Generated by a timer within the processor. This allows the operating system to perform
                    certain functions on a regular basis.
I/O                 Generated by an I/O controller, to signal normal completion of an operation or to signal
                    a variety of error conditions.
Hardware   failure  Generated by a failure, such as power failure or memory parity error.
           2A discussion of the uses of numerical prefixes, such as giga and tera, is contained in a supporting docu-
           ment at the Computer Science Student Resource Site at ComputerScienceStudent.com.

                                                                                    1.4 / INTERRUPTS                 15
User                           I/O      User     I/O                          User                              I/O
program                        program  program  program                      program    program
1                              4        1                                  4  1                                 4
                               I/O               I/O                                                            I/O
WRITE                          Command  WRITE    Command                      WRITE    Command
                               5
                                        2a
2                              END                                            2
                                                 Interrupt                             Interrupt
                                        2b       handler                                 handler
WRITE                                   WRITE                              5  WRITE                             5
                                        3a       END                                      END
3                                                                             3
                                        3b
WRITE                                   WRITE                                 WRITE
            (a) No interrupts              (b) Interrupts; short I/O wait        (c) Interrupts; long I/O wait
Figure 1.5  Program Flow of Control without and with Interrupts
            The dashed line represents the path of execution followed by the processor;
         that is, this line shows the sequence in which instructions are executed. Thus, after
         the first WRITE instruction is encountered, the user program is interrupted and
         execution continues with the I/O program. After the I/O program execution is com-
         plete, execution resumes in the user program immediately following the WRITE
         instruction.
            Because the I/O operation may take a relatively long time to complete, the I/O
         program is hung up waiting for the operation to complete; hence, the user program
         is stopped at the point of the WRITE call for some considerable period of time.
         Interrupts and the Instruction Cycle
         With interrupts, the processor can be engaged in executing other instructions while
         an I/O operation is in progress. Consider the flow of control in Figure 1.5b. As
         before, the user program reaches a point at which it makes a system call in the form
         of a WRITE call. The I/O program that is invoked in this case consists only of the
         preparation code and the actual I/O command. After these few instructions have
         been executed, control returns to the user program. Meanwhile, the external device
         is busy accepting data from computer memory and printing it. This I/O operation is
         conducted concurrently with the execution of instructions in the user program.
            When the external device becomes ready to be serviced, that is, when it is
         ready to accept more data from the processor, the I/O module for that external
         device sends an interrupt request signal to the processor. The processor responds by
         suspending operation of the current program; branching off to a routine to service

16  CHAPTER  1  /  COMPUTER     SYSTEM OVERVIEW
                                    User program                      Interrupt handler
                                1
                                2
                   Interrupt    i
                   occurs here  i1
                                M
                Figure 1.6      Transfer of Control via Interrupts
    that particular I/O device, known as an interrupt handler; and resuming the original
    execution after the device is serviced. The points at which such interrupts occur are
    indicated by   in Figure 1.5b. Note that an interrupt can occur at any point in the
    main program, not just at one specific instruction.
    For the user program, an interrupt suspends the normal sequence of execu-
    tion. When the interrupt processing is completed, execution resumes (Figure 1.6).
    Thus, the user program does not have to contain any special code to accommodate
    interrupts; the processor and the OS are responsible for suspending the user pro-
    gram and then resuming it at the same point.
    To accommodate interrupts, an interrupt stage is added to the instruction cycle,
    as shown in Figure 1.7 (compare Figure 1.2). In the interrupt stage, the processor
    checks to see if any interrupts have occurred, indicated by the presence of an inter-
    rupt signal. If no interrupts are pending, the processor proceeds to the fetch stage
    and fetches the next instruction of the current program. If an interrupt is pending,
                                Fetch stage           Execute stage                         Interrupt stage
                                                                    Interrupts
                                                                    disabled
                                                                                            Check for
    START                       Fetch next               Execute                            interrupt;
                                instruction              instruction            Interrupts  initiate interrupt
                                                                                enabled     handler
                                                         HALT
    Figure 1.7     Instruction Cycle with Interrupts

                                                   1.4 / INTERRUPTS                     17
the processor suspends execution of the current program and executes an interrupt-
handler routine. The interrupt-handler routine is generally part of the OS. Typically,
this routine determines the nature of the interrupt and performs whatever actions
are needed. In the example we have been using, the handler determines which I/O
module generated the interrupt and may branch to a program that will write more
data out to that I/O module. When the interrupt-handler routine is completed, the
processor can resume execution of the user program at the point of interruption.
It is clear that there is some overhead involved in this process. Extra instruc-
tions must be executed (in the interrupt handler) to determine the nature of the
interrupt and to decide on the appropriate action. Nevertheless, because of the
relatively large amount of time that would be wasted by simply waiting on an I/O
operation, the processor can be employed much more efficiently with the use of
interrupts.
To appreciate the gain in efficiency, consider Figure 1.8, which is a timing dia-
gram based on the flow of control in Figures 1.5a and 1.5b. Figures 1.5b and 1.8
Time
             1                                  1
             4                                  4
             Processor               I/O        2a                          I/O
             wait                    operation                          operation
             5                                  5
                                                2b
             2
                                                4
             4                                  3a                          I/O
                                                                        operation
             Processor               I/O        5
             wait                    operation
             5                                  3b
             3                                  (b) With interrupts
                                                (circled numbers refer
                                                to numbers in Figure 1.5b)
             (a) Without interrupts
             (circled numbers refer
to numbers in Figure 1.5a)
Figure 1.8   Program Timing: Short I/O Wait

18  CHAPTER 1 / COMPUTER SYSTEM OVERVIEW
    assume that the time required for the I/O operation is relatively short: less than the
    time to complete the execution of instructions between write operations in the user
    program. The more typical case, especially for a slow device such as a printer, is
    that the I/O operation will take much more time than executing a sequence of user
    instructions. Figure 1.5c indicates this state of affairs. In this case, the user program
    reaches the second WRITE call before the I/O operation spawned by the first call is
    complete. The result is that the user program is hung up at that point. When the pre-
    ceding I/O operation is completed, this new WRITE call may be processed, and a
    new I/O operation may be started. Figure 1.9 shows the timing for this situation with
    and without the use of interrupts. We can see that there is still a gain in efficiency
    because part of the time during which the I/O operation is underway overlaps with
    the execution of user instructions.
    Time
                1                                     1
                4                                     4
          Processor             I/O                   2
                wait            operation
                                                                                  I/O
                                                                              operation
                5                                     Processor
                                                      wait
                2                                     5
                                                      4
                4
                                                      3
          Processor             I/O                                               I/O
                wait            operation                                     operation
                                                      Processor
                                                      wait
                5
                                                      5
                3                                     (b) With interrupts
                                                      (circled numbers refer
                                                      to numbers in Figure 1.5c)
    (a) Without interrupts
    (circled numbers refer
    to numbers in Figure 1.5a)
    Figure 1.9  Program Timing: Long       I/O  Wait

                                                                           1.4 / INTERRUPTS                19
Interrupt Processing
An interrupt triggers a number of events, both in the processor hardware and in
software. Figure 1.10 shows a typical sequence. When an I/O device completes an
I/O operation, the following sequence of hardware events occurs:
1.  The device issues an interrupt signal to the processor.
2.  The processor finishes execution of the current instruction before responding
    to the interrupt, as indicated in Figure 1.7.
3.  The processor tests for a pending interrupt request, determines that there is
    one, and sends an acknowledgment signal to the device that issued the inter-
    rupt. The acknowledgment allows the device to remove its interrupt signal.
4.  The processor next needs to prepare to transfer control to the interrupt rou-
    tine. To begin, it saves information needed to resume the current program at
    the point of interrupt. The minimum information required is the program sta-
    tus word3 (PSW) and the location of the next instruction to be executed, which
           Hardware                                           Software
    Device controller or
    other system hardware
    issues an interrupt
                                                              Save remainder of
                                                              process state
                                                              information
    Processor finishes
    execution of current
    instruction
                                                              Process interrupt
    Processor signals
    acknowledgment
    of interrupt
                                                              Restore process state
                                                              information
    Processor pushes PSW
    and PC onto control
    stack
                                                              Restore old PSW
                                                              and PC
    Processor loads new
    PC value based on
    interrupt
    Figure 1.10       Simple Interrupt Processing
3The PSW contains status information about the currently running process, including memory usage
information, condition codes, and other status information, such as an interrupt enable/disable bit and a
kernel/user mode bit. See Appendix C for further discussion.

20  CHAPTER 1 / COMPUTER SYSTEM OVERVIEW
        is contained in the program counter (PC). These can be pushed onto a control
        stack (see Appendix P).
    5.  The processor then loads the program counter with the entry location of the
        interrupt-handling routine that will respond to this interrupt. Depending on
        the computer architecture and OS design, there may be a single program,
        one for each type of interrupt, or one for each device and each type of inter-
        rupt. If there is more than one interrupt-handling routine, the processor must
        determine which one to invoke. This information may have been included in
        the original interrupt signal, or the processor may have to issue a request to
        the device that issued the interrupt to get a response that contains the needed
        information.
        Once the program counter has been loaded, the processor proceeds to the next
    instruction cycle, which begins with an instruction fetch. Because the instruction
    fetch is determined by the contents of the program counter, control is transferred to
    the interrupt-handler program. The execution of this program results in the follow-
    ing operations:
    6.  At this point, the program counter and PSW relating to the interrupted
        program have been saved on the control stack. However, there is other in-
        formation that is considered part of the state of the executing program. In
        particular, the contents of the processor registers need to be saved, because
        these registers may be used by the interrupt handler. So all of these values,
        plus any other state information, need to be saved. Typically, the interrupt
        handler will begin by saving the contents of all registers on the stack. Other
        state information that must be saved is discussed in Chapter 3. Figure 1.11a
        shows a simple example. In this case, a user program is interrupted after the
        instruction at location N. The contents of all of the registers plus the address
        of the next instruction (N  1), a total of M words, are pushed onto the control
        stack. The stack pointer is updated to point to the new top of stack, and the
        program counter is updated to point to the beginning of the interrupt service
        routine.
    7.  The interrupt handler may now proceed to process the interrupt. This includes
        an examination of status information relating to the I/O operation or other
        event that caused an interrupt. It may also involve sending additional com-
        mands or acknowledgments to the I/O device.
    8.  When interrupt processing is complete, the saved register values are retrieved
        from the stack and restored to the registers (e.g., see Figure 1.11b).
    9.  The final act is to restore the PSW and program counter values from the stack.
        As a result, the next instruction to be executed will be from the previously
        interrupted program.
        It is important to save all of the state information about the interrupted pro-
    gram for later resumption. This is because the interrupt is not a routine called from
    the program. Rather, the interrupt can occur at any time and therefore at any point
    in the execution of a user program. Its occurrence is unpredictable.

                                                                          1.4 / INTERRUPTS         21
TM                                                 TM             N1
Control                                        Y   Control
stack                                              stack
         T                                                     T
                                    N+1                                              YL1
                                    Program                                          Program
                                    counter                                          counter
         Y   Start                  General                    Y  Start              General
                     Interrupt                                            Interrupt
                     service        registers                             service    registers
YL           Return  routine                       YL             Return  routine
                                    T                                                TM
                                    Stack                                            Stack
                                    pointer                                          pointer
                                Processor                                            Processor
                                               TM                                                  T
         N           User's                                    N          User's
N1                   program                       N1                     program
             Main                                                 Main
            memory                                                memory
(a) Interrupt occurs after instruction                            (b) Return from interrupt
                     at location N
Figure 1.11  Changes in Memory and Registers for an Interrupt
         Multiple Interrupts
         So far, we have discussed the occurrence of a single interrupt. Suppose, however,
         that one or more interrupts can occur while an interrupt is being processed. For
         example, a program may be receiving data from a communications line and print-
         ing results at the same time. The printer will generate an interrupt every time that
         it completes a print operation. The communication line controller will generate an
         interrupt every time a unit of data arrives. The unit could either be a single character
         or a block, depending on the nature of the communications discipline. In any case, it
         is possible for a communications interrupt to occur while a printer interrupt is being
         processed.

22  CHAPTER 1 / COMPUTER SYSTEM OVERVIEW
    Two approaches can be taken to dealing with multiple interrupts. The first
    is to disable interrupts while an interrupt is being processed. A disabled interrupt
    simply means that the processor ignores any new interrupt request signal. If an
    interrupt occurs during this time, it generally remains pending and will be checked
    by the processor after the processor has reenabled interrupts. Thus, if an interrupt
    occurs when a user program is executing, then interrupts are disabled immediately.
    After the interrupt-handler routine completes, interrupts are reenabled before
    resuming the user program, and the processor checks to see if additional interrupts
    have occurred. This approach is simple, as interrupts are handled in strict sequential
    order (Figure 1.12a).
                                         Interrupt
    User program                         handler X
                                                                         Interrupt
                                                                         handler Y
    (a) Sequential interrupt processing
                                         Interrupt
    User program                         handler X
                                                                         Interrupt
                                                                         handler Y
    (b) Nested interrupt processing
    Figure 1.12            Transfer of Control with Multiple Interrupts

                                                                                  1.4 / INTERRUPTS  23
The drawback to the preceding approach is that it does not take into account
relative priority or time-critical needs. For example, when input arrives from the
communications line, it may need to be absorbed rapidly to make room for more
input. If the first batch of input has not been processed before the second batch
arrives, data may be lost because the buffer on the I/O device may fill and overflow.
A second approach is to define priorities for interrupts and to allow an inter-
rupt of higher priority to cause a lower-priority interrupt handler to be interrupted
(Figure 1.12b). As an example of this second approach, consider a system with three
I/O devices: a printer, a disk, and a communications line, with increasing priorities of
2, 4, and 5, respectively. Figure 1.13, based on an example in [TANE06], illustrates
a possible sequence. A user program begins at t  0. At t  10, a printer interrupt
occurs; user information is placed on the control stack and execution continues at
the printer interrupt service routine (ISR). While this routine is still executing, at
t  15 a communications interrupt occurs. Because the communications line has
higher priority than the printer, the interrupt request is honored. The printer ISR is
interrupted, its state is pushed onto the stack, and execution continues at the com-
munications ISR. While this routine is executing, a disk interrupt occurs (t  20).
Because this interrupt is of lower priority, it is simply held, and the communications
ISR runs to completion.
When the communications ISR is complete (t  25), the previous processor
state is restored, which is the execution of the printer ISR. However, before even a
single instruction in that routine can be executed, the processor honors the higher-
priority disk interrupt and transfers control to the disk ISR. Only when that routine
is complete (t  35) is the printer ISR resumed. When that routine completes
(t  40), control finally returns to the user program.
User program             Printer                       Communication
                     interrupt service routine         interrupt service routine
t0
              t  10                             t  15
                                                t  25
              t  40                                    t  25                      Disk
                                                                                  interrupt service routine
                                                       t  35
Figure 1.13   Example Time Sequence of Multiple Interrupts

24  CHAPTER 1 / COMPUTER SYSTEM OVERVIEW
1.5  THE MEMORY HIERARCHY
     The design constraints on a computer's memory can be summed up by three ques-
     tions: How much? How fast? How expensive?
         The question of how much is somewhat open ended. If the capacity is there,
     applications will likely be developed to use it. The question of how fast is, in a sense,
     easier to answer. To achieve greatest performance, the memory must be able to
     keep up with the processor. That is, as the processor is executing instructions, we
     would not want it to have to pause waiting for instructions or operands. The final
     question must also be considered. For a practical system, the cost of memory must
     be reasonable in relationship to other components.
         As might be expected, there is a trade-off among the three key characteristics
     of memory: namely, capacity, access time, and cost. A variety of technologies are
     used to implement memory systems, and across this spectrum of technologies, the
     following relationships hold:
     ·   Faster access time, greater cost per bit
     ·   Greater capacity, smaller cost per bit
     ·   Greater capacity, slower access speed
         The dilemma facing the designer is clear. The designer would like to use
     memory technologies that provide for large-capacity memory, both because the
     capacity is needed and because the cost per bit is low. However, to meet perform-
     ance requirements, the designer needs to use expensive, relatively lower-capacity
     memories with fast access times.
         The way out of this dilemma is to not rely on a single memory component or
     technology, but to employ a memory hierarchy. A typical hierarchy is illustrated in
     Figure 1.14. As one goes down the hierarchy, the following occur:
     a.  Decreasing cost per bit
     b.  Increasing capacity
     c.  Increasing access time
     d.  Decreasing frequency of access to the memory by the processor
         Thus, smaller, more expensive, faster memories are supplemented by larger,
     cheaper, slower memories. The key to the success of this organization is the decreas-
     ing frequency of access at lower levels. We will examine this concept in greater
     detail later in this chapter, when we discuss the cache, and when we discuss virtual
     memory later in this book. A brief explanation is provided at this point.
         Suppose that the processor has access to two levels of memory. Level 1 con-
     tains 1,000 bytes and has an access time of 0.1 s; level 2 contains 100,000 bytes and
     has an access time of 1 s. Assume that if a byte to be accessed is in level 1, then
     the processor accesses it directly. If it is in level 2, then the byte is first transferred
     to level 1 and then accessed by the processor. For simplicity, we ignore the time
     required for the processor to determine whether the byte is in level 1 or level 2.

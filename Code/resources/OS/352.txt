Recommended Reading
330  CHAPTER 7 / MEMORY MANAGEMENT
     vulnerable programs. What the attacker     does with the resulting corruption             of
     memory varies considerably, depending on   what values are being overwritten.
     Defending against Buffer Overflows
     Finding and exploiting a stack buffer overflow is not that difficult. The large num-
     ber of exploits over the previous couple of decades clearly illustrates this. There
     is consequently a need to defend systems against such attacks by either prevent-
     ing them or at least detecting and aborting such attacks. Countermeasures can be
     broadly classified into two categories:
     ·  Compile-time defenses, which aim to harden programs to resist attacks in new
        programs
     ·  Run-time defenses, which aim to detect and abort attacks in existing programs
        While suitable defenses have been known for a couple of decades, the very
     large existing base of vulnerable software and systems hinders their deployment.
     Hence the interest in run-time defenses, which can be deployed in operating
     systems and updates and can provide some protection for existing vulnerable
     programs.
7.6  SUMMARY
     One of the most important and complex tasks of an operating system is memory
     management. Memory management involves treating main memory as a resource
     to be allocated to and shared among a number of active processes. To use the pro-
     cessor and the I/O facilities efficiently, it is desirable to maintain as many processes
     in main memory as possible. In addition, it is desirable to free programmers from
     size restrictions in program development.
        The basic tools of memory management are paging and segmentation. With
     paging, each process is divided into relatively small, fixed-size pages. Segmentation
     provides for the use of pieces of varying size. It is also possible to combine segmen-
     tation and paging in a single memory management scheme.
7.7  RECOMMENDED READING
     Because partitioning has been supplanted by virtual memory techniques, most OS
     books offer only cursory coverage. One of the more complete and interesting treat-
     ments is in [MILE92]. A thorough discussion of partitioning strategies is found in
     [KNUT97].
        The topics of linking and loading are covered in many books on program
     development, computer architecture, and operating systems. A particularly detailed
     treatment is [BECK97]. [CLAR98] also contains a good discussion. A thorough
     practical discussion of this topic, with numerous OS examples, is [LEVI00].

                           7.8 / KEY TERMS, REVIEW QUESTIONS, AND PROBLEMS                     331
       BECK97          Beck, L. System Software. Reading, MA: Addison-Wesley, 1997.
       CLAR98          Clarke, D., and Merusi, D. System Software Programming: The Way Things
                 Work. Upper Saddle River, NJ: Prentice Hall, 1998.
       KNUT97          Knuth, D. The Art of Computer Programming, Volume 1: Fundamental
                 Algorithms. Reading, MA: Addison-Wesley, 1997.
       LEVI00       Levine, J. Linkers and Loaders. San Francisco: Morgan Kaufmann, 2000.
       MILE92          Milenkovic, M. Operating Systems: Concepts and Design. New York:
                 McGraw-Hill, 1992.
7.8    KEY TERMS,          REVIEW QUESTIONS,                   AND PROBLEMS
Key Terms
absolute loading           linkage editor                            physical address
buddy system               linking                                   physical organization
compaction                 loading                                   protection
dynamic linking            logical address                           relative address
dynamic partitioning       logical organization                      relocatable loading
dynamic run-time loading   memory management                         relocation
external fragmentation     page                                      segment
fixed partitioning         page table                                segmentation
frame                      paging                                    sharing
internal fragmentation     partitioning
       Review Questions
       7.1    What requirements is memory management intended to satisfy?
       7.2    Why is the capability to relocate processes desirable?
       7.3    Why is it not possible to enforce memory protection at compile time?
       7.4    What are some reasons to allow two or more processes to all have access to a particu-
              lar region of memory?
       7.5    In    a  fixed-partitioning  scheme,  what  are  the   advantages  of    using  unequal-size
              partitions?
       7.6    What is the difference between internal and external fragmentation?
       7.7    What are the distinctions among logical, relative, and physical addresses?
       7.8    What is the difference between a page and a frame?
       7.9    What is the difference between a page and a segment?
       Problems
       7.1    In Section 2.3, we listed five objectives of memory management, and in Section 7.1,
              we listed five requirements. Argue that each list encompasses all of the concerns ad-
              dressed in the other.

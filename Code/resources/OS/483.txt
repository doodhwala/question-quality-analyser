UNIX SVR4 Scheduling
                                                      10.4 / UNIX SVR4 SCHEDULING                              461
          Timeslices are assigned in the range of 10­200 ms. In general, higher-priority
      tasks are assigned larger timeslices.
      RELATIONSHIP   TO      REAL-TIME       TASKS    Real-time  tasks       are  handled                      in  a
      different manner from non-real-time tasks in the priority queues. The following
      considerations apply:
      1.  All real-time tasks have only a static priority; no dynamic priority changes
          are made.
      2.  SCHED_FIFO tasks do not have assigned timeslices. Such tasks are scheduled
          in FIFO discipline. If a SHED_FIFO task is blocked, it returns to the same pri-
          ority queue in the active queue list when it becomes unblocked.
      3.  Although SCHED_RR tasks do have assigned timeslices, they also are never
          moved to the expired queue list. When a SCHED_RR task exhausts its timeslice,
          it is returned to its priority queue with the same timeslice value. Timeslice val-
          ues are never changed.
          The effect of these rules is that the switch between the active queue list and
      the expired queue list only happens when there are no ready real-time tasks waiting
      to execute.
10.4  UNIX SVR4 SCHEDULING
      The scheduling algorithm used in UNIX SVR4 is a complete overhaul of the sched-
      uling algorithm used in earlier UNIX systems (described in Section 9.3). The new
      algorithm is designed to give highest preference to real-time processes, next-highest
      preference to kernel-mode processes, and lowest preference to other user-mode
      processes, referred to as time-shared processes.6
          The two major modifications implemented in SVR4 are as follows:
      1.  The addition of a preemptable static priority scheduler and the introduction of
          a set of 160 priority levels divided into three priority classes.
      2.  The insertion of preemption points. Because the basic kernel is not preemp-
          tive, it can only be split into processing steps that must run to completion
          without interruption. In between the processing steps, safe places known as
          preemption points have been identified where the kernel can safely interrupt
          processing and schedule a new process. A safe place is defined as a region
          of code where all kernel data structures are either updated and consistent or
          locked via a semaphore.
          Figure 10.12 illustrates the 160 priority levels defined in SVR4. Each process
      is defined to belong to one of three priority classes and is assigned a priority level
      within that class. The classes are as follows:
      · Real time (159-100): Processes at these priority levels are guaranteed to be
          selected to run before any kernel or time-sharing process. In addition, real-time
      6Time-shared processes are the processes that correspond to users in a traditional time-sharing system.

462  CHAPTER      10  /  MULTIPROCESSOR AND REAL-TIME SCHEDULING
                                Priority      Global     Scheduling
                                class         value      sequence
                                              159        First
                                Real time
                                              100
                                              99
                                Kernel
                                              60
                                              59
                                Time shared
                                              0          Last
                                Figure 10.12  SVR4 Priority Classses
               processes can make use of preemption points to preempt kernel processes and
               user processes.
            ·  Kernel (99-60): Processes at these priority levels are guaranteed to be selected
               to run before any time-sharing process but must defer to real-time processes.
            ·  Time-shared (59-0): The lowest-priority processes, intended for user applica-
               tions other than real-time applications.
               Figure 10.13 indicates how scheduling is implemented in SVR4. A dispatch
     queue is associated with each priority level, and processes at a given priority level
     are executed in round-robin fashion. A bit-map vector, dqactmap, contains one bit
     for each priority level; the bit is set to one for any priority level with a nonempty
     queue. Whenever a running process leaves the Running state, due to a block, times-
     lice expiration, or preemption, the dispatcher checks dqactmap and dispatches a
     ready process from the highest-priority nonempty queue. In addition, whenever a
     defined preemption point is reached, the kernel checks a flag called kprunrun. If
     set, this indicates that at least one real-time process is in the Ready state, and the
     kernel preempts the current process if it is of lower priority than the highest-priority
     real-time ready process.
               Within the time-sharing class, the priority of a process is variable. The scheduler
     reduces the priority of a process each time it uses up a time quantum, and it raises its
dqactmap       0         1                                            1  1  0
     dispq  159          n                                            2  1  0
                         P                                            P  P
                         P                                            P
                         P                                            P
                         P
Figure 10.13      SVR4 Dispatch Queues

                                                          10.5 / UNIX FREEBSD SCHEDULING           463
      priority if it blocks on an event or resource. The time quantum allocated to a time-
      sharing process depends on its priority, ranging from 100 ms for priority 0 to 10 ms
      for priority 59. Each real-time process has a fixed priority and a fixed time quantum.
10.5  UNIX FREEBSD SCHEDULING
      The UNIX FreeBSD scheduler is designed to provide a more efficient operation
      than previous UNIX schedulers under heavy load and when used on a multiproces-
      sor or multicore platform. The scheduler is quite complex and here we present an
      overview of the most significant design features; for more detail, see [MCKU05]
      and [ROBE03].
      Priority Classes
      The underlying priority mechanism in the FreeBSD 5.1 scheduler is similar to that
      of UNIX SVR4. For FreeBSD, five priority classes are defined (Table 10.5); the
      first two classes are for kernel-mode thread and the remaining classes for user-mode
      threads. Kernel threads execute code that is complied into the kernel's load image
      and operate with the kernel's privileged execution code.
            The highest-priority threads are referred to as bottom-half kernel. Threads in
      this class run in the kernel are scheduled based on interrupt priorities. These pri-
      orities are set when the corresponding devices are configured and do not change.
      Top-half kernel threads also run in the kernel and execute various kernel functions.
      These priorities are set based on predefined priorities and never change.
            The next lower priority class is referred to as real-time user. A thread with a
      real-time priority is not subject to priority degradation. That is, a real-time thread
      maintains the priority it began with and does not drop to a lower priority as a result
      of using resources. Next comes the time-sharing user priority class. For threads in
      this class, priority is periodically recalculated based on a number of parameters,
      including the amount of processor time used, the amount of memory resources
      held, and other resource consumption parameters. The lowest range of priorities is
      referred to as the idle user class. This class is intended for applications that will only
      consume processor time when no other threads are ready to execute.
      Table 10.5  FreeBSD Thread Scheduling Classes
      Priority Class  Thread Type         Description
      0­63            Bottom-half kernel  Scheduled by interrupts. Can block to await a resource.
      64­127          Top-half kernel     Runs until blocked or done. Can block to await a resource.
      128­159         Real-time user      Allowed to run until blocked or until a higher-priority
                                          thread becomes available. Preemptive scheduling.
      160­223         Time-sharing user   Adjusts priorities based on processor usage.
      224­255         Idle user           Only run when there are no time sharing or real-time
                                          threads to run.
      Note: Lower number corresponds to higher priority.

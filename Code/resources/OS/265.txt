Summary
                                                                                    5.7 / SUMMARY               243
void    reader(int       i)                       void  controller()
{                                                 {
   message     rmsg;                                 while  (true)
        while     (true)     {                       {
           rmsg   =   i;                                if  (count     >   0)    {
           send   (readrequest,         rmsg);              if  (!empty      (finished))           {
           receive       (mbox[i],  rmsg);                      receive      (finished,         msg);
           READUNIT       ();                                   count++;
           rmsg   =   i;                                    }
           send   (finished,    rmsg);                      else   if  (!empty         (writerequest))          {
        }                                                       receive      (writerequest,           msg);
}                                                               writer_id        =     msg.id;
void    writer(int       j)                                     count     =  count        ­  100;
{                                                           }
   message     rmsg;                                        else   if  (!empty         (readrequest))        {
   while(true)        {                                         receive      (readrequest,            msg);
        rmsg   =  j;                                            count--;
        send   (writerequest,       rmsg);                      send   (msg.id,           "OK");
        receive   (mbox[j],     rmsg);                      }
        WRITEUNIT     ();                               }
        rmsg   =  j;                                    if  (count     ==    0)     {
        send   (finished,       rmsg);                      send   (writer_id,            "OK");
   }                                                        receive    (finished,            msg);
}                                                           count   =  100;
                                                        }
                                                        while   (count       <   0)    {
                                                            receive    (finished,            msg);
                                                            count++;
                                                        }
                                                     }
                                                  }
Figure 5.24    A Solution to the Readers/Writers  Problem Using Message Passing
               ·  If count < 0, then a writer has made a request and is being made to wait
                  to clear all active readers. Therefore, only "finished" messages should be
                  serviced.
   5.7     SUMMARY
           The central themes of modern operating systems are multiprogramming, multipro-
           cessing, and distributed processing. Fundamental to these themes, and fundamen-
           tal to the technology of OS design, is concurrency. When multiple processes are
           executing concurrently, either actually in the case of a multiprocessor system or vir-
           tually in the case of a single-processor multiprogramming system, issues of conflict
           resolution and cooperation arise.
                  Concurrent processes may interact in a number of ways. Processes that are
           unaware of each other may nevertheless compete for resources, such as processor
           time or access to I/O devices. Processes may be indirectly aware of one another
           because they share access to a common object, such as a block of main memory or
           a file. Finally, processes may be directly aware of each other and cooperate by the
           exchange of information. The key issues that arise in these interactions are mutual
           exclusion and deadlock.

244  CHAPTER 5 / CONCURRENCY: MUTUAL EXCLUSION AND SYNCHRONIZATION
     Mutual exclusion is a condition in which there is a set of concurrent processes,
     only one of which is able to access a given resource or perform a given function
     at any time. Mutual exclusion techniques can be used to resolve conflicts, such as
     competition for resources, and to synchronize processes so that they can coop-
     erate. An example of the latter is the producer/consumer model, in which one
     process is putting data into a buffer and one or more processes are extracting data
     from that buffer.
     One approach to supporting mutual exclusion involves the use of special-pur-
     pose machine instructions. This approach reduces overhead but is still inefficient
     because it uses busy waiting.
     Another approach to supporting mutual exclusion is to provide features within
     the OS. Two of the most common techniques are semaphores and message facili-
     ties. Semaphores are used for signaling among processes and can be readily used to
     enforce a mutual-exclusion discipline. Messages are useful for the enforcement of
     mutual exclusion and also provide an effective means of interprocess communication.
5.8  RECOMMENDED READING
     The misnamed Little Book of Semaphores (291 pages) [DOWN08] provides numer-
     ous examples of the uses of semaphores; available free online.
     [ANDR83] surveys many of the mechanisms described in this chapter.
     [BEN82] provides a very clear and even entertaining discussion of concurrency,
     mutual exclusion, semaphores, and other related topics. A more formal treatment,
     expanded to include distributed systems, is contained in [BEN06]. [AXFO88]
     is another readable and useful treatment; it also contains a number of problems
     with worked-out solutions. [RAYN86] is a comprehensive and lucid collection of
     algorithms for mutual exclusion, covering software (e.g., Dekker) and hardware
     approaches, as well as semaphores and messages. [HOAR85] is a very readable
     classic that presents a formal approach to defining sequential processes and concur-
     rency. [LAMP86] is a lengthy formal treatment of mutual exclusion. [RUDO90] is
     a useful aid in understanding concurrency. [BACO03] is a well-organized treatment
     of concurrency. [BIRR89] provides a good practical introduction to programming
     using concurrency. [BUHR95] is an exhaustive survey of monitors. [KANG98] is
     an instructive analysis of 12 different scheduling policies for the readers/writers
     problem.
     ANDR83    Andrews, G., and Schneider, F. "Concepts and Notations for Concurrent
     Programming." Computing Surveys, March 1983.
     AXFO88    Axford, T. Concurrent Programming: Fundamental Techniques for Real-
     Time and Parallel Software Design. New York: Wiley, 1988.
     BACO03    Bacon, J., and Harris, T. Operating Systems: Concurrent and Distributed
     Software Design. Reading, MA: Addison-Wesley, 2003.
     BEN82     Ben-Ari, M. Principles of Concurrent Programming. Englewood Cliffs, NJ:
     Prentice Hall, 1982.
